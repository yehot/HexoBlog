{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/favicon.ico","path":"favicon.ico","modified":1,"renderable":0},{"_id":"themes/maupassant/source/css/style.scss","path":"css/style.scss","modified":1,"renderable":1},{"_id":"themes/maupassant/source/css/jquery.fancybox.css","path":"css/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/maupassant/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1,"renderable":1},{"_id":"themes/maupassant/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/maupassant/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/maupassant/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/maupassant/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/maupassant/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/share.js","path":"js/share.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/search.js","path":"js/search.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/totop.js","path":"js/totop.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/smartresize.js","path":"js/smartresize.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/fancybox.js","path":"js/fancybox.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","path":"js/codeblock-resizer.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"da40c8fb47469adb5a8415316c46885541377f96","modified":1489125843000},{"_id":"source/favicon.ico","hash":"0f788e715691c76ce6364ae9d38cffdd71a10615","modified":1481994932000},{"_id":"themes/maupassant/_config.yml","hash":"8c21341a2876c2a1c9807be5e2c724a4e39166e3","modified":1479392060000},{"_id":"themes/maupassant/README.md","hash":"75d8c42569809961953d1934de445418c00ab94c","modified":1479392060000},{"_id":"themes/maupassant/LICENSE","hash":"019dc6a9aba02ae3aaabca45f39aecd6e8e7f1d8","modified":1479392060000},{"_id":"themes/maupassant/.travis.yml","hash":"0339959f29deddc365e8fe8bd85da524410b9a23","modified":1479392060000},{"_id":"themes/maupassant/package.json","hash":"81fb4e2ac051ecfb9a93f37b28910291b939771a","modified":1479392060000},{"_id":"source/_posts/.DS_Store","hash":"720cfa9ea17ebba7029d47a705c057377b7e0091","modified":1489126332000},{"_id":"source/_posts/20151129-project-contents.md","hash":"bbbdf65e977ab43acc2bbd4180876209cd1e8dfc","modified":1489126780000},{"_id":"source/_posts/20160405-YYFPSLabel-source-read.md","hash":"83f0987a627ccd14c57924faddb5a8bdb87f8df8","modified":1489126753000},{"_id":"source/_posts/20160531-ios-module-investigation.md","hash":"9753e0253911a652e9817593278dc781c74e53b0","modified":1489125802000},{"_id":"source/_posts/20160915-CTMediator-tutorials.md","hash":"cac3ab8a268998504e90a227662e03e1b8a3bfa7","modified":1489125348000},{"_id":"source/_posts/20160702-rutime-method-swiizzling.md","hash":"6612d15dbc9bd98f0ec104efce5412f61578dd84","modified":1489125577000},{"_id":"source/_posts/20161218-sina-sae-node-js-web-tutorial.md","hash":"d296a6797836fe28dc80f9fc5c829f2e94b78b53","modified":1489126331000},{"_id":"source/_posts/20170215-git-order-list.md","hash":"e1b3182862c8cefc60517e84b59452cc72ddbfcd","modified":1489124118000},{"_id":"source/_posts/hello-world.md","hash":"5a05db0e9179b6279f0ccffd0fb5236fefc3809a","modified":1489125460000},{"_id":"themes/maupassant/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1479392060000},{"_id":"themes/maupassant/.git/config","hash":"037345b11c41abb3dbbbd6e0242ced24979a7097","modified":1479392060000},{"_id":"themes/maupassant/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1479391899000},{"_id":"themes/maupassant/.git/index","hash":"57a7d870a2555e07f31a500f6f8d86980c6949d5","modified":1479392060000},{"_id":"themes/maupassant/.git/packed-refs","hash":"5728b18c986e633243326d7392ef895412449824","modified":1479392060000},{"_id":"themes/maupassant/layout/archive.jade","hash":"0050c883b4f202add71c8664d65e6072179e7190","modified":1479392060000},{"_id":"themes/maupassant/layout/base-without-sidebar.jade","hash":"1ad721de96784bf4253316b796db6200148d4152","modified":1479392060000},{"_id":"themes/maupassant/layout/base.jade","hash":"e648d878786ca17cd2d073ebd3db50f86d85d471","modified":1479392060000},{"_id":"themes/maupassant/layout/post.jade","hash":"9cf29fb0daed95935154ce0fa2b154df5a9b11b1","modified":1479392060000},{"_id":"themes/maupassant/layout/single-column.jade","hash":"c35fff4d9b331a41af5bc10f4278ec3d9da503db","modified":1479392060000},{"_id":"themes/maupassant/layout/page.jade","hash":"8d70fd3b93f2c9087a9ea7ec538dcc1d413bea01","modified":1479392060000},{"_id":"themes/maupassant/layout/index.jade","hash":"f842164f6cba007c1dfcd7fe7bba24736bc886a9","modified":1479392060000},{"_id":"themes/maupassant/layout/timeline.jade","hash":"f03d8df63a188543cfe4e85e76194abe081411a1","modified":1479392060000},{"_id":"themes/maupassant/languages/en.yml","hash":"e13ab1a2d2f1edbe67b4c035fd4667cb6a31db8e","modified":1479392060000},{"_id":"themes/maupassant/languages/fr-FR.yml","hash":"b47906ec0abf867fb3e3360bc046b7afb68aee25","modified":1479392060000},{"_id":"themes/maupassant/languages/es-ES.yml","hash":"58e1d04bcd1834fa9d2960e18e027abbbccbedc9","modified":1479392060000},{"_id":"themes/maupassant/languages/de-DE.yml","hash":"5d3556a885e355a8c2da65ef3e7b3ee36a628bfa","modified":1479392060000},{"_id":"themes/maupassant/languages/zh-CN.yml","hash":"ebacfa5d0c14d603e0d505757adb24c0bbe5dd13","modified":1479392060000},{"_id":"themes/maupassant/languages/ko.yml","hash":"909a33e0befa6978e8e72157c6b415b48551ee31","modified":1479392060000},{"_id":"themes/maupassant/languages/zh-TW.yml","hash":"56b65995c60e99dcebbf00168447fd225d28e5b2","modified":1479392060000},{"_id":"themes/maupassant/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1479391899000},{"_id":"themes/maupassant/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1479391899000},{"_id":"themes/maupassant/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1479391899000},{"_id":"themes/maupassant/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1479391899000},{"_id":"themes/maupassant/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1479391899000},{"_id":"themes/maupassant/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1479391899000},{"_id":"themes/maupassant/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1479391899000},{"_id":"themes/maupassant/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1479391899000},{"_id":"themes/maupassant/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1479391899000},{"_id":"themes/maupassant/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1479391899000},{"_id":"themes/maupassant/.git/logs/HEAD","hash":"92e274a6807833ba50fd29a4645e6d3b1f3a0c62","modified":1479392060000},{"_id":"themes/maupassant/layout/_partial/footer.jade","hash":"aa020b794e697e8e9612530c97c6295efde469fe","modified":1479392060000},{"_id":"themes/maupassant/layout/_partial/helpers.jade","hash":"acdf9e2d52ee86c831fa15ce1570930c5779bc78","modified":1479392060000},{"_id":"themes/maupassant/layout/_partial/comments.jade","hash":"6c7f63ba04a4d28323ba31e79a4927f3d3fcc56e","modified":1479392060000},{"_id":"themes/maupassant/layout/_partial/mathjax2.jade","hash":"d6ac5dc4e9c7a1b866f1f92d88988cfb35aded4c","modified":1479392060000},{"_id":"themes/maupassant/layout/_partial/post_nav.jade","hash":"a2d698c84bb6da08195fe870dbd7215f65388d3f","modified":1479392060000},{"_id":"themes/maupassant/layout/_partial/paginator.jade","hash":"53f9cb77448e84a98da5eb688e2e12b173c555bb","modified":1479392060000},{"_id":"themes/maupassant/layout/_partial/mathjax.jade","hash":"b54b56faff9e47ab3ca3cdd55056c73e60776f3c","modified":1479392060000},{"_id":"themes/maupassant/layout/_widget/category.jade","hash":"7c6aed762934ca51aa2669b886254da24b77bc14","modified":1479392060000},{"_id":"themes/maupassant/layout/_widget/recent_comments.jade","hash":"e119c5afa85abc60d139e2da99b0bfcd7a6530f8","modified":1479392060000},{"_id":"themes/maupassant/layout/_widget/recent_posts.jade","hash":"19431336d724d2118e46da43683bce9063176541","modified":1479392060000},{"_id":"themes/maupassant/layout/_widget/tag.jade","hash":"132f049ce677d0e38f50073174c4ee4b825d4a06","modified":1479392060000},{"_id":"themes/maupassant/layout/_widget/links.jade","hash":"f57a0c76d243882b2b77330132bdb43bc648948b","modified":1479392060000},{"_id":"themes/maupassant/layout/_partial/tag.jade","hash":"0f0e6770e9d5dd8040e330d71bbbfadd2df36a28","modified":1479392060000},{"_id":"themes/maupassant/layout/_widget/search.jade","hash":"193546282908e499813534f86d27ef6e0a1357b3","modified":1479392060000},{"_id":"themes/maupassant/layout/_partial/totop.jade","hash":"8225bbc3cdb9648bc2e6872e5c616a9a1e4def4f","modified":1479392060000},{"_id":"themes/maupassant/layout/_partial/after_footer.jade","hash":"3dbcc9a9f0d6e55da191d3393c18bbfcfe99fa69","modified":1479392060000},{"_id":"themes/maupassant/source/css/style.scss","hash":"158f1ebecf7b994ffae5332a627465f6bf38113b","modified":1479392060000},{"_id":"themes/maupassant/source/css/jquery.fancybox.css","hash":"f42f761157f26244673eb2f4a9215c70956f80dc","modified":1479392060000},{"_id":"themes/maupassant/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1479392060000},{"_id":"themes/maupassant/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1479392060000},{"_id":"themes/maupassant/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1479392060000},{"_id":"themes/maupassant/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1479392060000},{"_id":"themes/maupassant/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1479392060000},{"_id":"themes/maupassant/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1479392060000},{"_id":"themes/maupassant/source/js/share.js","hash":"f49776e0baa2b913ddc7a20db24b3edd469c8343","modified":1479392060000},{"_id":"themes/maupassant/source/js/search.js","hash":"53db2eb255dd40a412ed62ea7332ca5a22f7816f","modified":1479392060000},{"_id":"themes/maupassant/source/js/totop.js","hash":"7dbf8fcf582a4fb6eb9b2c60d6de9f9c2091ec4c","modified":1479392060000},{"_id":"themes/maupassant/source/js/smartresize.js","hash":"3ef157fd877167e3290f42c67a624ea375a46c24","modified":1479392060000},{"_id":"themes/maupassant/source/js/fancybox.js","hash":"13c4781570339f4fba76a3d7f202e442817dd605","modified":1479392060000},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","hash":"5d0b786d60bf225d9eabcc9cece2719ff4d9b6cd","modified":1479392060000},{"_id":"themes/maupassant/.git/refs/heads/master","hash":"5cdb6ae67bcdff36e5c4b4fb73d9adbed6c4190c","modified":1479392060000},{"_id":"themes/maupassant/.git/objects/pack/pack-5d7c5e76740af31a0ef5c3ff1483e7f84422bd31.idx","hash":"cd5316967c64994ab92025adda897f217b9b201a","modified":1479392060000},{"_id":"themes/maupassant/.git/logs/refs/heads/master","hash":"92e274a6807833ba50fd29a4645e6d3b1f3a0c62","modified":1479392060000},{"_id":"themes/maupassant/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1479392060000},{"_id":"themes/maupassant/.git/logs/refs/remotes/origin/HEAD","hash":"92e274a6807833ba50fd29a4645e6d3b1f3a0c62","modified":1479392060000},{"_id":"themes/maupassant/.git/objects/pack/pack-5d7c5e76740af31a0ef5c3ff1483e7f84422bd31.pack","hash":"fa507c9a259c24379510e329510acc15d05f14fe","modified":1479392060000},{"_id":"public/archives/index.html","hash":"7b1b348ac7050d66643f860acd51e40302297b72","modified":1489127086031},{"_id":"public/archives/2016/index.html","hash":"d74923962844a2b127261467d1849f3637c371ab","modified":1489127086037},{"_id":"public/archives/2016/12/index.html","hash":"128400af28959bbb45a0eb736daecbd723e0e1db","modified":1489127086037},{"_id":"public/archives/2017/index.html","hash":"4e10b97ce1c1d44b9847052ece695ccad4f8f384","modified":1489127086038},{"_id":"public/archives/2017/02/index.html","hash":"4e10b97ce1c1d44b9847052ece695ccad4f8f384","modified":1489127086038},{"_id":"public/index.html","hash":"7c82dfcb05bc33439b6a533fd3bb705be6659c3b","modified":1489127086038},{"_id":"public/tags/node-js-node-web-sina/index.html","hash":"1c6d10265dcd863d0dab79cb4f06f5dd3d6d9f23","modified":1489127086038},{"_id":"public/tags/git/index.html","hash":"0b848196171021e40b4839af13346ab1088a3f0e","modified":1489127086038},{"_id":"public/2017/02/15/20170215-git-order-list/index.html","hash":"382beed0e37eb9727d6ae3e0112e93fc1ea1a345","modified":1489127086038},{"_id":"public/2016/12/18/20161218-sina-sae-node-js-web-tutorial/index.html","hash":"4dd3591478514850d2d1098eca896b9c6be3a00c","modified":1489127086040},{"_id":"public/2016/07/02/20160702-rutime-method-swiizzling/index.html","hash":"c1fd437bae889607a048f820d0e0d0ee07979d1d","modified":1489127086044},{"_id":"public/2016/04/05/20160405-YYFPSLabel-source-read/index.html","hash":"5f451a003a96ee1ed69682a97ff5c94276739f18","modified":1489127086052},{"_id":"public/2015/11/29/20151129-project-contents/index.html","hash":"3cb1afff9a45bb31e9c4d33ea0d9e3af42030bd5","modified":1489127086053},{"_id":"public/2015/02/15/hello-world/index.html","hash":"b4ccaeefd27501355896631a8bf467e19c13ca18","modified":1489127086053},{"_id":"public/archives/2015/index.html","hash":"a5ad33ee32fd1ff3fc46fb376fbfa8bae5635dad","modified":1489127086053},{"_id":"public/archives/2015/02/index.html","hash":"012365cf26a111842f9f07cc1d2dc34f3751cbf2","modified":1489127086053},{"_id":"public/archives/2015/11/index.html","hash":"d4ddc24b2145d32fdd8ba857110b86abc1d9ea1c","modified":1489127086053},{"_id":"public/archives/2016/04/index.html","hash":"e2628b1f27e61dd29ed49bdc977e7b018513b62d","modified":1489127086053},{"_id":"public/archives/2016/05/index.html","hash":"46d842a37c729abc3ff5c6e314de16a5b1cf25b4","modified":1489127086053},{"_id":"public/archives/2016/07/index.html","hash":"bce7de01f982b3560c7e973581ff15a2345efb71","modified":1489127086053},{"_id":"public/tags/YYFPSLabel/index.html","hash":"6d704102f0745509965aa4616a2d81521edb07ab","modified":1489127086053},{"_id":"public/tags/module/index.html","hash":"4a88c0373d45edf427747e837e3f63e7c2ee00ca","modified":1489127086053},{"_id":"public/tags/runtime-swizzling/index.html","hash":"133481f53f016ef5beeefb576ea999c8224dc7d6","modified":1489127086053},{"_id":"public/2016/05/31/20160531-ios-module-investigation/index.html","hash":"b6d97452ef2ce0e227c1065017f0f30a9c174841","modified":1489127086053},{"_id":"public/favicon.ico","hash":"0f788e715691c76ce6364ae9d38cffdd71a10615","modified":1489127086053},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1489127086053},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1489127086054},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1489127086054},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1489127086054},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1489127086054},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1489127086054},{"_id":"public/css/jquery.fancybox.css","hash":"f42f761157f26244673eb2f4a9215c70956f80dc","modified":1489127086111},{"_id":"public/js/share.js","hash":"f49776e0baa2b913ddc7a20db24b3edd469c8343","modified":1489127086111},{"_id":"public/js/search.js","hash":"53db2eb255dd40a412ed62ea7332ca5a22f7816f","modified":1489127086112},{"_id":"public/js/totop.js","hash":"7dbf8fcf582a4fb6eb9b2c60d6de9f9c2091ec4c","modified":1489127086112},{"_id":"public/js/smartresize.js","hash":"3ef157fd877167e3290f42c67a624ea375a46c24","modified":1489127086114},{"_id":"public/js/fancybox.js","hash":"13c4781570339f4fba76a3d7f202e442817dd605","modified":1489127086114},{"_id":"public/js/codeblock-resizer.js","hash":"5d0b786d60bf225d9eabcc9cece2719ff4d9b6cd","modified":1489127086115},{"_id":"public/css/style.css","hash":"2afb6e7e24abf81c8b7b7d472fb0bb9b9a1eac16","modified":1489127086117}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"iOS工程目录结构的思考","date":"2015-11-29T06:18:43.000Z","_content":"\n#一、前言\n  在 [@汉斯哈哈哈](http://www.jianshu.com/users/368a8cd349af/latest_articles) 的 [iOS 项目的目录结构能看出你的开发经验](http://www.jianshu.com/p/77a948bcbc38) 这篇博客里提到一点：\n> - 面试iOS开发，面试官竟然问他『**怎么分目录结构**』的，而且还具体问到每个子目录的文件名。\n\n> - 清晰的目录结构，可让人一眼知道对应目录的职能，这也能体现开发者的经验和架构能力。\n\n  恰巧，有一次我参加面试，也被问到过类似的问题。\n  在日常工作中我自己对此也深有感触，《代码大全》里有个观点：\n> **代码首先是给人看的**\n\n  我觉得，一个项目的目录结构也是如此。以下是我个人的一些看法。\n\n  \n#二、不合理的目录结构\n  我想应该没人觉得一个项目的 「**工程目录结构**」这个东西不重要。\n  没人讨论这个可能是因为项目不同、团队风格不一样、目录结构没有个通用的标准，不太好下个结论。\n  而且项目**工程目录结构**这个东西，除非开始一个新项目，其它时候大多都是沿用旧项目里已有的目录结构。真正从无到有的完整搭一个新项目，除了软件外包公司，我想机会不是很多。\n\n  我因为非科班出身，刚入行时不是很懂，为了先找到一份工作，同时想着快速接触更多的项目（靠数量增加经验），所以在软件外包公司待过一段时间，接触了不少新开始的项目，也接手了不少旧项目的版本升级、维护等工作。\n###这是我接触过的一些项目的结构目录：\n![](http://upload-images.jianshu.io/upload_images/332029-9184199c95735d49.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n###为什么不合理：\n  我觉得普遍**存在以下几个问题**：\n**1 、目录结构没有层次性：**\n  有的工程，一级目录展开后就是十几个二级目录的文件夹。\n![](http://upload-images.jianshu.io/upload_images/332029-a4cca08c1fe89985.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n**2 、目录结构层次过深：**\n  文件夹过多、层级过深，会增加点击的成本。\n**3、单个目录下文件数过多**\n  某级目录内文件数量过多，展开后超过一屏。出现这种情况，我觉得就是目录结构设置不合理导致的。\n**4、目录命名不能够「见名知意」：**\n  大量的 **Common**、**Tool**、**Helper**、**Other**这样的文件夹名。\n**5、没有项目目录结构的ReadMe说明；**\n  这个属于代码文档中不容忽视的一点。\n**6、目录存在使用中文命名的情况；**\n**7、结虚拟文件夹与实体文件夹没有一一对应：**\n![](http://upload-images.jianshu.io/upload_images/332029-c642553bee09d282.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n###可能导致的问题：\n\n  **1、**一个糟糕的目录会让人对工程瞬间失去兴趣。\n  **2、**如果打开一个工程，没办法通过阅读目录结构获得对整个项目结构的大致的了解，这样的目录结构就是不够合理的。这样会导致在不熟悉项目的情况下，很难明白各个模块、各个文件夹里的类的作用。\n  **3、**目录结构如果没有统一的规范，类文件的命名也很难有相应的规则来进行约束；\n  **4、**对于新加入项目的人，如果需要新增一些类文件，会不知道究竟该放在哪个目录下合适，只能先\"凭感觉\"随便找个地方一放。这样的工程维护起来，只会越来越乱。\n\n\n#三、我的个人经验\n\n**1、** 简叔在 [iOS 项目的目录结构能看出你的开发经验](http://www.jianshu.com/p/77a948bcbc38) 一文下的评论：\n> ![](http://upload-images.jianshu.io/upload_images/332029-ef0bc5110921e153.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n  看到这条评论不胜赞同。\n  我自己就很喜欢整理，不论是电脑上的盘符目录，还是印象笔记下的笔记本目录，我都习惯于编个号、定期整理。\n\n![](http://upload-images.jianshu.io/upload_images/332029-296141c755a00794.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n  这样一般我要找一个存在自己电脑上的东西，在找之前，头脑里就已经基本想到它会在那个大目录、哪个子目录下。配合搜索功能，很少会找不到文件。\n  同时，存的时候也不会随便找个地方一放，乱七八糟。基本已经形成一套自己熟悉的规则了。\n\n**2、** [高质量iOS开发系列之(一)－iOS项目工程及目录结构](http://mtydev.net/?p=1) 中提高的几个基本原则：\n> - 一个合理的目录结构应该是清晰的，让人一眼就能了解目录职责，并且是容易扩展的。\n> - 不管是第三方库还是自己的库，尽量用CocoPods来管理/区分不同层次的通用组件。\n    - General Level, 最通用的组件，可以在不同项目里复用。\n    - Project Level, 可以在该项目里复用。\n    - Section Level, 可以在某个功能模块里复用。\n> - 对于General Level的组件，以Library的形式分出来，不要放在主工程。\n> - 对于基础库，保证质量，通用性，可扩展性，易用性，可以不断迭代\n\n  此外，该文章中讲到的各模块注意事项，非常切合iOS开发的实际。建议[阅读原文](http://mtydev.net/?p=1)，我就不在这里搬运了。\n\n**3、**  [@汉斯哈哈哈](http://www.jianshu.com/users/368a8cd349af/latest_articles) 提到的两种常用目录结构的分法：\n>1.主目录按照业务分类，内目录按照模块分类\n>2.主目录按照模块分类，内目录按照业务分类\n\n  我个人偏向于第二种：按照业务模块划分。因为：\n> 1> 第一种如果项目较大，经常会出现找个控制器对应的tableviewcell找半天。如果不是自己写的，更难找。\n2> 开发某一具体功能的时候，涉及到的类基本都是该业务模块里面的类，很少会出现跨目录的情况。而第一种情况则需要经常会跨目录。\n3> 从文件耦合度来讲，各业务模块里的文件耦合度相对来说比较高。放在一个目录内，也符合软件设计中的高内聚低耦合思想。\n\n\n**4、一个简单的工程结构目录的Demo**\n- 一级目录如下：（中文备注是为了便于理解，实际项目中不要加）\n![](http://upload-images.jianshu.io/upload_images/332029-908a1195b32b770e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n- 二级目录如下：\n![](http://upload-images.jianshu.io/upload_images/332029-63f11bd45bc0c94f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n**5、公用的类、模块放在哪里：**\n  一般的做法是遇到共用模块单独建一个模块叫common，都放到这里。（这样其实也不是很好，Common也是属于定义模糊的命名）\n**6、多个Target的情况：**\n  可以单独出一个Project文件夹，按Target名分各个子目录，内放各个Target中独有的文件。\n**7、图片资源**最好都用 **Images.xcassets** 去管理。\n  **Images.xcassets** 文件里边也按业务模块分子文件夹，这样可以方便的预览图片。\n\n\n#四、Tips\n  **在定位项目中的文件**时，善用以下快捷键可以节省大量时间：\n\n**1、Xcode左下角的搜索框 （不支持模糊搜索、会展开对应目录）**\n\n![](http://upload-images.jianshu.io/upload_images/332029-c747563290d2b596.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n> 快捷键: Command + option + j\n\n![](http://upload-images.jianshu.io/upload_images/332029-7705e2a055900eb8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n**2、工程全局搜索**（支持模糊搜索、不会展开对应目录）\n> 快捷键: Command + shift + O\n![](http://upload-images.jianshu.io/upload_images/332029-56a1f25146ea0cba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n###注：\n  以上只是我个人的一些经验，总结的不是很完善。同时有很多地方借鉴了以下文章的观点。有什么能改进的地方，欢迎在评论区讨论！\n\n</br>\n\n>###参考：\n>[高质量iOS开发系列之(一)－iOS项目工程及目录结构](http://mtydev.net/?p=1)\n>[iOS项目的目录结构和开发流程](http://limboy.me/ios/2013/09/23/build-ios-application.html)\n>[iOS 项目的目录结构能看出你的开发经验](http://www.jianshu.com/p/77a948bcbc38)\n","source":"_posts/20151129-project-contents.md","raw":"---\ntitle: iOS工程目录结构的思考\ndate: 2015-11-29 14:18:43\ntags:\n---\n\n#一、前言\n  在 [@汉斯哈哈哈](http://www.jianshu.com/users/368a8cd349af/latest_articles) 的 [iOS 项目的目录结构能看出你的开发经验](http://www.jianshu.com/p/77a948bcbc38) 这篇博客里提到一点：\n> - 面试iOS开发，面试官竟然问他『**怎么分目录结构**』的，而且还具体问到每个子目录的文件名。\n\n> - 清晰的目录结构，可让人一眼知道对应目录的职能，这也能体现开发者的经验和架构能力。\n\n  恰巧，有一次我参加面试，也被问到过类似的问题。\n  在日常工作中我自己对此也深有感触，《代码大全》里有个观点：\n> **代码首先是给人看的**\n\n  我觉得，一个项目的目录结构也是如此。以下是我个人的一些看法。\n\n  \n#二、不合理的目录结构\n  我想应该没人觉得一个项目的 「**工程目录结构**」这个东西不重要。\n  没人讨论这个可能是因为项目不同、团队风格不一样、目录结构没有个通用的标准，不太好下个结论。\n  而且项目**工程目录结构**这个东西，除非开始一个新项目，其它时候大多都是沿用旧项目里已有的目录结构。真正从无到有的完整搭一个新项目，除了软件外包公司，我想机会不是很多。\n\n  我因为非科班出身，刚入行时不是很懂，为了先找到一份工作，同时想着快速接触更多的项目（靠数量增加经验），所以在软件外包公司待过一段时间，接触了不少新开始的项目，也接手了不少旧项目的版本升级、维护等工作。\n###这是我接触过的一些项目的结构目录：\n![](http://upload-images.jianshu.io/upload_images/332029-9184199c95735d49.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n###为什么不合理：\n  我觉得普遍**存在以下几个问题**：\n**1 、目录结构没有层次性：**\n  有的工程，一级目录展开后就是十几个二级目录的文件夹。\n![](http://upload-images.jianshu.io/upload_images/332029-a4cca08c1fe89985.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n**2 、目录结构层次过深：**\n  文件夹过多、层级过深，会增加点击的成本。\n**3、单个目录下文件数过多**\n  某级目录内文件数量过多，展开后超过一屏。出现这种情况，我觉得就是目录结构设置不合理导致的。\n**4、目录命名不能够「见名知意」：**\n  大量的 **Common**、**Tool**、**Helper**、**Other**这样的文件夹名。\n**5、没有项目目录结构的ReadMe说明；**\n  这个属于代码文档中不容忽视的一点。\n**6、目录存在使用中文命名的情况；**\n**7、结虚拟文件夹与实体文件夹没有一一对应：**\n![](http://upload-images.jianshu.io/upload_images/332029-c642553bee09d282.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n###可能导致的问题：\n\n  **1、**一个糟糕的目录会让人对工程瞬间失去兴趣。\n  **2、**如果打开一个工程，没办法通过阅读目录结构获得对整个项目结构的大致的了解，这样的目录结构就是不够合理的。这样会导致在不熟悉项目的情况下，很难明白各个模块、各个文件夹里的类的作用。\n  **3、**目录结构如果没有统一的规范，类文件的命名也很难有相应的规则来进行约束；\n  **4、**对于新加入项目的人，如果需要新增一些类文件，会不知道究竟该放在哪个目录下合适，只能先\"凭感觉\"随便找个地方一放。这样的工程维护起来，只会越来越乱。\n\n\n#三、我的个人经验\n\n**1、** 简叔在 [iOS 项目的目录结构能看出你的开发经验](http://www.jianshu.com/p/77a948bcbc38) 一文下的评论：\n> ![](http://upload-images.jianshu.io/upload_images/332029-ef0bc5110921e153.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n  看到这条评论不胜赞同。\n  我自己就很喜欢整理，不论是电脑上的盘符目录，还是印象笔记下的笔记本目录，我都习惯于编个号、定期整理。\n\n![](http://upload-images.jianshu.io/upload_images/332029-296141c755a00794.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n  这样一般我要找一个存在自己电脑上的东西，在找之前，头脑里就已经基本想到它会在那个大目录、哪个子目录下。配合搜索功能，很少会找不到文件。\n  同时，存的时候也不会随便找个地方一放，乱七八糟。基本已经形成一套自己熟悉的规则了。\n\n**2、** [高质量iOS开发系列之(一)－iOS项目工程及目录结构](http://mtydev.net/?p=1) 中提高的几个基本原则：\n> - 一个合理的目录结构应该是清晰的，让人一眼就能了解目录职责，并且是容易扩展的。\n> - 不管是第三方库还是自己的库，尽量用CocoPods来管理/区分不同层次的通用组件。\n    - General Level, 最通用的组件，可以在不同项目里复用。\n    - Project Level, 可以在该项目里复用。\n    - Section Level, 可以在某个功能模块里复用。\n> - 对于General Level的组件，以Library的形式分出来，不要放在主工程。\n> - 对于基础库，保证质量，通用性，可扩展性，易用性，可以不断迭代\n\n  此外，该文章中讲到的各模块注意事项，非常切合iOS开发的实际。建议[阅读原文](http://mtydev.net/?p=1)，我就不在这里搬运了。\n\n**3、**  [@汉斯哈哈哈](http://www.jianshu.com/users/368a8cd349af/latest_articles) 提到的两种常用目录结构的分法：\n>1.主目录按照业务分类，内目录按照模块分类\n>2.主目录按照模块分类，内目录按照业务分类\n\n  我个人偏向于第二种：按照业务模块划分。因为：\n> 1> 第一种如果项目较大，经常会出现找个控制器对应的tableviewcell找半天。如果不是自己写的，更难找。\n2> 开发某一具体功能的时候，涉及到的类基本都是该业务模块里面的类，很少会出现跨目录的情况。而第一种情况则需要经常会跨目录。\n3> 从文件耦合度来讲，各业务模块里的文件耦合度相对来说比较高。放在一个目录内，也符合软件设计中的高内聚低耦合思想。\n\n\n**4、一个简单的工程结构目录的Demo**\n- 一级目录如下：（中文备注是为了便于理解，实际项目中不要加）\n![](http://upload-images.jianshu.io/upload_images/332029-908a1195b32b770e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n- 二级目录如下：\n![](http://upload-images.jianshu.io/upload_images/332029-63f11bd45bc0c94f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n**5、公用的类、模块放在哪里：**\n  一般的做法是遇到共用模块单独建一个模块叫common，都放到这里。（这样其实也不是很好，Common也是属于定义模糊的命名）\n**6、多个Target的情况：**\n  可以单独出一个Project文件夹，按Target名分各个子目录，内放各个Target中独有的文件。\n**7、图片资源**最好都用 **Images.xcassets** 去管理。\n  **Images.xcassets** 文件里边也按业务模块分子文件夹，这样可以方便的预览图片。\n\n\n#四、Tips\n  **在定位项目中的文件**时，善用以下快捷键可以节省大量时间：\n\n**1、Xcode左下角的搜索框 （不支持模糊搜索、会展开对应目录）**\n\n![](http://upload-images.jianshu.io/upload_images/332029-c747563290d2b596.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n> 快捷键: Command + option + j\n\n![](http://upload-images.jianshu.io/upload_images/332029-7705e2a055900eb8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n**2、工程全局搜索**（支持模糊搜索、不会展开对应目录）\n> 快捷键: Command + shift + O\n![](http://upload-images.jianshu.io/upload_images/332029-56a1f25146ea0cba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n###注：\n  以上只是我个人的一些经验，总结的不是很完善。同时有很多地方借鉴了以下文章的观点。有什么能改进的地方，欢迎在评论区讨论！\n\n</br>\n\n>###参考：\n>[高质量iOS开发系列之(一)－iOS项目工程及目录结构](http://mtydev.net/?p=1)\n>[iOS项目的目录结构和开发流程](http://limboy.me/ios/2013/09/23/build-ios-application.html)\n>[iOS 项目的目录结构能看出你的开发经验](http://www.jianshu.com/p/77a948bcbc38)\n","slug":"20151129-project-contents","published":1,"updated":"2017-03-10T06:19:40.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj03ftfn100007wom21wc9rlt","content":"<p>#一、前言<br>  在 <a href=\"http://www.jianshu.com/users/368a8cd349af/latest_articles\" target=\"_blank\" rel=\"external\">@汉斯哈哈哈</a> 的 <a href=\"http://www.jianshu.com/p/77a948bcbc38\" target=\"_blank\" rel=\"external\">iOS 项目的目录结构能看出你的开发经验</a> 这篇博客里提到一点：</p>\n<blockquote>\n<ul>\n<li><p>面试iOS开发，面试官竟然问他『<strong>怎么分目录结构</strong>』的，而且还具体问到每个子目录的文件名。</p>\n</li>\n<li><p>清晰的目录结构，可让人一眼知道对应目录的职能，这也能体现开发者的经验和架构能力。</p>\n</li>\n</ul>\n</blockquote>\n<p>  恰巧，有一次我参加面试，也被问到过类似的问题。<br>  在日常工作中我自己对此也深有感触，《代码大全》里有个观点：</p>\n<blockquote>\n<p><strong>代码首先是给人看的</strong></p>\n</blockquote>\n<p>  我觉得，一个项目的目录结构也是如此。以下是我个人的一些看法。</p>\n<p>  </p>\n<p>#二、不合理的目录结构<br>  我想应该没人觉得一个项目的 「<strong>工程目录结构</strong>」这个东西不重要。<br>  没人讨论这个可能是因为项目不同、团队风格不一样、目录结构没有个通用的标准，不太好下个结论。<br>  而且项目<strong>工程目录结构</strong>这个东西，除非开始一个新项目，其它时候大多都是沿用旧项目里已有的目录结构。真正从无到有的完整搭一个新项目，除了软件外包公司，我想机会不是很多。</p>\n<p>  我因为非科班出身，刚入行时不是很懂，为了先找到一份工作，同时想着快速接触更多的项目（靠数量增加经验），所以在软件外包公司待过一段时间，接触了不少新开始的项目，也接手了不少旧项目的版本升级、维护等工作。</p>\n<p>###这是我接触过的一些项目的结构目录：<br><img src=\"http://upload-images.jianshu.io/upload_images/332029-9184199c95735d49.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>###为什么不合理：<br>  我觉得普遍<strong>存在以下几个问题</strong>：<br><strong>1 、目录结构没有层次性：</strong><br>  有的工程，一级目录展开后就是十几个二级目录的文件夹。<br><img src=\"http://upload-images.jianshu.io/upload_images/332029-a4cca08c1fe89985.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br><strong>2 、目录结构层次过深：</strong><br>  文件夹过多、层级过深，会增加点击的成本。<br><strong>3、单个目录下文件数过多</strong><br>  某级目录内文件数量过多，展开后超过一屏。出现这种情况，我觉得就是目录结构设置不合理导致的。<br><strong>4、目录命名不能够「见名知意」：</strong><br>  大量的 <strong>Common</strong>、<strong>Tool</strong>、<strong>Helper</strong>、<strong>Other</strong>这样的文件夹名。<br><strong>5、没有项目目录结构的ReadMe说明；</strong><br>  这个属于代码文档中不容忽视的一点。<br><strong>6、目录存在使用中文命名的情况；</strong><br><strong>7、结虚拟文件夹与实体文件夹没有一一对应：</strong><br><img src=\"http://upload-images.jianshu.io/upload_images/332029-c642553bee09d282.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>###可能导致的问题：</p>\n<p>  <strong>1、</strong>一个糟糕的目录会让人对工程瞬间失去兴趣。<br>  <strong>2、</strong>如果打开一个工程，没办法通过阅读目录结构获得对整个项目结构的大致的了解，这样的目录结构就是不够合理的。这样会导致在不熟悉项目的情况下，很难明白各个模块、各个文件夹里的类的作用。<br>  <strong>3、</strong>目录结构如果没有统一的规范，类文件的命名也很难有相应的规则来进行约束；<br>  <strong>4、</strong>对于新加入项目的人，如果需要新增一些类文件，会不知道究竟该放在哪个目录下合适，只能先”凭感觉”随便找个地方一放。这样的工程维护起来，只会越来越乱。</p>\n<p>#三、我的个人经验</p>\n<p><strong>1、</strong> 简叔在 <a href=\"http://www.jianshu.com/p/77a948bcbc38\" target=\"_blank\" rel=\"external\">iOS 项目的目录结构能看出你的开发经验</a> 一文下的评论：</p>\n<blockquote>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/332029-ef0bc5110921e153.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n</blockquote>\n<p>  看到这条评论不胜赞同。<br>  我自己就很喜欢整理，不论是电脑上的盘符目录，还是印象笔记下的笔记本目录，我都习惯于编个号、定期整理。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/332029-296141c755a00794.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br>  这样一般我要找一个存在自己电脑上的东西，在找之前，头脑里就已经基本想到它会在那个大目录、哪个子目录下。配合搜索功能，很少会找不到文件。<br>  同时，存的时候也不会随便找个地方一放，乱七八糟。基本已经形成一套自己熟悉的规则了。</p>\n<p><strong>2、</strong> <a href=\"http://mtydev.net/?p=1\" target=\"_blank\" rel=\"external\">高质量iOS开发系列之(一)－iOS项目工程及目录结构</a> 中提高的几个基本原则：</p>\n<blockquote>\n<ul>\n<li>一个合理的目录结构应该是清晰的，让人一眼就能了解目录职责，并且是容易扩展的。</li>\n<li>不管是第三方库还是自己的库，尽量用CocoPods来管理/区分不同层次的通用组件。<ul>\n<li>General Level, 最通用的组件，可以在不同项目里复用。</li>\n<li>Project Level, 可以在该项目里复用。</li>\n<li>Section Level, 可以在某个功能模块里复用。</li>\n</ul>\n</li>\n<li>对于General Level的组件，以Library的形式分出来，不要放在主工程。</li>\n<li>对于基础库，保证质量，通用性，可扩展性，易用性，可以不断迭代</li>\n</ul>\n</blockquote>\n<p>  此外，该文章中讲到的各模块注意事项，非常切合iOS开发的实际。建议<a href=\"http://mtydev.net/?p=1\" target=\"_blank\" rel=\"external\">阅读原文</a>，我就不在这里搬运了。</p>\n<p><strong>3、</strong>  <a href=\"http://www.jianshu.com/users/368a8cd349af/latest_articles\" target=\"_blank\" rel=\"external\">@汉斯哈哈哈</a> 提到的两种常用目录结构的分法：</p>\n<blockquote>\n<p>1.主目录按照业务分类，内目录按照模块分类<br>2.主目录按照模块分类，内目录按照业务分类</p>\n</blockquote>\n<p>  我个人偏向于第二种：按照业务模块划分。因为：</p>\n<blockquote>\n<p>1&gt; 第一种如果项目较大，经常会出现找个控制器对应的tableviewcell找半天。如果不是自己写的，更难找。<br>2&gt; 开发某一具体功能的时候，涉及到的类基本都是该业务模块里面的类，很少会出现跨目录的情况。而第一种情况则需要经常会跨目录。<br>3&gt; 从文件耦合度来讲，各业务模块里的文件耦合度相对来说比较高。放在一个目录内，也符合软件设计中的高内聚低耦合思想。</p>\n</blockquote>\n<p><strong>4、一个简单的工程结构目录的Demo</strong></p>\n<ul>\n<li>一级目录如下：（中文备注是为了便于理解，实际项目中不要加）<br><img src=\"http://upload-images.jianshu.io/upload_images/332029-908a1195b32b770e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></li>\n<li>二级目录如下：<br><img src=\"http://upload-images.jianshu.io/upload_images/332029-63f11bd45bc0c94f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></li>\n</ul>\n<p><strong>5、公用的类、模块放在哪里：</strong><br>  一般的做法是遇到共用模块单独建一个模块叫common，都放到这里。（这样其实也不是很好，Common也是属于定义模糊的命名）<br><strong>6、多个Target的情况：</strong><br>  可以单独出一个Project文件夹，按Target名分各个子目录，内放各个Target中独有的文件。<br><strong>7、图片资源</strong>最好都用 <strong>Images.xcassets</strong> 去管理。<br>  <strong>Images.xcassets</strong> 文件里边也按业务模块分子文件夹，这样可以方便的预览图片。</p>\n<p>#四、Tips<br>  <strong>在定位项目中的文件</strong>时，善用以下快捷键可以节省大量时间：</p>\n<p><strong>1、Xcode左下角的搜索框 （不支持模糊搜索、会展开对应目录）</strong></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/332029-c747563290d2b596.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<blockquote>\n<p>快捷键: Command + option + j</p>\n</blockquote>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/332029-7705e2a055900eb8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p><strong>2、工程全局搜索</strong>（支持模糊搜索、不会展开对应目录）</p>\n<blockquote>\n<p>快捷键: Command + shift + O<br><img src=\"http://upload-images.jianshu.io/upload_images/332029-56a1f25146ea0cba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n</blockquote>\n<p>###注：<br>  以上只是我个人的一些经验，总结的不是很完善。同时有很多地方借鉴了以下文章的观点。有什么能改进的地方，欢迎在评论区讨论！</p>\n<p><br></p>\n<blockquote>\n<p>###参考：<br><a href=\"http://mtydev.net/?p=1\" target=\"_blank\" rel=\"external\">高质量iOS开发系列之(一)－iOS项目工程及目录结构</a><br><a href=\"http://limboy.me/ios/2013/09/23/build-ios-application.html\" target=\"_blank\" rel=\"external\">iOS项目的目录结构和开发流程</a><br><a href=\"http://www.jianshu.com/p/77a948bcbc38\" target=\"_blank\" rel=\"external\">iOS 项目的目录结构能看出你的开发经验</a></p>\n</blockquote>\n","excerpt":"","more":"<p>#一、前言<br>  在 <a href=\"http://www.jianshu.com/users/368a8cd349af/latest_articles\">@汉斯哈哈哈</a> 的 <a href=\"http://www.jianshu.com/p/77a948bcbc38\">iOS 项目的目录结构能看出你的开发经验</a> 这篇博客里提到一点：</p>\n<blockquote>\n<ul>\n<li><p>面试iOS开发，面试官竟然问他『<strong>怎么分目录结构</strong>』的，而且还具体问到每个子目录的文件名。</p>\n</li>\n<li><p>清晰的目录结构，可让人一眼知道对应目录的职能，这也能体现开发者的经验和架构能力。</p>\n</li>\n</ul>\n</blockquote>\n<p>  恰巧，有一次我参加面试，也被问到过类似的问题。<br>  在日常工作中我自己对此也深有感触，《代码大全》里有个观点：</p>\n<blockquote>\n<p><strong>代码首先是给人看的</strong></p>\n</blockquote>\n<p>  我觉得，一个项目的目录结构也是如此。以下是我个人的一些看法。</p>\n<p>  </p>\n<p>#二、不合理的目录结构<br>  我想应该没人觉得一个项目的 「<strong>工程目录结构</strong>」这个东西不重要。<br>  没人讨论这个可能是因为项目不同、团队风格不一样、目录结构没有个通用的标准，不太好下个结论。<br>  而且项目<strong>工程目录结构</strong>这个东西，除非开始一个新项目，其它时候大多都是沿用旧项目里已有的目录结构。真正从无到有的完整搭一个新项目，除了软件外包公司，我想机会不是很多。</p>\n<p>  我因为非科班出身，刚入行时不是很懂，为了先找到一份工作，同时想着快速接触更多的项目（靠数量增加经验），所以在软件外包公司待过一段时间，接触了不少新开始的项目，也接手了不少旧项目的版本升级、维护等工作。</p>\n<p>###这是我接触过的一些项目的结构目录：<br><img src=\"http://upload-images.jianshu.io/upload_images/332029-9184199c95735d49.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>###为什么不合理：<br>  我觉得普遍<strong>存在以下几个问题</strong>：<br><strong>1 、目录结构没有层次性：</strong><br>  有的工程，一级目录展开后就是十几个二级目录的文件夹。<br><img src=\"http://upload-images.jianshu.io/upload_images/332029-a4cca08c1fe89985.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br><strong>2 、目录结构层次过深：</strong><br>  文件夹过多、层级过深，会增加点击的成本。<br><strong>3、单个目录下文件数过多</strong><br>  某级目录内文件数量过多，展开后超过一屏。出现这种情况，我觉得就是目录结构设置不合理导致的。<br><strong>4、目录命名不能够「见名知意」：</strong><br>  大量的 <strong>Common</strong>、<strong>Tool</strong>、<strong>Helper</strong>、<strong>Other</strong>这样的文件夹名。<br><strong>5、没有项目目录结构的ReadMe说明；</strong><br>  这个属于代码文档中不容忽视的一点。<br><strong>6、目录存在使用中文命名的情况；</strong><br><strong>7、结虚拟文件夹与实体文件夹没有一一对应：</strong><br><img src=\"http://upload-images.jianshu.io/upload_images/332029-c642553bee09d282.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>###可能导致的问题：</p>\n<p>  <strong>1、</strong>一个糟糕的目录会让人对工程瞬间失去兴趣。<br>  <strong>2、</strong>如果打开一个工程，没办法通过阅读目录结构获得对整个项目结构的大致的了解，这样的目录结构就是不够合理的。这样会导致在不熟悉项目的情况下，很难明白各个模块、各个文件夹里的类的作用。<br>  <strong>3、</strong>目录结构如果没有统一的规范，类文件的命名也很难有相应的规则来进行约束；<br>  <strong>4、</strong>对于新加入项目的人，如果需要新增一些类文件，会不知道究竟该放在哪个目录下合适，只能先”凭感觉”随便找个地方一放。这样的工程维护起来，只会越来越乱。</p>\n<p>#三、我的个人经验</p>\n<p><strong>1、</strong> 简叔在 <a href=\"http://www.jianshu.com/p/77a948bcbc38\">iOS 项目的目录结构能看出你的开发经验</a> 一文下的评论：</p>\n<blockquote>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/332029-ef0bc5110921e153.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n</blockquote>\n<p>  看到这条评论不胜赞同。<br>  我自己就很喜欢整理，不论是电脑上的盘符目录，还是印象笔记下的笔记本目录，我都习惯于编个号、定期整理。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/332029-296141c755a00794.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br>  这样一般我要找一个存在自己电脑上的东西，在找之前，头脑里就已经基本想到它会在那个大目录、哪个子目录下。配合搜索功能，很少会找不到文件。<br>  同时，存的时候也不会随便找个地方一放，乱七八糟。基本已经形成一套自己熟悉的规则了。</p>\n<p><strong>2、</strong> <a href=\"http://mtydev.net/?p=1\">高质量iOS开发系列之(一)－iOS项目工程及目录结构</a> 中提高的几个基本原则：</p>\n<blockquote>\n<ul>\n<li>一个合理的目录结构应该是清晰的，让人一眼就能了解目录职责，并且是容易扩展的。</li>\n<li>不管是第三方库还是自己的库，尽量用CocoPods来管理/区分不同层次的通用组件。<ul>\n<li>General Level, 最通用的组件，可以在不同项目里复用。</li>\n<li>Project Level, 可以在该项目里复用。</li>\n<li>Section Level, 可以在某个功能模块里复用。</li>\n</ul>\n</li>\n<li>对于General Level的组件，以Library的形式分出来，不要放在主工程。</li>\n<li>对于基础库，保证质量，通用性，可扩展性，易用性，可以不断迭代</li>\n</ul>\n</blockquote>\n<p>  此外，该文章中讲到的各模块注意事项，非常切合iOS开发的实际。建议<a href=\"http://mtydev.net/?p=1\">阅读原文</a>，我就不在这里搬运了。</p>\n<p><strong>3、</strong>  <a href=\"http://www.jianshu.com/users/368a8cd349af/latest_articles\">@汉斯哈哈哈</a> 提到的两种常用目录结构的分法：</p>\n<blockquote>\n<p>1.主目录按照业务分类，内目录按照模块分类<br>2.主目录按照模块分类，内目录按照业务分类</p>\n</blockquote>\n<p>  我个人偏向于第二种：按照业务模块划分。因为：</p>\n<blockquote>\n<p>1&gt; 第一种如果项目较大，经常会出现找个控制器对应的tableviewcell找半天。如果不是自己写的，更难找。<br>2&gt; 开发某一具体功能的时候，涉及到的类基本都是该业务模块里面的类，很少会出现跨目录的情况。而第一种情况则需要经常会跨目录。<br>3&gt; 从文件耦合度来讲，各业务模块里的文件耦合度相对来说比较高。放在一个目录内，也符合软件设计中的高内聚低耦合思想。</p>\n</blockquote>\n<p><strong>4、一个简单的工程结构目录的Demo</strong></p>\n<ul>\n<li>一级目录如下：（中文备注是为了便于理解，实际项目中不要加）<br><img src=\"http://upload-images.jianshu.io/upload_images/332029-908a1195b32b770e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></li>\n<li>二级目录如下：<br><img src=\"http://upload-images.jianshu.io/upload_images/332029-63f11bd45bc0c94f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></li>\n</ul>\n<p><strong>5、公用的类、模块放在哪里：</strong><br>  一般的做法是遇到共用模块单独建一个模块叫common，都放到这里。（这样其实也不是很好，Common也是属于定义模糊的命名）<br><strong>6、多个Target的情况：</strong><br>  可以单独出一个Project文件夹，按Target名分各个子目录，内放各个Target中独有的文件。<br><strong>7、图片资源</strong>最好都用 <strong>Images.xcassets</strong> 去管理。<br>  <strong>Images.xcassets</strong> 文件里边也按业务模块分子文件夹，这样可以方便的预览图片。</p>\n<p>#四、Tips<br>  <strong>在定位项目中的文件</strong>时，善用以下快捷键可以节省大量时间：</p>\n<p><strong>1、Xcode左下角的搜索框 （不支持模糊搜索、会展开对应目录）</strong></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/332029-c747563290d2b596.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<blockquote>\n<p>快捷键: Command + option + j</p>\n</blockquote>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/332029-7705e2a055900eb8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p><strong>2、工程全局搜索</strong>（支持模糊搜索、不会展开对应目录）</p>\n<blockquote>\n<p>快捷键: Command + shift + O<br><img src=\"http://upload-images.jianshu.io/upload_images/332029-56a1f25146ea0cba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n</blockquote>\n<p>###注：<br>  以上只是我个人的一些经验，总结的不是很完善。同时有很多地方借鉴了以下文章的观点。有什么能改进的地方，欢迎在评论区讨论！</p>\n<p></br></p>\n<blockquote>\n<p>###参考：<br><a href=\"http://mtydev.net/?p=1\">高质量iOS开发系列之(一)－iOS项目工程及目录结构</a><br><a href=\"http://limboy.me/ios/2013/09/23/build-ios-application.html\">iOS项目的目录结构和开发流程</a><br><a href=\"http://www.jianshu.com/p/77a948bcbc38\">iOS 项目的目录结构能看出你的开发经验</a></p>\n</blockquote>\n"},{"title":"iOS查看屏幕帧数工具--YYFPSLabel","date":"2016-04-05T15:23:36.000Z","_content":"\n学习 **[YYKit](https://github.com/ibireme/YYKit)** 代码时，发现 [ibireme](https://github.com/ibireme) 在项目里加入的一个查看当前屏幕帧数的小工具，效果如下：\n\n![](http://upload-images.jianshu.io/upload_images/332029-36fb1bdbfb423531.gif?imageMogr2/auto-orient/strip)\n\n挺实用的，实现方法也很简单，但是思路特别棒。\n\n####这里是Demo： **[YYFPSLabel](https://github.com/yehot/YYFPSLabel)**\n\n\n这里我把这个小工具从 YYKit 中抽出来，在学习大牛的代码的过程中，收货了不少东西，这里**做个笔记**：\n\n###1、FPSLabel 实现思路：\n使用 CADisplayLink 的 timestamp 属性，配合 timer 的执行次数计算得出 FPS数，详见[代码](https://github.com/yehot/YYFPSLabel/blob/master/YYFPSLabel/YYFPSLabel/YYFPSLabel.m)。\n\n###2、NSTimer、CADisplayLink 常见问题：\n>**问题1：** UIScrollView 在滑动时，timer 会被暂停的问题。\n\n—— 原因：runloop mode 导致。iOS处理滑动时，mainloop 中UIScrollView的mode是 UITrackingRunLoopMode，会优先保证界面流畅，而 timer 默认的model是 NSDefaultRunLoopMode，所以会出现被暂停。\n—— 解决办法：将timer加到 NSRunLoopCommonModes 中。\n```\n    [_link addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes];\n```\n\n详见：[深入理解RunLoop](http://blog.ibireme.com/2015/05/18/runloop/) 一文中关于 [定时器](http://blog.ibireme.com/2015/05/18/runloop/#timer)  和 [RunLoop 的 Mode](http://blog.ibireme.com/2015/05/18/runloop/#mode) 的部分\n>**问题2：**NSTimer 对于 target 的循环引用问题：\n\n以下代码很常见：\n```\n    CADisplayLink *_link = [CADisplayLink displayLinkWithTarget:self selector:@selector(tick:)];\n\n    [NSTimer timerWithTimeInterval:1.f target:self selector:@selector(tick:) userInfo:nil repeats:YES];\n\n```\n—— 原因：以上两种用法，都会对self强引用，此时 timer持有 self，self 也持有 timer，循环引用导致页面 dismiss 时，双方都无法释放，造成循环引用。\n此时使用 __weak 也不能有效解决:\n```\n    __weak typeof(self) weakSelf = self;\n    _link = [CADisplayLink displayLinkWithTarget:weakSelf selector:@selector(tick:)];\n```\n效果如下：\n\n![](http://upload-images.jianshu.io/upload_images/332029-6b2957fc2ff9cc8b.gif?imageMogr2/auto-orient/strip)\n\n**可以看到 页面 dismiss 后，计时器仍然在打印**\n\n**—— 解决办法：1、**在页面退出前，或者合适的时候，手动停止 timer，结束循环引用。\n\n注意：在 dealloc 方法中是肯定不行的！由于循环引用，dealloc 方法不会进。\n![](http://upload-images.jianshu.io/upload_images/332029-90b68a2f2381e4f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n**——解决办法：2、**YYFPSLabel 作者提供的 [YYWeakProxy](https://github.com/yehot/YYFPSLabel/blob/master/YYFPSLabel/YYFPSLabel/YYWeakProxy.m)\n\n```\n@interface YYWeakProxy : NSProxy\n@end\n\n// 使用方式：\n    _link = [CADisplayLink displayLinkWithTarget:[YYWeakProxy proxyWithTarget:self] selector:@selector(tick:)];\n\n```\n代码很少，有兴趣可以自己看下源码。\n**Tips：** OC中 NSProxy 是不继承自 NSObject 的。\n\n###3、探索环节：iOS中子线程检测主线程\n>在和小伙伴分享这个小工具的时候，潘神抛出了这样一个**问题**：\n这里组件是在主线程绘制的label，如果主线程阻塞了还能用吗？\n\n\n结果是不能。\n####以下是探索阶段：\n\n1、模拟主线程阻塞，将 link 放在子线程，发现 timer 不能启动\n```\n    // 模拟 主线程阻塞 （不应该模拟主线程卡死，模拟卡顿即可）\n    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0f * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{  \n        NSLog(@\"即将阻塞\");\n        dispatch_sync(dispatch_get_main_queue(), ^{\n            NSLog(@\"同步阻塞主线程\");\n        });\n        NSLog(@\"不会执行\");\n    });\n```\n\n2、使用CFRunLoopAddObserver检测主线程是否卡顿：\n\n```\n//将观察者添加到主线程runloop的common模式下的观察中\nCFRunLoopAddObserver(CFRunLoopGetMain(), runLoopObserver, kCFRunLoopCommonModes);\n```\n\n这里是能检测到主线程是否卡顿了，但是 timer 在子线程中还是跑不起来。\n\n参考 [Starming星光社](https://www.google.com.hk/url?sa=t&rct=j&q=&esrc=s&source=web&cd=1&ved=0ahUKEwjx0Zjw4_fLAhWVj44KHdkUAvwQFggbMAA&url=%68%74%74%70%3a%2f%2f%77%77%77%2e%73%74%61%72%6d%69%6e%67%2e%63%6f%6d%2f&usg=AFQjCNF2xjShwXV0aXfKo1yXQHN95DRCAA&sig2=C_ywHG5vt8byOOqA6x-bOw) 的 [检测iOS的APP性能的一些方法](http://www.starming.com/index.php?v=index&view=91)\n\n3、在子线程手动创建一个 runloop，提供给 timer。\n```\n    dispatch_async(dispatch_get_global_queue(0, 0), ^{\n        _link = [CADisplayLink displayLinkWithTarget:self selector:@selector(tick:)];\n        // NOTE: 子线程的runloop默认不创建； 在子线程获取 currentRunLoop 对象的时候，就会自动创建RunLoop\n        // 这里不加到 main loop，必须创建一个 runloop\n        NSRunLoop *runloop = [NSRunLoop currentRunLoop];\n        [_link addToRunLoop:runloop forMode:NSRunLoopCommonModes];\n        // 必须 timer addToRunLoop 后，再run\n        [runloop run];\n    });\n```\n\n这样，就可以在子线程中使用 timer 了，但是此时只能 log，无法获通知主线程更新UI： (这里先不在主线程更新UI了)\n```\n// 尝试1：主线程阻塞， 这里就不能获取到主线程了\n//    dispatch_async(dispatch_get_main_queue(), ^{\n//        阻塞时，想通过 在主线程更新UI 来查看是不可行了\n//        label_.text = text;\n//    });\n    \n    // 尝试2：不在主线程操作 UI ，界面会发生变化\n    label_.text = text;\n```\n\n参考: [【iOS程序启动与运转】- RunLoop个人小结](http://www.jianshu.com/p/37ab0397fec7)\n\n\n以上是学习 YYFPSLabel 时的收获，和对于在子线程中检测主线程的探索。详情可以戳代码：\n**[YYFPSLabel](https://github.com/yehot/YYFPSLabel)**\n","source":"_posts/20160405-YYFPSLabel-source-read.md","raw":"---\ntitle: iOS查看屏幕帧数工具--YYFPSLabel\ndate: 2016-04-05 23:23:36\ntags: YYFPSLabel\n---\n\n学习 **[YYKit](https://github.com/ibireme/YYKit)** 代码时，发现 [ibireme](https://github.com/ibireme) 在项目里加入的一个查看当前屏幕帧数的小工具，效果如下：\n\n![](http://upload-images.jianshu.io/upload_images/332029-36fb1bdbfb423531.gif?imageMogr2/auto-orient/strip)\n\n挺实用的，实现方法也很简单，但是思路特别棒。\n\n####这里是Demo： **[YYFPSLabel](https://github.com/yehot/YYFPSLabel)**\n\n\n这里我把这个小工具从 YYKit 中抽出来，在学习大牛的代码的过程中，收货了不少东西，这里**做个笔记**：\n\n###1、FPSLabel 实现思路：\n使用 CADisplayLink 的 timestamp 属性，配合 timer 的执行次数计算得出 FPS数，详见[代码](https://github.com/yehot/YYFPSLabel/blob/master/YYFPSLabel/YYFPSLabel/YYFPSLabel.m)。\n\n###2、NSTimer、CADisplayLink 常见问题：\n>**问题1：** UIScrollView 在滑动时，timer 会被暂停的问题。\n\n—— 原因：runloop mode 导致。iOS处理滑动时，mainloop 中UIScrollView的mode是 UITrackingRunLoopMode，会优先保证界面流畅，而 timer 默认的model是 NSDefaultRunLoopMode，所以会出现被暂停。\n—— 解决办法：将timer加到 NSRunLoopCommonModes 中。\n```\n    [_link addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes];\n```\n\n详见：[深入理解RunLoop](http://blog.ibireme.com/2015/05/18/runloop/) 一文中关于 [定时器](http://blog.ibireme.com/2015/05/18/runloop/#timer)  和 [RunLoop 的 Mode](http://blog.ibireme.com/2015/05/18/runloop/#mode) 的部分\n>**问题2：**NSTimer 对于 target 的循环引用问题：\n\n以下代码很常见：\n```\n    CADisplayLink *_link = [CADisplayLink displayLinkWithTarget:self selector:@selector(tick:)];\n\n    [NSTimer timerWithTimeInterval:1.f target:self selector:@selector(tick:) userInfo:nil repeats:YES];\n\n```\n—— 原因：以上两种用法，都会对self强引用，此时 timer持有 self，self 也持有 timer，循环引用导致页面 dismiss 时，双方都无法释放，造成循环引用。\n此时使用 __weak 也不能有效解决:\n```\n    __weak typeof(self) weakSelf = self;\n    _link = [CADisplayLink displayLinkWithTarget:weakSelf selector:@selector(tick:)];\n```\n效果如下：\n\n![](http://upload-images.jianshu.io/upload_images/332029-6b2957fc2ff9cc8b.gif?imageMogr2/auto-orient/strip)\n\n**可以看到 页面 dismiss 后，计时器仍然在打印**\n\n**—— 解决办法：1、**在页面退出前，或者合适的时候，手动停止 timer，结束循环引用。\n\n注意：在 dealloc 方法中是肯定不行的！由于循环引用，dealloc 方法不会进。\n![](http://upload-images.jianshu.io/upload_images/332029-90b68a2f2381e4f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n**——解决办法：2、**YYFPSLabel 作者提供的 [YYWeakProxy](https://github.com/yehot/YYFPSLabel/blob/master/YYFPSLabel/YYFPSLabel/YYWeakProxy.m)\n\n```\n@interface YYWeakProxy : NSProxy\n@end\n\n// 使用方式：\n    _link = [CADisplayLink displayLinkWithTarget:[YYWeakProxy proxyWithTarget:self] selector:@selector(tick:)];\n\n```\n代码很少，有兴趣可以自己看下源码。\n**Tips：** OC中 NSProxy 是不继承自 NSObject 的。\n\n###3、探索环节：iOS中子线程检测主线程\n>在和小伙伴分享这个小工具的时候，潘神抛出了这样一个**问题**：\n这里组件是在主线程绘制的label，如果主线程阻塞了还能用吗？\n\n\n结果是不能。\n####以下是探索阶段：\n\n1、模拟主线程阻塞，将 link 放在子线程，发现 timer 不能启动\n```\n    // 模拟 主线程阻塞 （不应该模拟主线程卡死，模拟卡顿即可）\n    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0f * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{  \n        NSLog(@\"即将阻塞\");\n        dispatch_sync(dispatch_get_main_queue(), ^{\n            NSLog(@\"同步阻塞主线程\");\n        });\n        NSLog(@\"不会执行\");\n    });\n```\n\n2、使用CFRunLoopAddObserver检测主线程是否卡顿：\n\n```\n//将观察者添加到主线程runloop的common模式下的观察中\nCFRunLoopAddObserver(CFRunLoopGetMain(), runLoopObserver, kCFRunLoopCommonModes);\n```\n\n这里是能检测到主线程是否卡顿了，但是 timer 在子线程中还是跑不起来。\n\n参考 [Starming星光社](https://www.google.com.hk/url?sa=t&rct=j&q=&esrc=s&source=web&cd=1&ved=0ahUKEwjx0Zjw4_fLAhWVj44KHdkUAvwQFggbMAA&url=%68%74%74%70%3a%2f%2f%77%77%77%2e%73%74%61%72%6d%69%6e%67%2e%63%6f%6d%2f&usg=AFQjCNF2xjShwXV0aXfKo1yXQHN95DRCAA&sig2=C_ywHG5vt8byOOqA6x-bOw) 的 [检测iOS的APP性能的一些方法](http://www.starming.com/index.php?v=index&view=91)\n\n3、在子线程手动创建一个 runloop，提供给 timer。\n```\n    dispatch_async(dispatch_get_global_queue(0, 0), ^{\n        _link = [CADisplayLink displayLinkWithTarget:self selector:@selector(tick:)];\n        // NOTE: 子线程的runloop默认不创建； 在子线程获取 currentRunLoop 对象的时候，就会自动创建RunLoop\n        // 这里不加到 main loop，必须创建一个 runloop\n        NSRunLoop *runloop = [NSRunLoop currentRunLoop];\n        [_link addToRunLoop:runloop forMode:NSRunLoopCommonModes];\n        // 必须 timer addToRunLoop 后，再run\n        [runloop run];\n    });\n```\n\n这样，就可以在子线程中使用 timer 了，但是此时只能 log，无法获通知主线程更新UI： (这里先不在主线程更新UI了)\n```\n// 尝试1：主线程阻塞， 这里就不能获取到主线程了\n//    dispatch_async(dispatch_get_main_queue(), ^{\n//        阻塞时，想通过 在主线程更新UI 来查看是不可行了\n//        label_.text = text;\n//    });\n    \n    // 尝试2：不在主线程操作 UI ，界面会发生变化\n    label_.text = text;\n```\n\n参考: [【iOS程序启动与运转】- RunLoop个人小结](http://www.jianshu.com/p/37ab0397fec7)\n\n\n以上是学习 YYFPSLabel 时的收获，和对于在子线程中检测主线程的探索。详情可以戳代码：\n**[YYFPSLabel](https://github.com/yehot/YYFPSLabel)**\n","slug":"20160405-YYFPSLabel-source-read","published":1,"updated":"2017-03-10T06:19:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj03ftfnb00017womcu5jbum8","content":"<p>学习 <strong><a href=\"https://github.com/ibireme/YYKit\" target=\"_blank\" rel=\"external\">YYKit</a></strong> 代码时，发现 <a href=\"https://github.com/ibireme\" target=\"_blank\" rel=\"external\">ibireme</a> 在项目里加入的一个查看当前屏幕帧数的小工具，效果如下：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/332029-36fb1bdbfb423531.gif?imageMogr2/auto-orient/strip\" alt=\"\"></p>\n<p>挺实用的，实现方法也很简单，但是思路特别棒。</p>\n<p>####这里是Demo： <strong><a href=\"https://github.com/yehot/YYFPSLabel\" target=\"_blank\" rel=\"external\">YYFPSLabel</a></strong></p>\n<p>这里我把这个小工具从 YYKit 中抽出来，在学习大牛的代码的过程中，收货了不少东西，这里<strong>做个笔记</strong>：</p>\n<p>###1、FPSLabel 实现思路：<br>使用 CADisplayLink 的 timestamp 属性，配合 timer 的执行次数计算得出 FPS数，详见<a href=\"https://github.com/yehot/YYFPSLabel/blob/master/YYFPSLabel/YYFPSLabel/YYFPSLabel.m\" target=\"_blank\" rel=\"external\">代码</a>。</p>\n<p>###2、NSTimer、CADisplayLink 常见问题：</p>\n<blockquote>\n<p><strong>问题1：</strong> UIScrollView 在滑动时，timer 会被暂停的问题。</p>\n</blockquote>\n<p>—— 原因：runloop mode 导致。iOS处理滑动时，mainloop 中UIScrollView的mode是 UITrackingRunLoopMode，会优先保证界面流畅，而 timer 默认的model是 NSDefaultRunLoopMode，所以会出现被暂停。<br>—— 解决办法：将timer加到 NSRunLoopCommonModes 中。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">    [_link addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes];</div></pre></td></tr></table></figure></p>\n<p>详见：<a href=\"http://blog.ibireme.com/2015/05/18/runloop/\" target=\"_blank\" rel=\"external\">深入理解RunLoop</a> 一文中关于 <a href=\"http://blog.ibireme.com/2015/05/18/runloop/#timer\" target=\"_blank\" rel=\"external\">定时器</a>  和 <a href=\"http://blog.ibireme.com/2015/05/18/runloop/#mode\" target=\"_blank\" rel=\"external\">RunLoop 的 Mode</a> 的部分</p>\n<blockquote>\n<p><strong>问题2：</strong>NSTimer 对于 target 的循环引用问题：</p>\n</blockquote>\n<p>以下代码很常见：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">CADisplayLink *_link = [CADisplayLink displayLinkWithTarget:self selector:@selector(tick:)];</div><div class=\"line\"></div><div class=\"line\">    [NSTimer timerWithTimeInterval:1.f target:self selector:@selector(tick:) userInfo:nil repeats:YES];</div></pre></td></tr></table></figure></p>\n<p>—— 原因：以上两种用法，都会对self强引用，此时 timer持有 self，self 也持有 timer，循环引用导致页面 dismiss 时，双方都无法释放，造成循环引用。<br>此时使用 __weak 也不能有效解决:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">    __weak typeof(self) weakSelf = self;</div><div class=\"line\">    _link = [CADisplayLink displayLinkWithTarget:weakSelf selector:@selector(tick:)];</div></pre></td></tr></table></figure></p>\n<p>效果如下：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/332029-6b2957fc2ff9cc8b.gif?imageMogr2/auto-orient/strip\" alt=\"\"></p>\n<p><strong>可以看到 页面 dismiss 后，计时器仍然在打印</strong></p>\n<p><strong>—— 解决办法：1、</strong>在页面退出前，或者合适的时候，手动停止 timer，结束循环引用。</p>\n<p>注意：在 dealloc 方法中是肯定不行的！由于循环引用，dealloc 方法不会进。<br><img src=\"http://upload-images.jianshu.io/upload_images/332029-90b68a2f2381e4f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p><strong>——解决办法：2、</strong>YYFPSLabel 作者提供的 <a href=\"https://github.com/yehot/YYFPSLabel/blob/master/YYFPSLabel/YYFPSLabel/YYWeakProxy.m\" target=\"_blank\" rel=\"external\">YYWeakProxy</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface YYWeakProxy : NSProxy</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">// 使用方式：</div><div class=\"line\">    _link = [CADisplayLink displayLinkWithTarget:[YYWeakProxy proxyWithTarget:self] selector:@selector(tick:)];</div></pre></td></tr></table></figure>\n<p>代码很少，有兴趣可以自己看下源码。<br><strong>Tips：</strong> OC中 NSProxy 是不继承自 NSObject 的。</p>\n<p>###3、探索环节：iOS中子线程检测主线程</p>\n<blockquote>\n<p>在和小伙伴分享这个小工具的时候，潘神抛出了这样一个<strong>问题</strong>：<br>这里组件是在主线程绘制的label，如果主线程阻塞了还能用吗？</p>\n</blockquote>\n<p>结果是不能。</p>\n<p>####以下是探索阶段：</p>\n<p>1、模拟主线程阻塞，将 link 放在子线程，发现 timer 不能启动<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">    // 模拟 主线程阻塞 （不应该模拟主线程卡死，模拟卡顿即可）</div><div class=\"line\">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0f * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;  </div><div class=\"line\">        NSLog(@&quot;即将阻塞&quot;);</div><div class=\"line\">        dispatch_sync(dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">            NSLog(@&quot;同步阻塞主线程&quot;);</div><div class=\"line\">        &#125;);</div><div class=\"line\">        NSLog(@&quot;不会执行&quot;);</div><div class=\"line\">    &#125;);</div></pre></td></tr></table></figure></p>\n<p>2、使用CFRunLoopAddObserver检测主线程是否卡顿：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">//将观察者添加到主线程runloop的common模式下的观察中</div><div class=\"line\">CFRunLoopAddObserver(CFRunLoopGetMain(), runLoopObserver, kCFRunLoopCommonModes);</div></pre></td></tr></table></figure>\n<p>这里是能检测到主线程是否卡顿了，但是 timer 在子线程中还是跑不起来。</p>\n<p>参考 <a href=\"https://www.google.com.hk/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;ved=0ahUKEwjx0Zjw4_fLAhWVj44KHdkUAvwQFggbMAA&amp;url=%68%74%74%70%3a%2f%2f%77%77%77%2e%73%74%61%72%6d%69%6e%67%2e%63%6f%6d%2f&amp;usg=AFQjCNF2xjShwXV0aXfKo1yXQHN95DRCAA&amp;sig2=C_ywHG5vt8byOOqA6x-bOw\" target=\"_blank\" rel=\"external\">Starming星光社</a> 的 <a href=\"http://www.starming.com/index.php?v=index&amp;view=91\" target=\"_blank\" rel=\"external\">检测iOS的APP性能的一些方法</a></p>\n<p>3、在子线程手动创建一个 runloop，提供给 timer。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">    dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</div><div class=\"line\">        _link = [CADisplayLink displayLinkWithTarget:self selector:@selector(tick:)];</div><div class=\"line\">        // NOTE: 子线程的runloop默认不创建； 在子线程获取 currentRunLoop 对象的时候，就会自动创建RunLoop</div><div class=\"line\">        // 这里不加到 main loop，必须创建一个 runloop</div><div class=\"line\">        NSRunLoop *runloop = [NSRunLoop currentRunLoop];</div><div class=\"line\">        [_link addToRunLoop:runloop forMode:NSRunLoopCommonModes];</div><div class=\"line\">        // 必须 timer addToRunLoop 后，再run</div><div class=\"line\">        [runloop run];</div><div class=\"line\">    &#125;);</div></pre></td></tr></table></figure></p>\n<p>这样，就可以在子线程中使用 timer 了，但是此时只能 log，无法获通知主线程更新UI： (这里先不在主线程更新UI了)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 尝试1：主线程阻塞， 这里就不能获取到主线程了</div><div class=\"line\">//    dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">//        阻塞时，想通过 在主线程更新UI 来查看是不可行了</div><div class=\"line\">//        label_.text = text;</div><div class=\"line\">//    &#125;);</div><div class=\"line\">    </div><div class=\"line\">    // 尝试2：不在主线程操作 UI ，界面会发生变化</div><div class=\"line\">    label_.text = text;</div></pre></td></tr></table></figure></p>\n<p>参考: <a href=\"http://www.jianshu.com/p/37ab0397fec7\" target=\"_blank\" rel=\"external\">【iOS程序启动与运转】- RunLoop个人小结</a></p>\n<p>以上是学习 YYFPSLabel 时的收获，和对于在子线程中检测主线程的探索。详情可以戳代码：<br><strong><a href=\"https://github.com/yehot/YYFPSLabel\" target=\"_blank\" rel=\"external\">YYFPSLabel</a></strong></p>\n","excerpt":"","more":"<p>学习 <strong><a href=\"https://github.com/ibireme/YYKit\">YYKit</a></strong> 代码时，发现 <a href=\"https://github.com/ibireme\">ibireme</a> 在项目里加入的一个查看当前屏幕帧数的小工具，效果如下：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/332029-36fb1bdbfb423531.gif?imageMogr2/auto-orient/strip\" alt=\"\"></p>\n<p>挺实用的，实现方法也很简单，但是思路特别棒。</p>\n<p>####这里是Demo： <strong><a href=\"https://github.com/yehot/YYFPSLabel\">YYFPSLabel</a></strong></p>\n<p>这里我把这个小工具从 YYKit 中抽出来，在学习大牛的代码的过程中，收货了不少东西，这里<strong>做个笔记</strong>：</p>\n<p>###1、FPSLabel 实现思路：<br>使用 CADisplayLink 的 timestamp 属性，配合 timer 的执行次数计算得出 FPS数，详见<a href=\"https://github.com/yehot/YYFPSLabel/blob/master/YYFPSLabel/YYFPSLabel/YYFPSLabel.m\">代码</a>。</p>\n<p>###2、NSTimer、CADisplayLink 常见问题：</p>\n<blockquote>\n<p><strong>问题1：</strong> UIScrollView 在滑动时，timer 会被暂停的问题。</p>\n</blockquote>\n<p>—— 原因：runloop mode 导致。iOS处理滑动时，mainloop 中UIScrollView的mode是 UITrackingRunLoopMode，会优先保证界面流畅，而 timer 默认的model是 NSDefaultRunLoopMode，所以会出现被暂停。<br>—— 解决办法：将timer加到 NSRunLoopCommonModes 中。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">    [_link addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes];</div></pre></td></tr></table></figure></p>\n<p>详见：<a href=\"http://blog.ibireme.com/2015/05/18/runloop/\">深入理解RunLoop</a> 一文中关于 <a href=\"http://blog.ibireme.com/2015/05/18/runloop/#timer\">定时器</a>  和 <a href=\"http://blog.ibireme.com/2015/05/18/runloop/#mode\">RunLoop 的 Mode</a> 的部分</p>\n<blockquote>\n<p><strong>问题2：</strong>NSTimer 对于 target 的循环引用问题：</p>\n</blockquote>\n<p>以下代码很常见：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">CADisplayLink *_link = [CADisplayLink displayLinkWithTarget:self selector:@selector(tick:)];</div><div class=\"line\"></div><div class=\"line\">    [NSTimer timerWithTimeInterval:1.f target:self selector:@selector(tick:) userInfo:nil repeats:YES];</div></pre></td></tr></table></figure></p>\n<p>—— 原因：以上两种用法，都会对self强引用，此时 timer持有 self，self 也持有 timer，循环引用导致页面 dismiss 时，双方都无法释放，造成循环引用。<br>此时使用 __weak 也不能有效解决:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">    __weak typeof(self) weakSelf = self;</div><div class=\"line\">    _link = [CADisplayLink displayLinkWithTarget:weakSelf selector:@selector(tick:)];</div></pre></td></tr></table></figure></p>\n<p>效果如下：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/332029-6b2957fc2ff9cc8b.gif?imageMogr2/auto-orient/strip\" alt=\"\"></p>\n<p><strong>可以看到 页面 dismiss 后，计时器仍然在打印</strong></p>\n<p><strong>—— 解决办法：1、</strong>在页面退出前，或者合适的时候，手动停止 timer，结束循环引用。</p>\n<p>注意：在 dealloc 方法中是肯定不行的！由于循环引用，dealloc 方法不会进。<br><img src=\"http://upload-images.jianshu.io/upload_images/332029-90b68a2f2381e4f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p><strong>——解决办法：2、</strong>YYFPSLabel 作者提供的 <a href=\"https://github.com/yehot/YYFPSLabel/blob/master/YYFPSLabel/YYFPSLabel/YYWeakProxy.m\">YYWeakProxy</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface YYWeakProxy : NSProxy</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">// 使用方式：</div><div class=\"line\">    _link = [CADisplayLink displayLinkWithTarget:[YYWeakProxy proxyWithTarget:self] selector:@selector(tick:)];</div></pre></td></tr></table></figure>\n<p>代码很少，有兴趣可以自己看下源码。<br><strong>Tips：</strong> OC中 NSProxy 是不继承自 NSObject 的。</p>\n<p>###3、探索环节：iOS中子线程检测主线程</p>\n<blockquote>\n<p>在和小伙伴分享这个小工具的时候，潘神抛出了这样一个<strong>问题</strong>：<br>这里组件是在主线程绘制的label，如果主线程阻塞了还能用吗？</p>\n</blockquote>\n<p>结果是不能。</p>\n<p>####以下是探索阶段：</p>\n<p>1、模拟主线程阻塞，将 link 放在子线程，发现 timer 不能启动<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">    // 模拟 主线程阻塞 （不应该模拟主线程卡死，模拟卡顿即可）</div><div class=\"line\">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0f * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;  </div><div class=\"line\">        NSLog(@&quot;即将阻塞&quot;);</div><div class=\"line\">        dispatch_sync(dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">            NSLog(@&quot;同步阻塞主线程&quot;);</div><div class=\"line\">        &#125;);</div><div class=\"line\">        NSLog(@&quot;不会执行&quot;);</div><div class=\"line\">    &#125;);</div></pre></td></tr></table></figure></p>\n<p>2、使用CFRunLoopAddObserver检测主线程是否卡顿：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">//将观察者添加到主线程runloop的common模式下的观察中</div><div class=\"line\">CFRunLoopAddObserver(CFRunLoopGetMain(), runLoopObserver, kCFRunLoopCommonModes);</div></pre></td></tr></table></figure>\n<p>这里是能检测到主线程是否卡顿了，但是 timer 在子线程中还是跑不起来。</p>\n<p>参考 <a href=\"https://www.google.com.hk/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;ved=0ahUKEwjx0Zjw4_fLAhWVj44KHdkUAvwQFggbMAA&amp;url=%68%74%74%70%3a%2f%2f%77%77%77%2e%73%74%61%72%6d%69%6e%67%2e%63%6f%6d%2f&amp;usg=AFQjCNF2xjShwXV0aXfKo1yXQHN95DRCAA&amp;sig2=C_ywHG5vt8byOOqA6x-bOw\">Starming星光社</a> 的 <a href=\"http://www.starming.com/index.php?v=index&amp;view=91\">检测iOS的APP性能的一些方法</a></p>\n<p>3、在子线程手动创建一个 runloop，提供给 timer。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">    dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</div><div class=\"line\">        _link = [CADisplayLink displayLinkWithTarget:self selector:@selector(tick:)];</div><div class=\"line\">        // NOTE: 子线程的runloop默认不创建； 在子线程获取 currentRunLoop 对象的时候，就会自动创建RunLoop</div><div class=\"line\">        // 这里不加到 main loop，必须创建一个 runloop</div><div class=\"line\">        NSRunLoop *runloop = [NSRunLoop currentRunLoop];</div><div class=\"line\">        [_link addToRunLoop:runloop forMode:NSRunLoopCommonModes];</div><div class=\"line\">        // 必须 timer addToRunLoop 后，再run</div><div class=\"line\">        [runloop run];</div><div class=\"line\">    &#125;);</div></pre></td></tr></table></figure></p>\n<p>这样，就可以在子线程中使用 timer 了，但是此时只能 log，无法获通知主线程更新UI： (这里先不在主线程更新UI了)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 尝试1：主线程阻塞， 这里就不能获取到主线程了</div><div class=\"line\">//    dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class=\"line\">//        阻塞时，想通过 在主线程更新UI 来查看是不可行了</div><div class=\"line\">//        label_.text = text;</div><div class=\"line\">//    &#125;);</div><div class=\"line\">    </div><div class=\"line\">    // 尝试2：不在主线程操作 UI ，界面会发生变化</div><div class=\"line\">    label_.text = text;</div></pre></td></tr></table></figure></p>\n<p>参考: <a href=\"http://www.jianshu.com/p/37ab0397fec7\">【iOS程序启动与运转】- RunLoop个人小结</a></p>\n<p>以上是学习 YYFPSLabel 时的收获，和对于在子线程中检测主线程的探索。详情可以戳代码：<br><strong><a href=\"https://github.com/yehot/YYFPSLabel\">YYFPSLabel</a></strong></p>\n"},{"title":"iOS组件化方案调研","date":"2016-05-31T06:01:10.000Z","_content":"\n# iOS组件化方案探索\n\n## 一、什么是组件化？\n\n### 什么是组件？\n\n`\"组件\"`一般来说用于命名比较小的功能块，如：下拉刷新组件、提示框组件。而较大粒度的业务功能，我们习惯称之为`\"模块\"`，如：首页模块、我的模块、新闻模块。\n\n这次讨论的主题是组件化，这里为了方便表述，下面模块和组件代表同一个意思，都是指较大粒度的业务模块。\n\n### 什么是组件化？\n\n组件化，或者说模块化，用来分割、组织和打包软件。每个模块完成一个特定的子功能，所有的模块按某种方法组装起来，成为一个整体，完成整个系统所要求的功能。\n\n从工程代码层面来说，组件化的实施通常是通过`中间件`解决组件间头文件直接引用、依赖混乱的问题；从实际开发来说，组件之间最大的需求就是页面跳转，需要从组件A的pageA页面跳转到组件B的pageB页面，避免对组件B页面ViewController头文件的直接依赖。\n\n\n## 二、为什么要组件化？\n\n从两个方面论述：\n\n### 组件化是为了解决什么问题？\n\n一个 APP 有多个模块，模块之间会通信，互相调用，如我们的证券app，有首页、行情、资讯、我的等模块。这些模块会互相调用，例如 首页底部需要展示部分资讯、行情；行情底部需要展示个股资讯；资讯详情页需要跳转到行情，等等。\n\n一般我们是怎样调用呢，以首页调用资讯为例，会这样写：\n\n```\n#import \"HomeViewController.h\"\n#import \"NewsViewController.h\"\n\n@implementation HomeViewController\n\n+ (void)gotoNews {\n\n NewsViewController *detailVC = [[NewsViewController alloc] initWithStockCode:self.codeNum];\n [self.navigationController.pushViewController:detailVC animated:YES];\n}\n\n@end\n```\n\n看起来挺好，这样做简单明了，没有多余的东西，项目初期推荐这样快速开发，但到了项目越来越庞大，这种方式会有什么问题呢？\n\n- 问题1，每个模块都离不开其他模块，互相依赖粘在一起成为一坨：\n\n![各模块互相依赖.png](http://upload-images.jianshu.io/upload_images/332029-f03757f38936ed16.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n耦合比较严重（因为没有明确的约束，「组件」间引用的现象会比较多）\n- 问题2，多人同时开发时，容易出现冲突（尤其是Xcode Project文件）\n- 问题3，业务方的开发效率不够高（只关心自己的组件，却要编译整个项目，与其他不相干的代码糅合在一起）\n\n### 组件化的好处？\n\n**一般意义：**\n\n- 加快编译速度（不用编译主客那一大坨代码了）；\n- 各组件自由选择开发姿势（MVC / MVVM / FRP）；\n- 组件工程本身可以独立开发测试，方便 QA 有针对性地测试；\n- 规范组件之间的通信接，让各个组件对外都提供一个黑盒服务，减少沟通和维护成本，提高效率；\n\n**对于公司已有项目的现实意义：**\n\n- 业务分层、解耦，使代码变得可维护；\n- 有效的拆分、组织日益庞大的工程代码，使工程目录变得可维护；\n- 便于各业务功能拆分、抽离，实现真正的功能复用；\n- 业务隔离，跨团队开发代码控制和版本风险控制的实现；\n- 模块化对代码的封装性、合理性都有一定的要求，提升开发同学的设计能力；\n- 在维护好各级组件的情况下，随意组合满足不同客户需求；（只需要将之前的多个业务组件模块在新的主App中进行组装即可快速迭代出下一个全新App）\n\n\n### 什么情况下进行组件化比较合适？\n\n当然组件化也有它的缺点：\n\n- 学习成本高，对于开发人员对各种工具的掌握要求也比较高，对于新手来说入门较为困难。\n\n- 由于工具和流程的复杂化，导致团队之间协作的成本变高，某些情况下可能会导致开发效率下降。\n\n当项目App处于起步阶段、各个需求模块趋于成熟稳定的过程中，组件化也许并没有那么迫切，甚至考虑组件化的架构可能会影响开发效率和需求迭代。\n\n而当项目迭代到一定时期之后，便会出现一些相对独立的业务功能模块，而团队的规模也会随着项目迭代逐渐增长，这便是中小型应用考虑组件化的时机了。这时为了更好的分工协作，团队安排团队成员各自维护一个相对独立的业务组件是比较常见的做法。\n\n在这时这个时候来引入组件化方案，是比较合适的时机。长远来看，组件化带来的好处是远远大于坏处的，特别是随着项目的规模增大，这种好处会变得越来越明显\n\n\n## 三、如何组件化？\n\n> 组件化的开展需要解决以下几个层次的问题：\n\n### 组件化的架构目标？\n\n借用Limboy的图：\n\n![组件化架构.png](http://upload-images.jianshu.io/upload_images/332029-4c7b8e152db83b9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 如何划分组件？\n\n- 基础功能组件\n- 基础产品组件\n- 个性化业务组件\n\n对于一个没有实施过组件化拆分的工程来说，其中很可能充满了大量不合理的类、方法、头文件和各种错乱的依赖关系，因此首先要进行的第一步是模块拆分。\n\n模块拆分可以分成两个部分，基础模块拆分和业务模块拆分。基础模块通常是稳定的依赖代码，业务模块是涉及到业务的需要频繁改动的代码。\n\n> 基础模块拆分\n\n基础模块是任何一个App都需要用到的，如：性能统计、Networking、Patch、网络诊断、数据存储模块。对于基础模块来说，其本身应该是自洽的，即可以单独编译或者几个模块合在一起可以单独编译。所有的依赖关系都应该是业务模块指向基础模块的。\n基础模块之间尽量避免产生横向依赖。\n\n> 业务模块拆分\n\n对于业务模块来说，考虑到旧有代码可能没有相关的横向解耦策略，业务模块之间的依赖会非常复杂，难以单独进行拆分，因此我们采用的方法是首先从 group 角度进行重新整理。\n\n对业务量很大的工程来说，我个人更加推荐“业务-分层”这样的结构，而不是“分层-业务”，即类似下面的 group 结构：\n\n```\n- BusinessA\n  - Model\n  - View\n  - Controller\n  - Store\n- BusinessB\n  - Model\n  - View\n  - Controller\n  -Store\n```\n\n而非目前项目中采用的：\n\n```\n- Controllers\n  - BusinessA_Controller\n  - BusinessB_Controller\n- Views\n  - BusinessA_View\n  - BusinessB_View\n- Models\n  - BusinessA_Model\n  - BusinessB_Model\n```\n\n### 组件化的技术难点？\n\n> 组件化的实施，直观上看，只是需要将各业务组件的代码放到各自的文件夹或者 jar包里就行了。\n\n这里引出的是：\n\n#### 1、组件的拆分方式问题：\n\n可以利用CocoaPods 配合 git 做代码版本管理，独立业务模块单独成库。\n\n但这仅仅是物理上拆分了，拆分后的代码编译是肯定通不过的，因为如下：\n\n```\n\n#import \"MainViewController.h\"\n#import \"HomeViewController.h\"\n#import \"NewsViewController.h\"\n#import \"MeViewController.h\"\n#import ...\n\n@implementation MainViewController\n\n@end\n\n```\n\n`MainViewController` 会找不到依赖的其它各个模块的头文件而报错。这里引出的又是另一个问题：\n\n#### 2、组件间如何解耦？\n\n组件间解耦，是组件化必须解决的一个问题。换句话说，就是如何解除业务模块间的横向依赖。还是拿上边举得例子来说：\n\nApp的根视图`MainViewController`需要管理首页、新闻、我的等等页面时，如何做到 ``MainViewController`` 中，不用去 ``import``这一大堆 `XXViewController` ?\n\n很简单，按软件工程的思路，下意识就会加一个中间层Mediator：\n\n![中间层.png](http://upload-images.jianshu.io/upload_images/332029-bd66e6dac09f2e08.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n这样一来，各个模块直接都不需要再互相依赖，而是仅需要依赖 Mediator 层即可。\n\n可直观上看，这样做并没有什么好处，依赖关系并没有解除，Mediator 依赖了所有模块，而调用者又依赖 Mediator，最后还是一坨互相依赖，跟原来没有 Mediator 的方案相比除了更麻烦点其他没区别。\n\n我们希望最终能过实现的是单向的依赖，即：\n\n![单向依赖.png](http://upload-images.jianshu.io/upload_images/332029-4bbac402d8344090.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n对此，可以参考业内的流行方案：\n\n- 基于 URL Router、ModuleManager\n    代表：[蘑菇街 Limboy](http://limboy.me/ios/2016/03/10/mgj-components.html)\n\n- 基于 Target-Action、Runtime、Category\n    代表：[安居客 casa](http://casatwy.com/iOS-Modulization.html?hmsr=toutiao.io&utm_medium=toutiao.io&utm_source=toutiao.io)\n\n具体实现方案较为抽象，这里暂时先不详细展开论述，可以参见Demo：\n\n[Demo1 基于 Target-Action](https://github.com/yehot/CTMediator)\n\n[Demo2 基于 URL Router](https://github.com/yehot/routable-ios)\n\n\n## 四、其它\n\n### 开发流程控制\n\n> 托管平台选择\n\n自己利用开源的方案搭建私有的托管平台，可以最大限制地保证代码的安全。开源方案当中最知名也是最为广泛使用的当属 Gitlab。\n\n组件化使我们从单一的主工程，变成了主工程+多个拆分好的基础模块+统一的私有 Spec 仓库。为了避免某个人的工作对其他人开发环境造成影响，需要对整个组的开发流程进行统一的规范。\n\n不管是对于主仓库和子模块仓库，git-flow 都是首先推荐的工作流程。一个仓库的 master 分支只有所有者可以有权限更改，其他的贡献者想更改的话，需要自己创建新的分支（在 Github 上就是进行 fork），然后进行更改，之后把更改向原仓库发送 Pull Request。Pull Request 就是一个合并的请求，其中可以看到贡献者的更改，项目主人和其他维护者可以对 Pull Request 进行审核，共同探讨修改意见。当项目主人认为修改 OK 之后，就可以合并这个 Pull Request ，把这部分代码合并到主分支。\n\n这个流程是完全分布式的，也就是说可以同时有多个贡献者在不同的分支进行工作，最后统一合并到主分支上，实现并行协作。\n\n同时在审核 Pull Request 阶段，除了人工审核代码之外，Github 还加入了对于持续集成的支持，可以检测这个 Pull Request 是不是能够通过测试的，进一步保证了代码的质量。\n\n\n### 组件维护问题？\n\n待补充\n\n\n\n\n\n## 五、参考资料：\n\n### 相关技术博客：\n\n1、[iOS应用架构谈 组件化方案](http://casatwy.com/iOS-Modulization.html?hmsr=toutiao.io&utm_medium=toutiao.io&utm_source=toutiao.io)\n\n2、[蘑菇街 App 的组件化之路](http://limboy.me/ios/2016/03/10/mgj-components.html)\n\n[蘑菇街 App 的组件化之路·续](http://limboy.me/ios/2016/03/14/mgj-components-continued.html)\n\n3、[iOS 组件化方案探索](http://blog.cnbang.net/tech/3080/)\n\n4、[《iOS应用架构谈 组件化方案》和《蘑菇街 App 的组件化之路》的阅读指导](http://www.reviewcode.cn/article.html?reviewId=20)\n\n5、[浅析 iOS 应用组件化设计](https://skyline75489.github.io/post/2016-3-16_ios_module_design.html)\n\n6、[糯米移动组件架构演进之路](http://chuansong.me/n/320688951236)\n\n7、[饿了么移动APP的架构演进](https://www.sdk.cn/news/2023)\n\n8、[滴滴出行iOS客户端架构演进之路](https://mp.weixin.qq.com/s?__biz=MzA3ODg4MDk0Ng%3D%3D&idx=1&mid=402854111&sn=5876e615fabd6d921285d904e16670fb)\n\n9、[ios业务模块间互相跳转的解耦方案](http://www.aliog.com/101363.html)\n\n10、[iOS组件化思路－大神博客研读和思考](http://cdn0.jianshu.io/p/afb9b52143d4)\n\n11、[模块化与解耦](https://blog.cnbluebox.com/blog/2015/11/28/module-and-decoupling/)\n\n### 相关解决方案\n\n1、[casatwy/CTMediator](https://github.com/casatwy/CTMediator)\n\n2、[mogujie/MGJRouter](https://github.com/mogujie/MGJRouter)\n\n3、[joeldev/JLRoutes](https://github.com/joeldev/JLRoutes)\n\n4、[Huohua/HHRouter](https://github.com/Huohua/HHRouter)\n\n5、[clayallsopp/routable-ios](https://github.com/clayallsopp/routable-ios)\n\n6、[Lede-Inc/LDBusBundle_IOS](https://github.com/Lede-Inc/LDBusBundle_IOS)\n\n### 私有Cocoapods实施方案\n\n1、[使用Cocoapods创建私有podspec - GeekerProbe](http://blog.wtlucky.com/blog/2015/02/26/create-private-podspec/)\n\n2、[Cocoapods系列教程(三)——私有库管理和模块化管理](http://www.pluto-y.com/cocoapod-private-pods-and-module-manager/)\n\n3、[iOS组件化实践方案－LDBusMediator炼就](http://www.jianshu.com/p/196f66d31543)\n\n4、[基于 CocoaPods 和 Git 的 iOS 工程组件化实践](https://skyline75489.github.io/post/2016-3-19_ios_modularization_practice.html)\n\n5、[Cocoapods代码管理](https://blog.cnbluebox.com/blog/2014/03/31/cocoapodsdai-ma-guan-li/)\n\n6、[CocoaPods创建私有Pods](http://www.liuchungui.com/blog/2015/10/19/cocoapodschuang-jian-si-you-pods/)\n\n7、[如何创建私有 CocoaPods 仓库](http://www.jianshu.com/p/ddc2490bff9f)\n","source":"_posts/20160531-ios-module-investigation.md","raw":"---\ntitle: iOS组件化方案调研\ndate: 2016-05-31 14:01:10\ntags: module\n---\n\n# iOS组件化方案探索\n\n## 一、什么是组件化？\n\n### 什么是组件？\n\n`\"组件\"`一般来说用于命名比较小的功能块，如：下拉刷新组件、提示框组件。而较大粒度的业务功能，我们习惯称之为`\"模块\"`，如：首页模块、我的模块、新闻模块。\n\n这次讨论的主题是组件化，这里为了方便表述，下面模块和组件代表同一个意思，都是指较大粒度的业务模块。\n\n### 什么是组件化？\n\n组件化，或者说模块化，用来分割、组织和打包软件。每个模块完成一个特定的子功能，所有的模块按某种方法组装起来，成为一个整体，完成整个系统所要求的功能。\n\n从工程代码层面来说，组件化的实施通常是通过`中间件`解决组件间头文件直接引用、依赖混乱的问题；从实际开发来说，组件之间最大的需求就是页面跳转，需要从组件A的pageA页面跳转到组件B的pageB页面，避免对组件B页面ViewController头文件的直接依赖。\n\n\n## 二、为什么要组件化？\n\n从两个方面论述：\n\n### 组件化是为了解决什么问题？\n\n一个 APP 有多个模块，模块之间会通信，互相调用，如我们的证券app，有首页、行情、资讯、我的等模块。这些模块会互相调用，例如 首页底部需要展示部分资讯、行情；行情底部需要展示个股资讯；资讯详情页需要跳转到行情，等等。\n\n一般我们是怎样调用呢，以首页调用资讯为例，会这样写：\n\n```\n#import \"HomeViewController.h\"\n#import \"NewsViewController.h\"\n\n@implementation HomeViewController\n\n+ (void)gotoNews {\n\n NewsViewController *detailVC = [[NewsViewController alloc] initWithStockCode:self.codeNum];\n [self.navigationController.pushViewController:detailVC animated:YES];\n}\n\n@end\n```\n\n看起来挺好，这样做简单明了，没有多余的东西，项目初期推荐这样快速开发，但到了项目越来越庞大，这种方式会有什么问题呢？\n\n- 问题1，每个模块都离不开其他模块，互相依赖粘在一起成为一坨：\n\n![各模块互相依赖.png](http://upload-images.jianshu.io/upload_images/332029-f03757f38936ed16.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n耦合比较严重（因为没有明确的约束，「组件」间引用的现象会比较多）\n- 问题2，多人同时开发时，容易出现冲突（尤其是Xcode Project文件）\n- 问题3，业务方的开发效率不够高（只关心自己的组件，却要编译整个项目，与其他不相干的代码糅合在一起）\n\n### 组件化的好处？\n\n**一般意义：**\n\n- 加快编译速度（不用编译主客那一大坨代码了）；\n- 各组件自由选择开发姿势（MVC / MVVM / FRP）；\n- 组件工程本身可以独立开发测试，方便 QA 有针对性地测试；\n- 规范组件之间的通信接，让各个组件对外都提供一个黑盒服务，减少沟通和维护成本，提高效率；\n\n**对于公司已有项目的现实意义：**\n\n- 业务分层、解耦，使代码变得可维护；\n- 有效的拆分、组织日益庞大的工程代码，使工程目录变得可维护；\n- 便于各业务功能拆分、抽离，实现真正的功能复用；\n- 业务隔离，跨团队开发代码控制和版本风险控制的实现；\n- 模块化对代码的封装性、合理性都有一定的要求，提升开发同学的设计能力；\n- 在维护好各级组件的情况下，随意组合满足不同客户需求；（只需要将之前的多个业务组件模块在新的主App中进行组装即可快速迭代出下一个全新App）\n\n\n### 什么情况下进行组件化比较合适？\n\n当然组件化也有它的缺点：\n\n- 学习成本高，对于开发人员对各种工具的掌握要求也比较高，对于新手来说入门较为困难。\n\n- 由于工具和流程的复杂化，导致团队之间协作的成本变高，某些情况下可能会导致开发效率下降。\n\n当项目App处于起步阶段、各个需求模块趋于成熟稳定的过程中，组件化也许并没有那么迫切，甚至考虑组件化的架构可能会影响开发效率和需求迭代。\n\n而当项目迭代到一定时期之后，便会出现一些相对独立的业务功能模块，而团队的规模也会随着项目迭代逐渐增长，这便是中小型应用考虑组件化的时机了。这时为了更好的分工协作，团队安排团队成员各自维护一个相对独立的业务组件是比较常见的做法。\n\n在这时这个时候来引入组件化方案，是比较合适的时机。长远来看，组件化带来的好处是远远大于坏处的，特别是随着项目的规模增大，这种好处会变得越来越明显\n\n\n## 三、如何组件化？\n\n> 组件化的开展需要解决以下几个层次的问题：\n\n### 组件化的架构目标？\n\n借用Limboy的图：\n\n![组件化架构.png](http://upload-images.jianshu.io/upload_images/332029-4c7b8e152db83b9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 如何划分组件？\n\n- 基础功能组件\n- 基础产品组件\n- 个性化业务组件\n\n对于一个没有实施过组件化拆分的工程来说，其中很可能充满了大量不合理的类、方法、头文件和各种错乱的依赖关系，因此首先要进行的第一步是模块拆分。\n\n模块拆分可以分成两个部分，基础模块拆分和业务模块拆分。基础模块通常是稳定的依赖代码，业务模块是涉及到业务的需要频繁改动的代码。\n\n> 基础模块拆分\n\n基础模块是任何一个App都需要用到的，如：性能统计、Networking、Patch、网络诊断、数据存储模块。对于基础模块来说，其本身应该是自洽的，即可以单独编译或者几个模块合在一起可以单独编译。所有的依赖关系都应该是业务模块指向基础模块的。\n基础模块之间尽量避免产生横向依赖。\n\n> 业务模块拆分\n\n对于业务模块来说，考虑到旧有代码可能没有相关的横向解耦策略，业务模块之间的依赖会非常复杂，难以单独进行拆分，因此我们采用的方法是首先从 group 角度进行重新整理。\n\n对业务量很大的工程来说，我个人更加推荐“业务-分层”这样的结构，而不是“分层-业务”，即类似下面的 group 结构：\n\n```\n- BusinessA\n  - Model\n  - View\n  - Controller\n  - Store\n- BusinessB\n  - Model\n  - View\n  - Controller\n  -Store\n```\n\n而非目前项目中采用的：\n\n```\n- Controllers\n  - BusinessA_Controller\n  - BusinessB_Controller\n- Views\n  - BusinessA_View\n  - BusinessB_View\n- Models\n  - BusinessA_Model\n  - BusinessB_Model\n```\n\n### 组件化的技术难点？\n\n> 组件化的实施，直观上看，只是需要将各业务组件的代码放到各自的文件夹或者 jar包里就行了。\n\n这里引出的是：\n\n#### 1、组件的拆分方式问题：\n\n可以利用CocoaPods 配合 git 做代码版本管理，独立业务模块单独成库。\n\n但这仅仅是物理上拆分了，拆分后的代码编译是肯定通不过的，因为如下：\n\n```\n\n#import \"MainViewController.h\"\n#import \"HomeViewController.h\"\n#import \"NewsViewController.h\"\n#import \"MeViewController.h\"\n#import ...\n\n@implementation MainViewController\n\n@end\n\n```\n\n`MainViewController` 会找不到依赖的其它各个模块的头文件而报错。这里引出的又是另一个问题：\n\n#### 2、组件间如何解耦？\n\n组件间解耦，是组件化必须解决的一个问题。换句话说，就是如何解除业务模块间的横向依赖。还是拿上边举得例子来说：\n\nApp的根视图`MainViewController`需要管理首页、新闻、我的等等页面时，如何做到 ``MainViewController`` 中，不用去 ``import``这一大堆 `XXViewController` ?\n\n很简单，按软件工程的思路，下意识就会加一个中间层Mediator：\n\n![中间层.png](http://upload-images.jianshu.io/upload_images/332029-bd66e6dac09f2e08.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n这样一来，各个模块直接都不需要再互相依赖，而是仅需要依赖 Mediator 层即可。\n\n可直观上看，这样做并没有什么好处，依赖关系并没有解除，Mediator 依赖了所有模块，而调用者又依赖 Mediator，最后还是一坨互相依赖，跟原来没有 Mediator 的方案相比除了更麻烦点其他没区别。\n\n我们希望最终能过实现的是单向的依赖，即：\n\n![单向依赖.png](http://upload-images.jianshu.io/upload_images/332029-4bbac402d8344090.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n对此，可以参考业内的流行方案：\n\n- 基于 URL Router、ModuleManager\n    代表：[蘑菇街 Limboy](http://limboy.me/ios/2016/03/10/mgj-components.html)\n\n- 基于 Target-Action、Runtime、Category\n    代表：[安居客 casa](http://casatwy.com/iOS-Modulization.html?hmsr=toutiao.io&utm_medium=toutiao.io&utm_source=toutiao.io)\n\n具体实现方案较为抽象，这里暂时先不详细展开论述，可以参见Demo：\n\n[Demo1 基于 Target-Action](https://github.com/yehot/CTMediator)\n\n[Demo2 基于 URL Router](https://github.com/yehot/routable-ios)\n\n\n## 四、其它\n\n### 开发流程控制\n\n> 托管平台选择\n\n自己利用开源的方案搭建私有的托管平台，可以最大限制地保证代码的安全。开源方案当中最知名也是最为广泛使用的当属 Gitlab。\n\n组件化使我们从单一的主工程，变成了主工程+多个拆分好的基础模块+统一的私有 Spec 仓库。为了避免某个人的工作对其他人开发环境造成影响，需要对整个组的开发流程进行统一的规范。\n\n不管是对于主仓库和子模块仓库，git-flow 都是首先推荐的工作流程。一个仓库的 master 分支只有所有者可以有权限更改，其他的贡献者想更改的话，需要自己创建新的分支（在 Github 上就是进行 fork），然后进行更改，之后把更改向原仓库发送 Pull Request。Pull Request 就是一个合并的请求，其中可以看到贡献者的更改，项目主人和其他维护者可以对 Pull Request 进行审核，共同探讨修改意见。当项目主人认为修改 OK 之后，就可以合并这个 Pull Request ，把这部分代码合并到主分支。\n\n这个流程是完全分布式的，也就是说可以同时有多个贡献者在不同的分支进行工作，最后统一合并到主分支上，实现并行协作。\n\n同时在审核 Pull Request 阶段，除了人工审核代码之外，Github 还加入了对于持续集成的支持，可以检测这个 Pull Request 是不是能够通过测试的，进一步保证了代码的质量。\n\n\n### 组件维护问题？\n\n待补充\n\n\n\n\n\n## 五、参考资料：\n\n### 相关技术博客：\n\n1、[iOS应用架构谈 组件化方案](http://casatwy.com/iOS-Modulization.html?hmsr=toutiao.io&utm_medium=toutiao.io&utm_source=toutiao.io)\n\n2、[蘑菇街 App 的组件化之路](http://limboy.me/ios/2016/03/10/mgj-components.html)\n\n[蘑菇街 App 的组件化之路·续](http://limboy.me/ios/2016/03/14/mgj-components-continued.html)\n\n3、[iOS 组件化方案探索](http://blog.cnbang.net/tech/3080/)\n\n4、[《iOS应用架构谈 组件化方案》和《蘑菇街 App 的组件化之路》的阅读指导](http://www.reviewcode.cn/article.html?reviewId=20)\n\n5、[浅析 iOS 应用组件化设计](https://skyline75489.github.io/post/2016-3-16_ios_module_design.html)\n\n6、[糯米移动组件架构演进之路](http://chuansong.me/n/320688951236)\n\n7、[饿了么移动APP的架构演进](https://www.sdk.cn/news/2023)\n\n8、[滴滴出行iOS客户端架构演进之路](https://mp.weixin.qq.com/s?__biz=MzA3ODg4MDk0Ng%3D%3D&idx=1&mid=402854111&sn=5876e615fabd6d921285d904e16670fb)\n\n9、[ios业务模块间互相跳转的解耦方案](http://www.aliog.com/101363.html)\n\n10、[iOS组件化思路－大神博客研读和思考](http://cdn0.jianshu.io/p/afb9b52143d4)\n\n11、[模块化与解耦](https://blog.cnbluebox.com/blog/2015/11/28/module-and-decoupling/)\n\n### 相关解决方案\n\n1、[casatwy/CTMediator](https://github.com/casatwy/CTMediator)\n\n2、[mogujie/MGJRouter](https://github.com/mogujie/MGJRouter)\n\n3、[joeldev/JLRoutes](https://github.com/joeldev/JLRoutes)\n\n4、[Huohua/HHRouter](https://github.com/Huohua/HHRouter)\n\n5、[clayallsopp/routable-ios](https://github.com/clayallsopp/routable-ios)\n\n6、[Lede-Inc/LDBusBundle_IOS](https://github.com/Lede-Inc/LDBusBundle_IOS)\n\n### 私有Cocoapods实施方案\n\n1、[使用Cocoapods创建私有podspec - GeekerProbe](http://blog.wtlucky.com/blog/2015/02/26/create-private-podspec/)\n\n2、[Cocoapods系列教程(三)——私有库管理和模块化管理](http://www.pluto-y.com/cocoapod-private-pods-and-module-manager/)\n\n3、[iOS组件化实践方案－LDBusMediator炼就](http://www.jianshu.com/p/196f66d31543)\n\n4、[基于 CocoaPods 和 Git 的 iOS 工程组件化实践](https://skyline75489.github.io/post/2016-3-19_ios_modularization_practice.html)\n\n5、[Cocoapods代码管理](https://blog.cnbluebox.com/blog/2014/03/31/cocoapodsdai-ma-guan-li/)\n\n6、[CocoaPods创建私有Pods](http://www.liuchungui.com/blog/2015/10/19/cocoapodschuang-jian-si-you-pods/)\n\n7、[如何创建私有 CocoaPods 仓库](http://www.jianshu.com/p/ddc2490bff9f)\n","slug":"20160531-ios-module-investigation","published":1,"updated":"2017-03-10T06:03:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj03ftfnh00027wom7vdahjuh","content":"<h1 id=\"iOS组件化方案探索\"><a href=\"#iOS组件化方案探索\" class=\"headerlink\" title=\"iOS组件化方案探索\"></a>iOS组件化方案探索</h1><h2 id=\"一、什么是组件化？\"><a href=\"#一、什么是组件化？\" class=\"headerlink\" title=\"一、什么是组件化？\"></a>一、什么是组件化？</h2><h3 id=\"什么是组件？\"><a href=\"#什么是组件？\" class=\"headerlink\" title=\"什么是组件？\"></a>什么是组件？</h3><p><code>&quot;组件&quot;</code>一般来说用于命名比较小的功能块，如：下拉刷新组件、提示框组件。而较大粒度的业务功能，我们习惯称之为<code>&quot;模块&quot;</code>，如：首页模块、我的模块、新闻模块。</p>\n<p>这次讨论的主题是组件化，这里为了方便表述，下面模块和组件代表同一个意思，都是指较大粒度的业务模块。</p>\n<h3 id=\"什么是组件化？\"><a href=\"#什么是组件化？\" class=\"headerlink\" title=\"什么是组件化？\"></a>什么是组件化？</h3><p>组件化，或者说模块化，用来分割、组织和打包软件。每个模块完成一个特定的子功能，所有的模块按某种方法组装起来，成为一个整体，完成整个系统所要求的功能。</p>\n<p>从工程代码层面来说，组件化的实施通常是通过<code>中间件</code>解决组件间头文件直接引用、依赖混乱的问题；从实际开发来说，组件之间最大的需求就是页面跳转，需要从组件A的pageA页面跳转到组件B的pageB页面，避免对组件B页面ViewController头文件的直接依赖。</p>\n<h2 id=\"二、为什么要组件化？\"><a href=\"#二、为什么要组件化？\" class=\"headerlink\" title=\"二、为什么要组件化？\"></a>二、为什么要组件化？</h2><p>从两个方面论述：</p>\n<h3 id=\"组件化是为了解决什么问题？\"><a href=\"#组件化是为了解决什么问题？\" class=\"headerlink\" title=\"组件化是为了解决什么问题？\"></a>组件化是为了解决什么问题？</h3><p>一个 APP 有多个模块，模块之间会通信，互相调用，如我们的证券app，有首页、行情、资讯、我的等模块。这些模块会互相调用，例如 首页底部需要展示部分资讯、行情；行情底部需要展示个股资讯；资讯详情页需要跳转到行情，等等。</p>\n<p>一般我们是怎样调用呢，以首页调用资讯为例，会这样写：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &quot;HomeViewController.h&quot;</div><div class=\"line\">#import &quot;NewsViewController.h&quot;</div><div class=\"line\"></div><div class=\"line\">@implementation HomeViewController</div><div class=\"line\"></div><div class=\"line\">+ (void)gotoNews &#123;</div><div class=\"line\"></div><div class=\"line\"> NewsViewController *detailVC = [[NewsViewController alloc] initWithStockCode:self.codeNum];</div><div class=\"line\"> [self.navigationController.pushViewController:detailVC animated:YES];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>看起来挺好，这样做简单明了，没有多余的东西，项目初期推荐这样快速开发，但到了项目越来越庞大，这种方式会有什么问题呢？</p>\n<ul>\n<li>问题1，每个模块都离不开其他模块，互相依赖粘在一起成为一坨：</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/332029-f03757f38936ed16.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"各模块互相依赖.png\"></p>\n<p>耦合比较严重（因为没有明确的约束，「组件」间引用的现象会比较多）</p>\n<ul>\n<li>问题2，多人同时开发时，容易出现冲突（尤其是Xcode Project文件）</li>\n<li>问题3，业务方的开发效率不够高（只关心自己的组件，却要编译整个项目，与其他不相干的代码糅合在一起）</li>\n</ul>\n<h3 id=\"组件化的好处？\"><a href=\"#组件化的好处？\" class=\"headerlink\" title=\"组件化的好处？\"></a>组件化的好处？</h3><p><strong>一般意义：</strong></p>\n<ul>\n<li>加快编译速度（不用编译主客那一大坨代码了）；</li>\n<li>各组件自由选择开发姿势（MVC / MVVM / FRP）；</li>\n<li>组件工程本身可以独立开发测试，方便 QA 有针对性地测试；</li>\n<li>规范组件之间的通信接，让各个组件对外都提供一个黑盒服务，减少沟通和维护成本，提高效率；</li>\n</ul>\n<p><strong>对于公司已有项目的现实意义：</strong></p>\n<ul>\n<li>业务分层、解耦，使代码变得可维护；</li>\n<li>有效的拆分、组织日益庞大的工程代码，使工程目录变得可维护；</li>\n<li>便于各业务功能拆分、抽离，实现真正的功能复用；</li>\n<li>业务隔离，跨团队开发代码控制和版本风险控制的实现；</li>\n<li>模块化对代码的封装性、合理性都有一定的要求，提升开发同学的设计能力；</li>\n<li>在维护好各级组件的情况下，随意组合满足不同客户需求；（只需要将之前的多个业务组件模块在新的主App中进行组装即可快速迭代出下一个全新App）</li>\n</ul>\n<h3 id=\"什么情况下进行组件化比较合适？\"><a href=\"#什么情况下进行组件化比较合适？\" class=\"headerlink\" title=\"什么情况下进行组件化比较合适？\"></a>什么情况下进行组件化比较合适？</h3><p>当然组件化也有它的缺点：</p>\n<ul>\n<li><p>学习成本高，对于开发人员对各种工具的掌握要求也比较高，对于新手来说入门较为困难。</p>\n</li>\n<li><p>由于工具和流程的复杂化，导致团队之间协作的成本变高，某些情况下可能会导致开发效率下降。</p>\n</li>\n</ul>\n<p>当项目App处于起步阶段、各个需求模块趋于成熟稳定的过程中，组件化也许并没有那么迫切，甚至考虑组件化的架构可能会影响开发效率和需求迭代。</p>\n<p>而当项目迭代到一定时期之后，便会出现一些相对独立的业务功能模块，而团队的规模也会随着项目迭代逐渐增长，这便是中小型应用考虑组件化的时机了。这时为了更好的分工协作，团队安排团队成员各自维护一个相对独立的业务组件是比较常见的做法。</p>\n<p>在这时这个时候来引入组件化方案，是比较合适的时机。长远来看，组件化带来的好处是远远大于坏处的，特别是随着项目的规模增大，这种好处会变得越来越明显</p>\n<h2 id=\"三、如何组件化？\"><a href=\"#三、如何组件化？\" class=\"headerlink\" title=\"三、如何组件化？\"></a>三、如何组件化？</h2><blockquote>\n<p>组件化的开展需要解决以下几个层次的问题：</p>\n</blockquote>\n<h3 id=\"组件化的架构目标？\"><a href=\"#组件化的架构目标？\" class=\"headerlink\" title=\"组件化的架构目标？\"></a>组件化的架构目标？</h3><p>借用Limboy的图：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/332029-4c7b8e152db83b9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"组件化架构.png\"></p>\n<h3 id=\"如何划分组件？\"><a href=\"#如何划分组件？\" class=\"headerlink\" title=\"如何划分组件？\"></a>如何划分组件？</h3><ul>\n<li>基础功能组件</li>\n<li>基础产品组件</li>\n<li>个性化业务组件</li>\n</ul>\n<p>对于一个没有实施过组件化拆分的工程来说，其中很可能充满了大量不合理的类、方法、头文件和各种错乱的依赖关系，因此首先要进行的第一步是模块拆分。</p>\n<p>模块拆分可以分成两个部分，基础模块拆分和业务模块拆分。基础模块通常是稳定的依赖代码，业务模块是涉及到业务的需要频繁改动的代码。</p>\n<blockquote>\n<p>基础模块拆分</p>\n</blockquote>\n<p>基础模块是任何一个App都需要用到的，如：性能统计、Networking、Patch、网络诊断、数据存储模块。对于基础模块来说，其本身应该是自洽的，即可以单独编译或者几个模块合在一起可以单独编译。所有的依赖关系都应该是业务模块指向基础模块的。<br>基础模块之间尽量避免产生横向依赖。</p>\n<blockquote>\n<p>业务模块拆分</p>\n</blockquote>\n<p>对于业务模块来说，考虑到旧有代码可能没有相关的横向解耦策略，业务模块之间的依赖会非常复杂，难以单独进行拆分，因此我们采用的方法是首先从 group 角度进行重新整理。</p>\n<p>对业务量很大的工程来说，我个人更加推荐“业务-分层”这样的结构，而不是“分层-业务”，即类似下面的 group 结构：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">- BusinessA</div><div class=\"line\">  - Model</div><div class=\"line\">  - View</div><div class=\"line\">  - Controller</div><div class=\"line\">  - Store</div><div class=\"line\">- BusinessB</div><div class=\"line\">  - Model</div><div class=\"line\">  - View</div><div class=\"line\">  - Controller</div><div class=\"line\">  -Store</div></pre></td></tr></table></figure>\n<p>而非目前项目中采用的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">- Controllers</div><div class=\"line\">  - BusinessA_Controller</div><div class=\"line\">  - BusinessB_Controller</div><div class=\"line\">- Views</div><div class=\"line\">  - BusinessA_View</div><div class=\"line\">  - BusinessB_View</div><div class=\"line\">- Models</div><div class=\"line\">  - BusinessA_Model</div><div class=\"line\">  - BusinessB_Model</div></pre></td></tr></table></figure>\n<h3 id=\"组件化的技术难点？\"><a href=\"#组件化的技术难点？\" class=\"headerlink\" title=\"组件化的技术难点？\"></a>组件化的技术难点？</h3><blockquote>\n<p>组件化的实施，直观上看，只是需要将各业务组件的代码放到各自的文件夹或者 jar包里就行了。</p>\n</blockquote>\n<p>这里引出的是：</p>\n<h4 id=\"1、组件的拆分方式问题：\"><a href=\"#1、组件的拆分方式问题：\" class=\"headerlink\" title=\"1、组件的拆分方式问题：\"></a>1、组件的拆分方式问题：</h4><p>可以利用CocoaPods 配合 git 做代码版本管理，独立业务模块单独成库。</p>\n<p>但这仅仅是物理上拆分了，拆分后的代码编译是肯定通不过的，因为如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">#import &quot;MainViewController.h&quot;</div><div class=\"line\">#import &quot;HomeViewController.h&quot;</div><div class=\"line\">#import &quot;NewsViewController.h&quot;</div><div class=\"line\">#import &quot;MeViewController.h&quot;</div><div class=\"line\">#import ...</div><div class=\"line\"></div><div class=\"line\">@implementation MainViewController</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p><code>MainViewController</code> 会找不到依赖的其它各个模块的头文件而报错。这里引出的又是另一个问题：</p>\n<h4 id=\"2、组件间如何解耦？\"><a href=\"#2、组件间如何解耦？\" class=\"headerlink\" title=\"2、组件间如何解耦？\"></a>2、组件间如何解耦？</h4><p>组件间解耦，是组件化必须解决的一个问题。换句话说，就是如何解除业务模块间的横向依赖。还是拿上边举得例子来说：</p>\n<p>App的根视图<code>MainViewController</code>需要管理首页、新闻、我的等等页面时，如何做到 <code>MainViewController</code> 中，不用去 <code>import</code>这一大堆 <code>XXViewController</code> ?</p>\n<p>很简单，按软件工程的思路，下意识就会加一个中间层Mediator：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/332029-bd66e6dac09f2e08.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"中间层.png\"></p>\n<p>这样一来，各个模块直接都不需要再互相依赖，而是仅需要依赖 Mediator 层即可。</p>\n<p>可直观上看，这样做并没有什么好处，依赖关系并没有解除，Mediator 依赖了所有模块，而调用者又依赖 Mediator，最后还是一坨互相依赖，跟原来没有 Mediator 的方案相比除了更麻烦点其他没区别。</p>\n<p>我们希望最终能过实现的是单向的依赖，即：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/332029-4bbac402d8344090.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"单向依赖.png\"></p>\n<p>对此，可以参考业内的流行方案：</p>\n<ul>\n<li><p>基于 URL Router、ModuleManager<br>  代表：<a href=\"http://limboy.me/ios/2016/03/10/mgj-components.html\" target=\"_blank\" rel=\"external\">蘑菇街 Limboy</a></p>\n</li>\n<li><p>基于 Target-Action、Runtime、Category<br>  代表：<a href=\"http://casatwy.com/iOS-Modulization.html?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io\" target=\"_blank\" rel=\"external\">安居客 casa</a></p>\n</li>\n</ul>\n<p>具体实现方案较为抽象，这里暂时先不详细展开论述，可以参见Demo：</p>\n<p><a href=\"https://github.com/yehot/CTMediator\" target=\"_blank\" rel=\"external\">Demo1 基于 Target-Action</a></p>\n<p><a href=\"https://github.com/yehot/routable-ios\" target=\"_blank\" rel=\"external\">Demo2 基于 URL Router</a></p>\n<h2 id=\"四、其它\"><a href=\"#四、其它\" class=\"headerlink\" title=\"四、其它\"></a>四、其它</h2><h3 id=\"开发流程控制\"><a href=\"#开发流程控制\" class=\"headerlink\" title=\"开发流程控制\"></a>开发流程控制</h3><blockquote>\n<p>托管平台选择</p>\n</blockquote>\n<p>自己利用开源的方案搭建私有的托管平台，可以最大限制地保证代码的安全。开源方案当中最知名也是最为广泛使用的当属 Gitlab。</p>\n<p>组件化使我们从单一的主工程，变成了主工程+多个拆分好的基础模块+统一的私有 Spec 仓库。为了避免某个人的工作对其他人开发环境造成影响，需要对整个组的开发流程进行统一的规范。</p>\n<p>不管是对于主仓库和子模块仓库，git-flow 都是首先推荐的工作流程。一个仓库的 master 分支只有所有者可以有权限更改，其他的贡献者想更改的话，需要自己创建新的分支（在 Github 上就是进行 fork），然后进行更改，之后把更改向原仓库发送 Pull Request。Pull Request 就是一个合并的请求，其中可以看到贡献者的更改，项目主人和其他维护者可以对 Pull Request 进行审核，共同探讨修改意见。当项目主人认为修改 OK 之后，就可以合并这个 Pull Request ，把这部分代码合并到主分支。</p>\n<p>这个流程是完全分布式的，也就是说可以同时有多个贡献者在不同的分支进行工作，最后统一合并到主分支上，实现并行协作。</p>\n<p>同时在审核 Pull Request 阶段，除了人工审核代码之外，Github 还加入了对于持续集成的支持，可以检测这个 Pull Request 是不是能够通过测试的，进一步保证了代码的质量。</p>\n<h3 id=\"组件维护问题？\"><a href=\"#组件维护问题？\" class=\"headerlink\" title=\"组件维护问题？\"></a>组件维护问题？</h3><p>待补充</p>\n<h2 id=\"五、参考资料：\"><a href=\"#五、参考资料：\" class=\"headerlink\" title=\"五、参考资料：\"></a>五、参考资料：</h2><h3 id=\"相关技术博客：\"><a href=\"#相关技术博客：\" class=\"headerlink\" title=\"相关技术博客：\"></a>相关技术博客：</h3><p>1、<a href=\"http://casatwy.com/iOS-Modulization.html?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io\" target=\"_blank\" rel=\"external\">iOS应用架构谈 组件化方案</a></p>\n<p>2、<a href=\"http://limboy.me/ios/2016/03/10/mgj-components.html\" target=\"_blank\" rel=\"external\">蘑菇街 App 的组件化之路</a></p>\n<p><a href=\"http://limboy.me/ios/2016/03/14/mgj-components-continued.html\" target=\"_blank\" rel=\"external\">蘑菇街 App 的组件化之路·续</a></p>\n<p>3、<a href=\"http://blog.cnbang.net/tech/3080/\" target=\"_blank\" rel=\"external\">iOS 组件化方案探索</a></p>\n<p>4、<a href=\"http://www.reviewcode.cn/article.html?reviewId=20\" target=\"_blank\" rel=\"external\">《iOS应用架构谈 组件化方案》和《蘑菇街 App 的组件化之路》的阅读指导</a></p>\n<p>5、<a href=\"https://skyline75489.github.io/post/2016-3-16_ios_module_design.html\" target=\"_blank\" rel=\"external\">浅析 iOS 应用组件化设计</a></p>\n<p>6、<a href=\"http://chuansong.me/n/320688951236\" target=\"_blank\" rel=\"external\">糯米移动组件架构演进之路</a></p>\n<p>7、<a href=\"https://www.sdk.cn/news/2023\" target=\"_blank\" rel=\"external\">饿了么移动APP的架构演进</a></p>\n<p>8、<a href=\"https://mp.weixin.qq.com/s?__biz=MzA3ODg4MDk0Ng%3D%3D&amp;idx=1&amp;mid=402854111&amp;sn=5876e615fabd6d921285d904e16670fb\" target=\"_blank\" rel=\"external\">滴滴出行iOS客户端架构演进之路</a></p>\n<p>9、<a href=\"http://www.aliog.com/101363.html\" target=\"_blank\" rel=\"external\">ios业务模块间互相跳转的解耦方案</a></p>\n<p>10、<a href=\"http://cdn0.jianshu.io/p/afb9b52143d4\" target=\"_blank\" rel=\"external\">iOS组件化思路－大神博客研读和思考</a></p>\n<p>11、<a href=\"https://blog.cnbluebox.com/blog/2015/11/28/module-and-decoupling/\" target=\"_blank\" rel=\"external\">模块化与解耦</a></p>\n<h3 id=\"相关解决方案\"><a href=\"#相关解决方案\" class=\"headerlink\" title=\"相关解决方案\"></a>相关解决方案</h3><p>1、<a href=\"https://github.com/casatwy/CTMediator\" target=\"_blank\" rel=\"external\">casatwy/CTMediator</a></p>\n<p>2、<a href=\"https://github.com/mogujie/MGJRouter\" target=\"_blank\" rel=\"external\">mogujie/MGJRouter</a></p>\n<p>3、<a href=\"https://github.com/joeldev/JLRoutes\" target=\"_blank\" rel=\"external\">joeldev/JLRoutes</a></p>\n<p>4、<a href=\"https://github.com/Huohua/HHRouter\" target=\"_blank\" rel=\"external\">Huohua/HHRouter</a></p>\n<p>5、<a href=\"https://github.com/clayallsopp/routable-ios\" target=\"_blank\" rel=\"external\">clayallsopp/routable-ios</a></p>\n<p>6、<a href=\"https://github.com/Lede-Inc/LDBusBundle_IOS\" target=\"_blank\" rel=\"external\">Lede-Inc/LDBusBundle_IOS</a></p>\n<h3 id=\"私有Cocoapods实施方案\"><a href=\"#私有Cocoapods实施方案\" class=\"headerlink\" title=\"私有Cocoapods实施方案\"></a>私有Cocoapods实施方案</h3><p>1、<a href=\"http://blog.wtlucky.com/blog/2015/02/26/create-private-podspec/\" target=\"_blank\" rel=\"external\">使用Cocoapods创建私有podspec - GeekerProbe</a></p>\n<p>2、<a href=\"http://www.pluto-y.com/cocoapod-private-pods-and-module-manager/\" target=\"_blank\" rel=\"external\">Cocoapods系列教程(三)——私有库管理和模块化管理</a></p>\n<p>3、<a href=\"http://www.jianshu.com/p/196f66d31543\" target=\"_blank\" rel=\"external\">iOS组件化实践方案－LDBusMediator炼就</a></p>\n<p>4、<a href=\"https://skyline75489.github.io/post/2016-3-19_ios_modularization_practice.html\" target=\"_blank\" rel=\"external\">基于 CocoaPods 和 Git 的 iOS 工程组件化实践</a></p>\n<p>5、<a href=\"https://blog.cnbluebox.com/blog/2014/03/31/cocoapodsdai-ma-guan-li/\" target=\"_blank\" rel=\"external\">Cocoapods代码管理</a></p>\n<p>6、<a href=\"http://www.liuchungui.com/blog/2015/10/19/cocoapodschuang-jian-si-you-pods/\" target=\"_blank\" rel=\"external\">CocoaPods创建私有Pods</a></p>\n<p>7、<a href=\"http://www.jianshu.com/p/ddc2490bff9f\" target=\"_blank\" rel=\"external\">如何创建私有 CocoaPods 仓库</a></p>\n","excerpt":"","more":"<h1 id=\"iOS组件化方案探索\"><a href=\"#iOS组件化方案探索\" class=\"headerlink\" title=\"iOS组件化方案探索\"></a>iOS组件化方案探索</h1><h2 id=\"一、什么是组件化？\"><a href=\"#一、什么是组件化？\" class=\"headerlink\" title=\"一、什么是组件化？\"></a>一、什么是组件化？</h2><h3 id=\"什么是组件？\"><a href=\"#什么是组件？\" class=\"headerlink\" title=\"什么是组件？\"></a>什么是组件？</h3><p><code>&quot;组件&quot;</code>一般来说用于命名比较小的功能块，如：下拉刷新组件、提示框组件。而较大粒度的业务功能，我们习惯称之为<code>&quot;模块&quot;</code>，如：首页模块、我的模块、新闻模块。</p>\n<p>这次讨论的主题是组件化，这里为了方便表述，下面模块和组件代表同一个意思，都是指较大粒度的业务模块。</p>\n<h3 id=\"什么是组件化？\"><a href=\"#什么是组件化？\" class=\"headerlink\" title=\"什么是组件化？\"></a>什么是组件化？</h3><p>组件化，或者说模块化，用来分割、组织和打包软件。每个模块完成一个特定的子功能，所有的模块按某种方法组装起来，成为一个整体，完成整个系统所要求的功能。</p>\n<p>从工程代码层面来说，组件化的实施通常是通过<code>中间件</code>解决组件间头文件直接引用、依赖混乱的问题；从实际开发来说，组件之间最大的需求就是页面跳转，需要从组件A的pageA页面跳转到组件B的pageB页面，避免对组件B页面ViewController头文件的直接依赖。</p>\n<h2 id=\"二、为什么要组件化？\"><a href=\"#二、为什么要组件化？\" class=\"headerlink\" title=\"二、为什么要组件化？\"></a>二、为什么要组件化？</h2><p>从两个方面论述：</p>\n<h3 id=\"组件化是为了解决什么问题？\"><a href=\"#组件化是为了解决什么问题？\" class=\"headerlink\" title=\"组件化是为了解决什么问题？\"></a>组件化是为了解决什么问题？</h3><p>一个 APP 有多个模块，模块之间会通信，互相调用，如我们的证券app，有首页、行情、资讯、我的等模块。这些模块会互相调用，例如 首页底部需要展示部分资讯、行情；行情底部需要展示个股资讯；资讯详情页需要跳转到行情，等等。</p>\n<p>一般我们是怎样调用呢，以首页调用资讯为例，会这样写：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &quot;HomeViewController.h&quot;</div><div class=\"line\">#import &quot;NewsViewController.h&quot;</div><div class=\"line\"></div><div class=\"line\">@implementation HomeViewController</div><div class=\"line\"></div><div class=\"line\">+ (void)gotoNews &#123;</div><div class=\"line\"></div><div class=\"line\"> NewsViewController *detailVC = [[NewsViewController alloc] initWithStockCode:self.codeNum];</div><div class=\"line\"> [self.navigationController.pushViewController:detailVC animated:YES];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>看起来挺好，这样做简单明了，没有多余的东西，项目初期推荐这样快速开发，但到了项目越来越庞大，这种方式会有什么问题呢？</p>\n<ul>\n<li>问题1，每个模块都离不开其他模块，互相依赖粘在一起成为一坨：</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/332029-f03757f38936ed16.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"各模块互相依赖.png\"></p>\n<p>耦合比较严重（因为没有明确的约束，「组件」间引用的现象会比较多）</p>\n<ul>\n<li>问题2，多人同时开发时，容易出现冲突（尤其是Xcode Project文件）</li>\n<li>问题3，业务方的开发效率不够高（只关心自己的组件，却要编译整个项目，与其他不相干的代码糅合在一起）</li>\n</ul>\n<h3 id=\"组件化的好处？\"><a href=\"#组件化的好处？\" class=\"headerlink\" title=\"组件化的好处？\"></a>组件化的好处？</h3><p><strong>一般意义：</strong></p>\n<ul>\n<li>加快编译速度（不用编译主客那一大坨代码了）；</li>\n<li>各组件自由选择开发姿势（MVC / MVVM / FRP）；</li>\n<li>组件工程本身可以独立开发测试，方便 QA 有针对性地测试；</li>\n<li>规范组件之间的通信接，让各个组件对外都提供一个黑盒服务，减少沟通和维护成本，提高效率；</li>\n</ul>\n<p><strong>对于公司已有项目的现实意义：</strong></p>\n<ul>\n<li>业务分层、解耦，使代码变得可维护；</li>\n<li>有效的拆分、组织日益庞大的工程代码，使工程目录变得可维护；</li>\n<li>便于各业务功能拆分、抽离，实现真正的功能复用；</li>\n<li>业务隔离，跨团队开发代码控制和版本风险控制的实现；</li>\n<li>模块化对代码的封装性、合理性都有一定的要求，提升开发同学的设计能力；</li>\n<li>在维护好各级组件的情况下，随意组合满足不同客户需求；（只需要将之前的多个业务组件模块在新的主App中进行组装即可快速迭代出下一个全新App）</li>\n</ul>\n<h3 id=\"什么情况下进行组件化比较合适？\"><a href=\"#什么情况下进行组件化比较合适？\" class=\"headerlink\" title=\"什么情况下进行组件化比较合适？\"></a>什么情况下进行组件化比较合适？</h3><p>当然组件化也有它的缺点：</p>\n<ul>\n<li><p>学习成本高，对于开发人员对各种工具的掌握要求也比较高，对于新手来说入门较为困难。</p>\n</li>\n<li><p>由于工具和流程的复杂化，导致团队之间协作的成本变高，某些情况下可能会导致开发效率下降。</p>\n</li>\n</ul>\n<p>当项目App处于起步阶段、各个需求模块趋于成熟稳定的过程中，组件化也许并没有那么迫切，甚至考虑组件化的架构可能会影响开发效率和需求迭代。</p>\n<p>而当项目迭代到一定时期之后，便会出现一些相对独立的业务功能模块，而团队的规模也会随着项目迭代逐渐增长，这便是中小型应用考虑组件化的时机了。这时为了更好的分工协作，团队安排团队成员各自维护一个相对独立的业务组件是比较常见的做法。</p>\n<p>在这时这个时候来引入组件化方案，是比较合适的时机。长远来看，组件化带来的好处是远远大于坏处的，特别是随着项目的规模增大，这种好处会变得越来越明显</p>\n<h2 id=\"三、如何组件化？\"><a href=\"#三、如何组件化？\" class=\"headerlink\" title=\"三、如何组件化？\"></a>三、如何组件化？</h2><blockquote>\n<p>组件化的开展需要解决以下几个层次的问题：</p>\n</blockquote>\n<h3 id=\"组件化的架构目标？\"><a href=\"#组件化的架构目标？\" class=\"headerlink\" title=\"组件化的架构目标？\"></a>组件化的架构目标？</h3><p>借用Limboy的图：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/332029-4c7b8e152db83b9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"组件化架构.png\"></p>\n<h3 id=\"如何划分组件？\"><a href=\"#如何划分组件？\" class=\"headerlink\" title=\"如何划分组件？\"></a>如何划分组件？</h3><ul>\n<li>基础功能组件</li>\n<li>基础产品组件</li>\n<li>个性化业务组件</li>\n</ul>\n<p>对于一个没有实施过组件化拆分的工程来说，其中很可能充满了大量不合理的类、方法、头文件和各种错乱的依赖关系，因此首先要进行的第一步是模块拆分。</p>\n<p>模块拆分可以分成两个部分，基础模块拆分和业务模块拆分。基础模块通常是稳定的依赖代码，业务模块是涉及到业务的需要频繁改动的代码。</p>\n<blockquote>\n<p>基础模块拆分</p>\n</blockquote>\n<p>基础模块是任何一个App都需要用到的，如：性能统计、Networking、Patch、网络诊断、数据存储模块。对于基础模块来说，其本身应该是自洽的，即可以单独编译或者几个模块合在一起可以单独编译。所有的依赖关系都应该是业务模块指向基础模块的。<br>基础模块之间尽量避免产生横向依赖。</p>\n<blockquote>\n<p>业务模块拆分</p>\n</blockquote>\n<p>对于业务模块来说，考虑到旧有代码可能没有相关的横向解耦策略，业务模块之间的依赖会非常复杂，难以单独进行拆分，因此我们采用的方法是首先从 group 角度进行重新整理。</p>\n<p>对业务量很大的工程来说，我个人更加推荐“业务-分层”这样的结构，而不是“分层-业务”，即类似下面的 group 结构：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">- BusinessA</div><div class=\"line\">  - Model</div><div class=\"line\">  - View</div><div class=\"line\">  - Controller</div><div class=\"line\">  - Store</div><div class=\"line\">- BusinessB</div><div class=\"line\">  - Model</div><div class=\"line\">  - View</div><div class=\"line\">  - Controller</div><div class=\"line\">  -Store</div></pre></td></tr></table></figure>\n<p>而非目前项目中采用的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">- Controllers</div><div class=\"line\">  - BusinessA_Controller</div><div class=\"line\">  - BusinessB_Controller</div><div class=\"line\">- Views</div><div class=\"line\">  - BusinessA_View</div><div class=\"line\">  - BusinessB_View</div><div class=\"line\">- Models</div><div class=\"line\">  - BusinessA_Model</div><div class=\"line\">  - BusinessB_Model</div></pre></td></tr></table></figure>\n<h3 id=\"组件化的技术难点？\"><a href=\"#组件化的技术难点？\" class=\"headerlink\" title=\"组件化的技术难点？\"></a>组件化的技术难点？</h3><blockquote>\n<p>组件化的实施，直观上看，只是需要将各业务组件的代码放到各自的文件夹或者 jar包里就行了。</p>\n</blockquote>\n<p>这里引出的是：</p>\n<h4 id=\"1、组件的拆分方式问题：\"><a href=\"#1、组件的拆分方式问题：\" class=\"headerlink\" title=\"1、组件的拆分方式问题：\"></a>1、组件的拆分方式问题：</h4><p>可以利用CocoaPods 配合 git 做代码版本管理，独立业务模块单独成库。</p>\n<p>但这仅仅是物理上拆分了，拆分后的代码编译是肯定通不过的，因为如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">#import &quot;MainViewController.h&quot;</div><div class=\"line\">#import &quot;HomeViewController.h&quot;</div><div class=\"line\">#import &quot;NewsViewController.h&quot;</div><div class=\"line\">#import &quot;MeViewController.h&quot;</div><div class=\"line\">#import ...</div><div class=\"line\"></div><div class=\"line\">@implementation MainViewController</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p><code>MainViewController</code> 会找不到依赖的其它各个模块的头文件而报错。这里引出的又是另一个问题：</p>\n<h4 id=\"2、组件间如何解耦？\"><a href=\"#2、组件间如何解耦？\" class=\"headerlink\" title=\"2、组件间如何解耦？\"></a>2、组件间如何解耦？</h4><p>组件间解耦，是组件化必须解决的一个问题。换句话说，就是如何解除业务模块间的横向依赖。还是拿上边举得例子来说：</p>\n<p>App的根视图<code>MainViewController</code>需要管理首页、新闻、我的等等页面时，如何做到 <code>MainViewController</code> 中，不用去 <code>import</code>这一大堆 <code>XXViewController</code> ?</p>\n<p>很简单，按软件工程的思路，下意识就会加一个中间层Mediator：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/332029-bd66e6dac09f2e08.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"中间层.png\"></p>\n<p>这样一来，各个模块直接都不需要再互相依赖，而是仅需要依赖 Mediator 层即可。</p>\n<p>可直观上看，这样做并没有什么好处，依赖关系并没有解除，Mediator 依赖了所有模块，而调用者又依赖 Mediator，最后还是一坨互相依赖，跟原来没有 Mediator 的方案相比除了更麻烦点其他没区别。</p>\n<p>我们希望最终能过实现的是单向的依赖，即：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/332029-4bbac402d8344090.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"单向依赖.png\"></p>\n<p>对此，可以参考业内的流行方案：</p>\n<ul>\n<li><p>基于 URL Router、ModuleManager<br>  代表：<a href=\"http://limboy.me/ios/2016/03/10/mgj-components.html\">蘑菇街 Limboy</a></p>\n</li>\n<li><p>基于 Target-Action、Runtime、Category<br>  代表：<a href=\"http://casatwy.com/iOS-Modulization.html?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io\">安居客 casa</a></p>\n</li>\n</ul>\n<p>具体实现方案较为抽象，这里暂时先不详细展开论述，可以参见Demo：</p>\n<p><a href=\"https://github.com/yehot/CTMediator\">Demo1 基于 Target-Action</a></p>\n<p><a href=\"https://github.com/yehot/routable-ios\">Demo2 基于 URL Router</a></p>\n<h2 id=\"四、其它\"><a href=\"#四、其它\" class=\"headerlink\" title=\"四、其它\"></a>四、其它</h2><h3 id=\"开发流程控制\"><a href=\"#开发流程控制\" class=\"headerlink\" title=\"开发流程控制\"></a>开发流程控制</h3><blockquote>\n<p>托管平台选择</p>\n</blockquote>\n<p>自己利用开源的方案搭建私有的托管平台，可以最大限制地保证代码的安全。开源方案当中最知名也是最为广泛使用的当属 Gitlab。</p>\n<p>组件化使我们从单一的主工程，变成了主工程+多个拆分好的基础模块+统一的私有 Spec 仓库。为了避免某个人的工作对其他人开发环境造成影响，需要对整个组的开发流程进行统一的规范。</p>\n<p>不管是对于主仓库和子模块仓库，git-flow 都是首先推荐的工作流程。一个仓库的 master 分支只有所有者可以有权限更改，其他的贡献者想更改的话，需要自己创建新的分支（在 Github 上就是进行 fork），然后进行更改，之后把更改向原仓库发送 Pull Request。Pull Request 就是一个合并的请求，其中可以看到贡献者的更改，项目主人和其他维护者可以对 Pull Request 进行审核，共同探讨修改意见。当项目主人认为修改 OK 之后，就可以合并这个 Pull Request ，把这部分代码合并到主分支。</p>\n<p>这个流程是完全分布式的，也就是说可以同时有多个贡献者在不同的分支进行工作，最后统一合并到主分支上，实现并行协作。</p>\n<p>同时在审核 Pull Request 阶段，除了人工审核代码之外，Github 还加入了对于持续集成的支持，可以检测这个 Pull Request 是不是能够通过测试的，进一步保证了代码的质量。</p>\n<h3 id=\"组件维护问题？\"><a href=\"#组件维护问题？\" class=\"headerlink\" title=\"组件维护问题？\"></a>组件维护问题？</h3><p>待补充</p>\n<h2 id=\"五、参考资料：\"><a href=\"#五、参考资料：\" class=\"headerlink\" title=\"五、参考资料：\"></a>五、参考资料：</h2><h3 id=\"相关技术博客：\"><a href=\"#相关技术博客：\" class=\"headerlink\" title=\"相关技术博客：\"></a>相关技术博客：</h3><p>1、<a href=\"http://casatwy.com/iOS-Modulization.html?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io\">iOS应用架构谈 组件化方案</a></p>\n<p>2、<a href=\"http://limboy.me/ios/2016/03/10/mgj-components.html\">蘑菇街 App 的组件化之路</a></p>\n<p><a href=\"http://limboy.me/ios/2016/03/14/mgj-components-continued.html\">蘑菇街 App 的组件化之路·续</a></p>\n<p>3、<a href=\"http://blog.cnbang.net/tech/3080/\">iOS 组件化方案探索</a></p>\n<p>4、<a href=\"http://www.reviewcode.cn/article.html?reviewId=20\">《iOS应用架构谈 组件化方案》和《蘑菇街 App 的组件化之路》的阅读指导</a></p>\n<p>5、<a href=\"https://skyline75489.github.io/post/2016-3-16_ios_module_design.html\">浅析 iOS 应用组件化设计</a></p>\n<p>6、<a href=\"http://chuansong.me/n/320688951236\">糯米移动组件架构演进之路</a></p>\n<p>7、<a href=\"https://www.sdk.cn/news/2023\">饿了么移动APP的架构演进</a></p>\n<p>8、<a href=\"https://mp.weixin.qq.com/s?__biz=MzA3ODg4MDk0Ng%3D%3D&amp;idx=1&amp;mid=402854111&amp;sn=5876e615fabd6d921285d904e16670fb\">滴滴出行iOS客户端架构演进之路</a></p>\n<p>9、<a href=\"http://www.aliog.com/101363.html\">ios业务模块间互相跳转的解耦方案</a></p>\n<p>10、<a href=\"http://cdn0.jianshu.io/p/afb9b52143d4\">iOS组件化思路－大神博客研读和思考</a></p>\n<p>11、<a href=\"https://blog.cnbluebox.com/blog/2015/11/28/module-and-decoupling/\">模块化与解耦</a></p>\n<h3 id=\"相关解决方案\"><a href=\"#相关解决方案\" class=\"headerlink\" title=\"相关解决方案\"></a>相关解决方案</h3><p>1、<a href=\"https://github.com/casatwy/CTMediator\">casatwy/CTMediator</a></p>\n<p>2、<a href=\"https://github.com/mogujie/MGJRouter\">mogujie/MGJRouter</a></p>\n<p>3、<a href=\"https://github.com/joeldev/JLRoutes\">joeldev/JLRoutes</a></p>\n<p>4、<a href=\"https://github.com/Huohua/HHRouter\">Huohua/HHRouter</a></p>\n<p>5、<a href=\"https://github.com/clayallsopp/routable-ios\">clayallsopp/routable-ios</a></p>\n<p>6、<a href=\"https://github.com/Lede-Inc/LDBusBundle_IOS\">Lede-Inc/LDBusBundle_IOS</a></p>\n<h3 id=\"私有Cocoapods实施方案\"><a href=\"#私有Cocoapods实施方案\" class=\"headerlink\" title=\"私有Cocoapods实施方案\"></a>私有Cocoapods实施方案</h3><p>1、<a href=\"http://blog.wtlucky.com/blog/2015/02/26/create-private-podspec/\">使用Cocoapods创建私有podspec - GeekerProbe</a></p>\n<p>2、<a href=\"http://www.pluto-y.com/cocoapod-private-pods-and-module-manager/\">Cocoapods系列教程(三)——私有库管理和模块化管理</a></p>\n<p>3、<a href=\"http://www.jianshu.com/p/196f66d31543\">iOS组件化实践方案－LDBusMediator炼就</a></p>\n<p>4、<a href=\"https://skyline75489.github.io/post/2016-3-19_ios_modularization_practice.html\">基于 CocoaPods 和 Git 的 iOS 工程组件化实践</a></p>\n<p>5、<a href=\"https://blog.cnbluebox.com/blog/2014/03/31/cocoapodsdai-ma-guan-li/\">Cocoapods代码管理</a></p>\n<p>6、<a href=\"http://www.liuchungui.com/blog/2015/10/19/cocoapodschuang-jian-si-you-pods/\">CocoaPods创建私有Pods</a></p>\n<p>7、<a href=\"http://www.jianshu.com/p/ddc2490bff9f\">如何创建私有 CocoaPods 仓库</a></p>\n"},{"title":"runtime入门系列之——方法替换","date":"2016-07-02T10:58:37.000Z","_content":"\n作为一个有2年以上 iOS 开发经验的程序猿，如果说自己不知道 runtime 简直不好意思跟别人打招呼了。\n\n但是大部分初级 iOS 程序猿在实际项目开发中，很少有机会需要主动用到 runtime 相关的东西。最近面试的不少同学，当我问\"请说说你对 iOS 中 runtime 的理解\"就懵逼了。\n\n其实作为小面试官，我也是很尴尬的。你简历上期望薪资都写 15k+ 了，那总不能指望面试一个小时，我都只跟你聊如何写界面吧？\n\n---\n\n我觉得当我问面试者：\n> \"什么是 runtime ?\"\n\n这个问题时，如果能在以下三个方面做个简单的阐述，我觉得就基本合格了。\n\n### 一、runtime 是什么？\n\n- 首先 OC 是 C 语言的超集，因为 runtime 这个库使得C语言有了面向对象的能力：\nOC 对象可以用C语言中的结构体表示，而方法可以用C函数来实现，这些结构体和函数被 runtime 函数封装后，我们就可以在程序运行时创建，检查，修改类、对象和它们的方法了。\n\n- OC 是一门动态语言，它将很多静态语言在编译和链接时期做的事放到了运行时来处理。\n这种特性意味着Objective-C不仅需要一个编译器，还需要一个运行时系统来执行编译的代码。这个运行时系统即Objc Runtime。Objc Runtime基本上是用C和汇编写的。\n[参考 南峰子： Objective-C Runtime 运行时之一：类与对象](http://southpeak.github.io/blog/2014/10/25/objective-c-runtime-yun-xing-shi-zhi-lei-yu-dui-xiang/)\n\n### 二、runtime 有什么用？\n- 我们写的代码在程序运行过程中都会被转化成 runtime 的C代码执行\nOC的类、对象、方法在运行时，最终都转换成 C语言的 结构体、函数来执行。\n     可以在程序运行时创建，检查，修改类、对象和它们的方法。\n\n- 常用于：\n      - 获取类的方法列表/参数列表；\n      - 方法调用；\n      - 方法拦截、动态添加方法；\n      - 方法替换： method swizzling\n      - 关联对象，动态添加属性；\n\n### 三、runtime 怎么用？\n\n> 或者，说说你具体在项目中哪些地方用到过 runtime ？\n\n- runtime 的 API 提供了大量的函数来操作类和对象，如：\n    - 动态替换方法的实现、方法拦截：`class_replaceMethod`\n    - 获取对象的属性列表：`class_copyIvarList`\n    - 获取对象的方法列表： `class_copyMethodList`\n    - 动态添加属性: `class_addProperty`\n    - 动态添加方法： `class_addMethod`\n    - 获取方法名： `method_getName`\n    - 获取方法的实现： `class_getMethodImplementation`\n\n- 具体应用：\n    - 给 category 添加属性： \n        `给 UIAlertView 加 block 回调`\n    - 给系统的方法做替换，插入代码： \n        `替换 viewDidLoad 方法的实现，NSLog 出每一个出现页面的类名`\n\n---\n\n## 「方法替换」demo:\n\n声明一个`People`类\n```\n@interface People : NSObject\n- (void)run;\n@end\n\n@implementation People\n- (void)run {\n    NSLog(@\"People run\");\n}\n@end\n```\n\n实现替换的方法\n\n```\n@implementation ViewController\n\n// demo 是在当前类直接定义了一个方法，也可以用代码动态生成一个方法\n- (void)runFast {\n    NSLog(@\"People run fast\");\n}\n\n/\n *  替换 People 类中 run 方法的实现\n */\n- (void)replacePeopleRunMethod {\n    \n    Class peopleClass = NSClassFromString(@\"People\");\n    SEL peopleRunSel = @selector(run);\n    Method methodRun = class_getInstanceMethod(peopleClass, peopleRunSel);\n    // 获取 run 方法的参数 （包括了 parameter and return types）\n    char *typeDescription = (char *)method_getTypeEncoding(methodRun);\n    \n    // 获取 runFast 方法的实现\n    IMP runFastImp = class_getMethodImplementation([self class], @selector(runFast));\n    \n    // 给 People 新增 runFast 方法，并指向的当前类中 runFast 的实现\n    class_addMethod(peopleClass, @selector(runFast), runFastImp, typeDescription);\n    \n    // 替换 run 方法为 runFast 方法\n    class_replaceMethod(peopleClass, peopleRunSel, runFastImp, typeDescription);\n}\n@end\n```\n\n调用\n\n```\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    People *p1 = [[People alloc] init];\n    [p1 run];\n    \n    [self replacePeopleRunMethod];\n    [p1 run];\n}\n```\n\n输出如下：\n```\n2016-07-02 18:11:26.707 RuntimeDemo[26972:1726702] People run\n2016-07-02 18:11:26.712 RuntimeDemo[26972:1726702] People run fast\n```\n> 注意，这里的方法替换是永久性的，只要程序不退出，以后无论在任何地方调用`[p1 run]`都只会调用`runFast`的实现。\n\n> 而且，method swizzling 方法并不适合写在这里，通常写在 `+ (void)load `方法中，并且用 `dispatch_once` 来进行调度。至于为什么，可以参考[Objective-C +load vs +initialize](http://blog.leichunfeng.com/blog/2015/05/02/objective-c-plus-load-vs-plus-initialize/)。\n\n相关注释：\n\n```\n    // Method : 包含了一个方法的  方法名 + 实现 + 参数个数及类型 + 返回值个数及类型 等信息\n    // class_getInstanceMethod : 通过类名 + 方法名 获取一个 Method\n    // class_getMethodImplementation: 类名 + 方法名\n    // class_addMethod: 类名 + 方法名 + 方法实现 + 参数信息\n    // class_replaceMethod : 类型 + 替换的方法名 + 替换后的实现 + 参数信息\n```\n\n以上 demo 只是简单的在当前类`ViewController`中，定义了一个`runFast`方法，并用其替换了`People` 类中`run`方法的实现。\n\n这里需要先用 `class_addMethod`，而不是直接用`class_replaceMethod`，是为了做一层保护，因为如果 `People` 类没有实现 `run` 方法 ，但其父类实现了，那 class_getInstanceMethod 会返回父类的方法。\n     这样 method_exchangeImplementations 替换的是父类的那个方法，这当然不是你想要的。\n     所以我们先尝试添加 `runFast`方法，如果已经存在，就用 `method_exchangeImplementations` 把原方法的实现跟新的方法实现给交换掉。否则用`class_replaceMethod`来替换。\n\n---\n\n### 「方法替换」常规写法\n\n上文 demo 中的写法，只是实现了方法替换的效果，但真正在项目中用的时候会存在一些问题，如调用时机、调用次数、替换失败等问题，所以，一般实战中写法如下：\n\n```\n#import \"UIViewController+Logging.h\"\n#import <objc/runtime.h>\n\n@implementation UIViewController (Logging)\n\n+ (void)load {\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        Class targetClass = [self class];\n        SEL originalSelector = @selector(viewDidAppear:);\n        SEL swizzledSelector = @selector(swizzled_viewDidAppear:);\n        swizzleMethod(targetClass, originalSelector, swizzledSelector);\n    });\n}\n\nvoid swizzleMethod(Class class, SEL originalSelector, SEL swizzledSelector) {\n    Method originalMethod = class_getInstanceMethod(class, originalSelector);\n    Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);\n    \n    IMP swizzledImp = method_getImplementation(swizzledMethod);\n    char *swizzledTypes = (char *)method_getTypeEncoding(swizzledMethod);\n    \n    IMP originalImp = method_getImplementation(originalMethod);\n    \n    char *originalTypes = (char *)method_getTypeEncoding(originalMethod);\n    BOOL success = class_addMethod(class, originalSelector, swizzledImp, swizzledTypes);\n    if (success) {\n        class_replaceMethod(class, swizzledSelector, originalImp, originalTypes);\n    }else {\n        // 添加失败，表明已经有这个方法，直接交换\n        method_exchangeImplementations(originalMethod, swizzledMethod);\n    }\n}\n\n- (void)swizzled_viewDidAppear:(BOOL)animation {\n    [self swizzled_viewDidAppear:animation];\n    NSLog(@\"%@ viewDidAppear\", NSStringFromClass([self class]));\n}\n\n@end\n```\n---\n\n### 扩展 —— 用 Aspects 实现方法替换\n\n上边 demo 中写了一大堆 runtime 的 api 在代码里，即不好阅读，也不便于维护。\n> 这里有现成的方案：一个基于 swizzling method 的开源框架 [Aspects](https://github.com/steipete/Aspects) 。\n\n用 `Aspects` 来实现上文 demo 如下：\n\n```\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    People *p1 = [[People alloc] init];\n    [p1 run];   \n      \n    [People aspect_hookSelector:@selector(run) withOptions:AspectPositionInstead usingBlock:^(id<AspectInfo> aspectInfo) {\n        NSLog(@\"People aspect run fast\");\n    } error:nil];\n\n    [p1 run];\n```\n\n输出：\n\n```\n2016-07-02 18:16:38.039 RuntimeDemo[26994:1730239] People run\n2016-07-02 18:16:38.043 RuntimeDemo[26994:1730239] People aspect run fast\n```\n\n需要注意的是 `Aspects` 的 `aspect_hookSelector:` 方法中，`AspectOptions`参数决定了方法替换的时机：\n\n```\ntypedef NS_OPTIONS(NSUInteger, AspectOptions) {\n    AspectPositionAfter   = 0,            /// 原方法调用后 (default)\n    AspectPositionInstead = 1,            /// 完全替换原方法\n    AspectPositionBefore  = 2,            /// 原方法调用前\n    AspectOptionAutomaticRemoval = 1 << 3 /// 在执行一次替换的方法后，就移除替换效果\n    };\n```\n\n`Aspects`帮我们封装了 `method swizzling`的过程，剩下的只管用就行了。\n\n[本文 demo 代码 戳这里](https://github.com/yehot/RuntimeDemo)\n\n> 水平有限，有错误的地方，欢迎指正！\n","source":"_posts/20160702-rutime-method-swiizzling.md","raw":"---\ntitle: runtime入门系列之——方法替换\ndate: 2016-07-02 18:58:37\ntags: runtime swizzling\n---\n\n作为一个有2年以上 iOS 开发经验的程序猿，如果说自己不知道 runtime 简直不好意思跟别人打招呼了。\n\n但是大部分初级 iOS 程序猿在实际项目开发中，很少有机会需要主动用到 runtime 相关的东西。最近面试的不少同学，当我问\"请说说你对 iOS 中 runtime 的理解\"就懵逼了。\n\n其实作为小面试官，我也是很尴尬的。你简历上期望薪资都写 15k+ 了，那总不能指望面试一个小时，我都只跟你聊如何写界面吧？\n\n---\n\n我觉得当我问面试者：\n> \"什么是 runtime ?\"\n\n这个问题时，如果能在以下三个方面做个简单的阐述，我觉得就基本合格了。\n\n### 一、runtime 是什么？\n\n- 首先 OC 是 C 语言的超集，因为 runtime 这个库使得C语言有了面向对象的能力：\nOC 对象可以用C语言中的结构体表示，而方法可以用C函数来实现，这些结构体和函数被 runtime 函数封装后，我们就可以在程序运行时创建，检查，修改类、对象和它们的方法了。\n\n- OC 是一门动态语言，它将很多静态语言在编译和链接时期做的事放到了运行时来处理。\n这种特性意味着Objective-C不仅需要一个编译器，还需要一个运行时系统来执行编译的代码。这个运行时系统即Objc Runtime。Objc Runtime基本上是用C和汇编写的。\n[参考 南峰子： Objective-C Runtime 运行时之一：类与对象](http://southpeak.github.io/blog/2014/10/25/objective-c-runtime-yun-xing-shi-zhi-lei-yu-dui-xiang/)\n\n### 二、runtime 有什么用？\n- 我们写的代码在程序运行过程中都会被转化成 runtime 的C代码执行\nOC的类、对象、方法在运行时，最终都转换成 C语言的 结构体、函数来执行。\n     可以在程序运行时创建，检查，修改类、对象和它们的方法。\n\n- 常用于：\n      - 获取类的方法列表/参数列表；\n      - 方法调用；\n      - 方法拦截、动态添加方法；\n      - 方法替换： method swizzling\n      - 关联对象，动态添加属性；\n\n### 三、runtime 怎么用？\n\n> 或者，说说你具体在项目中哪些地方用到过 runtime ？\n\n- runtime 的 API 提供了大量的函数来操作类和对象，如：\n    - 动态替换方法的实现、方法拦截：`class_replaceMethod`\n    - 获取对象的属性列表：`class_copyIvarList`\n    - 获取对象的方法列表： `class_copyMethodList`\n    - 动态添加属性: `class_addProperty`\n    - 动态添加方法： `class_addMethod`\n    - 获取方法名： `method_getName`\n    - 获取方法的实现： `class_getMethodImplementation`\n\n- 具体应用：\n    - 给 category 添加属性： \n        `给 UIAlertView 加 block 回调`\n    - 给系统的方法做替换，插入代码： \n        `替换 viewDidLoad 方法的实现，NSLog 出每一个出现页面的类名`\n\n---\n\n## 「方法替换」demo:\n\n声明一个`People`类\n```\n@interface People : NSObject\n- (void)run;\n@end\n\n@implementation People\n- (void)run {\n    NSLog(@\"People run\");\n}\n@end\n```\n\n实现替换的方法\n\n```\n@implementation ViewController\n\n// demo 是在当前类直接定义了一个方法，也可以用代码动态生成一个方法\n- (void)runFast {\n    NSLog(@\"People run fast\");\n}\n\n/\n *  替换 People 类中 run 方法的实现\n */\n- (void)replacePeopleRunMethod {\n    \n    Class peopleClass = NSClassFromString(@\"People\");\n    SEL peopleRunSel = @selector(run);\n    Method methodRun = class_getInstanceMethod(peopleClass, peopleRunSel);\n    // 获取 run 方法的参数 （包括了 parameter and return types）\n    char *typeDescription = (char *)method_getTypeEncoding(methodRun);\n    \n    // 获取 runFast 方法的实现\n    IMP runFastImp = class_getMethodImplementation([self class], @selector(runFast));\n    \n    // 给 People 新增 runFast 方法，并指向的当前类中 runFast 的实现\n    class_addMethod(peopleClass, @selector(runFast), runFastImp, typeDescription);\n    \n    // 替换 run 方法为 runFast 方法\n    class_replaceMethod(peopleClass, peopleRunSel, runFastImp, typeDescription);\n}\n@end\n```\n\n调用\n\n```\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    People *p1 = [[People alloc] init];\n    [p1 run];\n    \n    [self replacePeopleRunMethod];\n    [p1 run];\n}\n```\n\n输出如下：\n```\n2016-07-02 18:11:26.707 RuntimeDemo[26972:1726702] People run\n2016-07-02 18:11:26.712 RuntimeDemo[26972:1726702] People run fast\n```\n> 注意，这里的方法替换是永久性的，只要程序不退出，以后无论在任何地方调用`[p1 run]`都只会调用`runFast`的实现。\n\n> 而且，method swizzling 方法并不适合写在这里，通常写在 `+ (void)load `方法中，并且用 `dispatch_once` 来进行调度。至于为什么，可以参考[Objective-C +load vs +initialize](http://blog.leichunfeng.com/blog/2015/05/02/objective-c-plus-load-vs-plus-initialize/)。\n\n相关注释：\n\n```\n    // Method : 包含了一个方法的  方法名 + 实现 + 参数个数及类型 + 返回值个数及类型 等信息\n    // class_getInstanceMethod : 通过类名 + 方法名 获取一个 Method\n    // class_getMethodImplementation: 类名 + 方法名\n    // class_addMethod: 类名 + 方法名 + 方法实现 + 参数信息\n    // class_replaceMethod : 类型 + 替换的方法名 + 替换后的实现 + 参数信息\n```\n\n以上 demo 只是简单的在当前类`ViewController`中，定义了一个`runFast`方法，并用其替换了`People` 类中`run`方法的实现。\n\n这里需要先用 `class_addMethod`，而不是直接用`class_replaceMethod`，是为了做一层保护，因为如果 `People` 类没有实现 `run` 方法 ，但其父类实现了，那 class_getInstanceMethod 会返回父类的方法。\n     这样 method_exchangeImplementations 替换的是父类的那个方法，这当然不是你想要的。\n     所以我们先尝试添加 `runFast`方法，如果已经存在，就用 `method_exchangeImplementations` 把原方法的实现跟新的方法实现给交换掉。否则用`class_replaceMethod`来替换。\n\n---\n\n### 「方法替换」常规写法\n\n上文 demo 中的写法，只是实现了方法替换的效果，但真正在项目中用的时候会存在一些问题，如调用时机、调用次数、替换失败等问题，所以，一般实战中写法如下：\n\n```\n#import \"UIViewController+Logging.h\"\n#import <objc/runtime.h>\n\n@implementation UIViewController (Logging)\n\n+ (void)load {\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        Class targetClass = [self class];\n        SEL originalSelector = @selector(viewDidAppear:);\n        SEL swizzledSelector = @selector(swizzled_viewDidAppear:);\n        swizzleMethod(targetClass, originalSelector, swizzledSelector);\n    });\n}\n\nvoid swizzleMethod(Class class, SEL originalSelector, SEL swizzledSelector) {\n    Method originalMethod = class_getInstanceMethod(class, originalSelector);\n    Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);\n    \n    IMP swizzledImp = method_getImplementation(swizzledMethod);\n    char *swizzledTypes = (char *)method_getTypeEncoding(swizzledMethod);\n    \n    IMP originalImp = method_getImplementation(originalMethod);\n    \n    char *originalTypes = (char *)method_getTypeEncoding(originalMethod);\n    BOOL success = class_addMethod(class, originalSelector, swizzledImp, swizzledTypes);\n    if (success) {\n        class_replaceMethod(class, swizzledSelector, originalImp, originalTypes);\n    }else {\n        // 添加失败，表明已经有这个方法，直接交换\n        method_exchangeImplementations(originalMethod, swizzledMethod);\n    }\n}\n\n- (void)swizzled_viewDidAppear:(BOOL)animation {\n    [self swizzled_viewDidAppear:animation];\n    NSLog(@\"%@ viewDidAppear\", NSStringFromClass([self class]));\n}\n\n@end\n```\n---\n\n### 扩展 —— 用 Aspects 实现方法替换\n\n上边 demo 中写了一大堆 runtime 的 api 在代码里，即不好阅读，也不便于维护。\n> 这里有现成的方案：一个基于 swizzling method 的开源框架 [Aspects](https://github.com/steipete/Aspects) 。\n\n用 `Aspects` 来实现上文 demo 如下：\n\n```\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    People *p1 = [[People alloc] init];\n    [p1 run];   \n      \n    [People aspect_hookSelector:@selector(run) withOptions:AspectPositionInstead usingBlock:^(id<AspectInfo> aspectInfo) {\n        NSLog(@\"People aspect run fast\");\n    } error:nil];\n\n    [p1 run];\n```\n\n输出：\n\n```\n2016-07-02 18:16:38.039 RuntimeDemo[26994:1730239] People run\n2016-07-02 18:16:38.043 RuntimeDemo[26994:1730239] People aspect run fast\n```\n\n需要注意的是 `Aspects` 的 `aspect_hookSelector:` 方法中，`AspectOptions`参数决定了方法替换的时机：\n\n```\ntypedef NS_OPTIONS(NSUInteger, AspectOptions) {\n    AspectPositionAfter   = 0,            /// 原方法调用后 (default)\n    AspectPositionInstead = 1,            /// 完全替换原方法\n    AspectPositionBefore  = 2,            /// 原方法调用前\n    AspectOptionAutomaticRemoval = 1 << 3 /// 在执行一次替换的方法后，就移除替换效果\n    };\n```\n\n`Aspects`帮我们封装了 `method swizzling`的过程，剩下的只管用就行了。\n\n[本文 demo 代码 戳这里](https://github.com/yehot/RuntimeDemo)\n\n> 水平有限，有错误的地方，欢迎指正！\n","slug":"20160702-rutime-method-swiizzling","published":1,"updated":"2017-03-10T05:59:37.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj03ftfnw00047womlvsok456","content":"<p>作为一个有2年以上 iOS 开发经验的程序猿，如果说自己不知道 runtime 简直不好意思跟别人打招呼了。</p>\n<p>但是大部分初级 iOS 程序猿在实际项目开发中，很少有机会需要主动用到 runtime 相关的东西。最近面试的不少同学，当我问”请说说你对 iOS 中 runtime 的理解”就懵逼了。</p>\n<p>其实作为小面试官，我也是很尴尬的。你简历上期望薪资都写 15k+ 了，那总不能指望面试一个小时，我都只跟你聊如何写界面吧？</p>\n<hr>\n<p>我觉得当我问面试者：</p>\n<blockquote>\n<p>“什么是 runtime ?”</p>\n</blockquote>\n<p>这个问题时，如果能在以下三个方面做个简单的阐述，我觉得就基本合格了。</p>\n<h3 id=\"一、runtime-是什么？\"><a href=\"#一、runtime-是什么？\" class=\"headerlink\" title=\"一、runtime 是什么？\"></a>一、runtime 是什么？</h3><ul>\n<li><p>首先 OC 是 C 语言的超集，因为 runtime 这个库使得C语言有了面向对象的能力：<br>OC 对象可以用C语言中的结构体表示，而方法可以用C函数来实现，这些结构体和函数被 runtime 函数封装后，我们就可以在程序运行时创建，检查，修改类、对象和它们的方法了。</p>\n</li>\n<li><p>OC 是一门动态语言，它将很多静态语言在编译和链接时期做的事放到了运行时来处理。<br>这种特性意味着Objective-C不仅需要一个编译器，还需要一个运行时系统来执行编译的代码。这个运行时系统即Objc Runtime。Objc Runtime基本上是用C和汇编写的。<br><a href=\"http://southpeak.github.io/blog/2014/10/25/objective-c-runtime-yun-xing-shi-zhi-lei-yu-dui-xiang/\" target=\"_blank\" rel=\"external\">参考 南峰子： Objective-C Runtime 运行时之一：类与对象</a></p>\n</li>\n</ul>\n<h3 id=\"二、runtime-有什么用？\"><a href=\"#二、runtime-有什么用？\" class=\"headerlink\" title=\"二、runtime 有什么用？\"></a>二、runtime 有什么用？</h3><ul>\n<li><p>我们写的代码在程序运行过程中都会被转化成 runtime 的C代码执行<br>OC的类、对象、方法在运行时，最终都转换成 C语言的 结构体、函数来执行。<br>   可以在程序运行时创建，检查，修改类、对象和它们的方法。</p>\n</li>\n<li><p>常用于：</p>\n<pre><code>- 获取类的方法列表/参数列表；\n- 方法调用；\n- 方法拦截、动态添加方法；\n- 方法替换： method swizzling\n- 关联对象，动态添加属性；\n</code></pre></li>\n</ul>\n<h3 id=\"三、runtime-怎么用？\"><a href=\"#三、runtime-怎么用？\" class=\"headerlink\" title=\"三、runtime 怎么用？\"></a>三、runtime 怎么用？</h3><blockquote>\n<p>或者，说说你具体在项目中哪些地方用到过 runtime ？</p>\n</blockquote>\n<ul>\n<li><p>runtime 的 API 提供了大量的函数来操作类和对象，如：</p>\n<ul>\n<li>动态替换方法的实现、方法拦截：<code>class_replaceMethod</code></li>\n<li>获取对象的属性列表：<code>class_copyIvarList</code></li>\n<li>获取对象的方法列表： <code>class_copyMethodList</code></li>\n<li>动态添加属性: <code>class_addProperty</code></li>\n<li>动态添加方法： <code>class_addMethod</code></li>\n<li>获取方法名： <code>method_getName</code></li>\n<li>获取方法的实现： <code>class_getMethodImplementation</code></li>\n</ul>\n</li>\n<li><p>具体应用：</p>\n<ul>\n<li>给 category 添加属性：<br>  <code>给 UIAlertView 加 block 回调</code></li>\n<li>给系统的方法做替换，插入代码：<br>  <code>替换 viewDidLoad 方法的实现，NSLog 出每一个出现页面的类名</code></li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"「方法替换」demo\"><a href=\"#「方法替换」demo\" class=\"headerlink\" title=\"「方法替换」demo:\"></a>「方法替换」demo:</h2><p>声明一个<code>People</code>类<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface People : NSObject</div><div class=\"line\">- (void)run;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation People</div><div class=\"line\">- (void)run &#123;</div><div class=\"line\">    NSLog(@&quot;People run&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure></p>\n<p>实现替换的方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">@implementation ViewController</div><div class=\"line\"></div><div class=\"line\">// demo 是在当前类直接定义了一个方法，也可以用代码动态生成一个方法</div><div class=\"line\">- (void)runFast &#123;</div><div class=\"line\">    NSLog(@&quot;People run fast&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">/</div><div class=\"line\"> *  替换 People 类中 run 方法的实现</div><div class=\"line\"> */</div><div class=\"line\">- (void)replacePeopleRunMethod &#123;</div><div class=\"line\">    </div><div class=\"line\">    Class peopleClass = NSClassFromString(@&quot;People&quot;);</div><div class=\"line\">    SEL peopleRunSel = @selector(run);</div><div class=\"line\">    Method methodRun = class_getInstanceMethod(peopleClass, peopleRunSel);</div><div class=\"line\">    // 获取 run 方法的参数 （包括了 parameter and return types）</div><div class=\"line\">    char *typeDescription = (char *)method_getTypeEncoding(methodRun);</div><div class=\"line\">    </div><div class=\"line\">    // 获取 runFast 方法的实现</div><div class=\"line\">    IMP runFastImp = class_getMethodImplementation([self class], @selector(runFast));</div><div class=\"line\">    </div><div class=\"line\">    // 给 People 新增 runFast 方法，并指向的当前类中 runFast 的实现</div><div class=\"line\">    class_addMethod(peopleClass, @selector(runFast), runFastImp, typeDescription);</div><div class=\"line\">    </div><div class=\"line\">    // 替换 run 方法为 runFast 方法</div><div class=\"line\">    class_replaceMethod(peopleClass, peopleRunSel, runFastImp, typeDescription);</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>调用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)viewDidLoad &#123;</div><div class=\"line\">    [super viewDidLoad];</div><div class=\"line\"></div><div class=\"line\">    People *p1 = [[People alloc] init];</div><div class=\"line\">    [p1 run];</div><div class=\"line\">    </div><div class=\"line\">    [self replacePeopleRunMethod];</div><div class=\"line\">    [p1 run];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>输出如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">2016-07-02 18:11:26.707 RuntimeDemo[26972:1726702] People run</div><div class=\"line\">2016-07-02 18:11:26.712 RuntimeDemo[26972:1726702] People run fast</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>注意，这里的方法替换是永久性的，只要程序不退出，以后无论在任何地方调用<code>[p1 run]</code>都只会调用<code>runFast</code>的实现。</p>\n<p>而且，method swizzling 方法并不适合写在这里，通常写在 <code>+ (void)load</code>方法中，并且用 <code>dispatch_once</code> 来进行调度。至于为什么，可以参考<a href=\"http://blog.leichunfeng.com/blog/2015/05/02/objective-c-plus-load-vs-plus-initialize/\" target=\"_blank\" rel=\"external\">Objective-C +load vs +initialize</a>。</p>\n</blockquote>\n<p>相关注释：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">    // Method : 包含了一个方法的  方法名 + 实现 + 参数个数及类型 + 返回值个数及类型 等信息</div><div class=\"line\">    // class_getInstanceMethod : 通过类名 + 方法名 获取一个 Method</div><div class=\"line\">// class_getMethodImplementation: 类名 + 方法名</div><div class=\"line\">    // class_addMethod: 类名 + 方法名 + 方法实现 + 参数信息</div><div class=\"line\">    // class_replaceMethod : 类型 + 替换的方法名 + 替换后的实现 + 参数信息</div></pre></td></tr></table></figure>\n<p>以上 demo 只是简单的在当前类<code>ViewController</code>中，定义了一个<code>runFast</code>方法，并用其替换了<code>People</code> 类中<code>run</code>方法的实现。</p>\n<p>这里需要先用 <code>class_addMethod</code>，而不是直接用<code>class_replaceMethod</code>，是为了做一层保护，因为如果 <code>People</code> 类没有实现 <code>run</code> 方法 ，但其父类实现了，那 class_getInstanceMethod 会返回父类的方法。<br>     这样 method_exchangeImplementations 替换的是父类的那个方法，这当然不是你想要的。<br>     所以我们先尝试添加 <code>runFast</code>方法，如果已经存在，就用 <code>method_exchangeImplementations</code> 把原方法的实现跟新的方法实现给交换掉。否则用<code>class_replaceMethod</code>来替换。</p>\n<hr>\n<h3 id=\"「方法替换」常规写法\"><a href=\"#「方法替换」常规写法\" class=\"headerlink\" title=\"「方法替换」常规写法\"></a>「方法替换」常规写法</h3><p>上文 demo 中的写法，只是实现了方法替换的效果，但真正在项目中用的时候会存在一些问题，如调用时机、调用次数、替换失败等问题，所以，一般实战中写法如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &quot;UIViewController+Logging.h&quot;</div><div class=\"line\">#import &lt;objc/runtime.h&gt;</div><div class=\"line\"></div><div class=\"line\">@implementation UIViewController (Logging)</div><div class=\"line\"></div><div class=\"line\">+ (void)load &#123;</div><div class=\"line\">    static dispatch_once_t onceToken;</div><div class=\"line\">    dispatch_once(&amp;onceToken, ^&#123;</div><div class=\"line\">        Class targetClass = [self class];</div><div class=\"line\">        SEL originalSelector = @selector(viewDidAppear:);</div><div class=\"line\">        SEL swizzledSelector = @selector(swizzled_viewDidAppear:);</div><div class=\"line\">        swizzleMethod(targetClass, originalSelector, swizzledSelector);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">void swizzleMethod(Class class, SEL originalSelector, SEL swizzledSelector) &#123;</div><div class=\"line\">    Method originalMethod = class_getInstanceMethod(class, originalSelector);</div><div class=\"line\">    Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);</div><div class=\"line\">    </div><div class=\"line\">    IMP swizzledImp = method_getImplementation(swizzledMethod);</div><div class=\"line\">    char *swizzledTypes = (char *)method_getTypeEncoding(swizzledMethod);</div><div class=\"line\">    </div><div class=\"line\">    IMP originalImp = method_getImplementation(originalMethod);</div><div class=\"line\">    </div><div class=\"line\">    char *originalTypes = (char *)method_getTypeEncoding(originalMethod);</div><div class=\"line\">    BOOL success = class_addMethod(class, originalSelector, swizzledImp, swizzledTypes);</div><div class=\"line\">    if (success) &#123;</div><div class=\"line\">        class_replaceMethod(class, swizzledSelector, originalImp, originalTypes);</div><div class=\"line\">    &#125;else &#123;</div><div class=\"line\">        // 添加失败，表明已经有这个方法，直接交换</div><div class=\"line\">        method_exchangeImplementations(originalMethod, swizzledMethod);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)swizzled_viewDidAppear:(BOOL)animation &#123;</div><div class=\"line\">    [self swizzled_viewDidAppear:animation];</div><div class=\"line\">    NSLog(@&quot;%@ viewDidAppear&quot;, NSStringFromClass([self class]));</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"扩展-——-用-Aspects-实现方法替换\"><a href=\"#扩展-——-用-Aspects-实现方法替换\" class=\"headerlink\" title=\"扩展 —— 用 Aspects 实现方法替换\"></a>扩展 —— 用 Aspects 实现方法替换</h3><p>上边 demo 中写了一大堆 runtime 的 api 在代码里，即不好阅读，也不便于维护。</p>\n<blockquote>\n<p>这里有现成的方案：一个基于 swizzling method 的开源框架 <a href=\"https://github.com/steipete/Aspects\" target=\"_blank\" rel=\"external\">Aspects</a> 。</p>\n</blockquote>\n<p>用 <code>Aspects</code> 来实现上文 demo 如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)viewDidLoad &#123;</div><div class=\"line\">    [super viewDidLoad];</div><div class=\"line\">    </div><div class=\"line\">    People *p1 = [[People alloc] init];</div><div class=\"line\">    [p1 run];   </div><div class=\"line\">      </div><div class=\"line\">    [People aspect_hookSelector:@selector(run) withOptions:AspectPositionInstead usingBlock:^(id&lt;AspectInfo&gt; aspectInfo) &#123;</div><div class=\"line\">        NSLog(@&quot;People aspect run fast&quot;);</div><div class=\"line\">    &#125; error:nil];</div><div class=\"line\"></div><div class=\"line\">    [p1 run];</div></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">2016-07-02 18:16:38.039 RuntimeDemo[26994:1730239] People run</div><div class=\"line\">2016-07-02 18:16:38.043 RuntimeDemo[26994:1730239] People aspect run fast</div></pre></td></tr></table></figure>\n<p>需要注意的是 <code>Aspects</code> 的 <code>aspect_hookSelector:</code> 方法中，<code>AspectOptions</code>参数决定了方法替换的时机：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef NS_OPTIONS(NSUInteger, AspectOptions) &#123;</div><div class=\"line\">    AspectPositionAfter   = 0,            /// 原方法调用后 (default)</div><div class=\"line\">    AspectPositionInstead = 1,            /// 完全替换原方法</div><div class=\"line\">    AspectPositionBefore  = 2,            /// 原方法调用前</div><div class=\"line\">    AspectOptionAutomaticRemoval = 1 &lt;&lt; 3 /// 在执行一次替换的方法后，就移除替换效果</div><div class=\"line\">    &#125;;</div></pre></td></tr></table></figure>\n<p><code>Aspects</code>帮我们封装了 <code>method swizzling</code>的过程，剩下的只管用就行了。</p>\n<p><a href=\"https://github.com/yehot/RuntimeDemo\" target=\"_blank\" rel=\"external\">本文 demo 代码 戳这里</a></p>\n<blockquote>\n<p>水平有限，有错误的地方，欢迎指正！</p>\n</blockquote>\n","excerpt":"","more":"<p>作为一个有2年以上 iOS 开发经验的程序猿，如果说自己不知道 runtime 简直不好意思跟别人打招呼了。</p>\n<p>但是大部分初级 iOS 程序猿在实际项目开发中，很少有机会需要主动用到 runtime 相关的东西。最近面试的不少同学，当我问”请说说你对 iOS 中 runtime 的理解”就懵逼了。</p>\n<p>其实作为小面试官，我也是很尴尬的。你简历上期望薪资都写 15k+ 了，那总不能指望面试一个小时，我都只跟你聊如何写界面吧？</p>\n<hr>\n<p>我觉得当我问面试者：</p>\n<blockquote>\n<p>“什么是 runtime ?”</p>\n</blockquote>\n<p>这个问题时，如果能在以下三个方面做个简单的阐述，我觉得就基本合格了。</p>\n<h3 id=\"一、runtime-是什么？\"><a href=\"#一、runtime-是什么？\" class=\"headerlink\" title=\"一、runtime 是什么？\"></a>一、runtime 是什么？</h3><ul>\n<li><p>首先 OC 是 C 语言的超集，因为 runtime 这个库使得C语言有了面向对象的能力：<br>OC 对象可以用C语言中的结构体表示，而方法可以用C函数来实现，这些结构体和函数被 runtime 函数封装后，我们就可以在程序运行时创建，检查，修改类、对象和它们的方法了。</p>\n</li>\n<li><p>OC 是一门动态语言，它将很多静态语言在编译和链接时期做的事放到了运行时来处理。<br>这种特性意味着Objective-C不仅需要一个编译器，还需要一个运行时系统来执行编译的代码。这个运行时系统即Objc Runtime。Objc Runtime基本上是用C和汇编写的。<br><a href=\"http://southpeak.github.io/blog/2014/10/25/objective-c-runtime-yun-xing-shi-zhi-lei-yu-dui-xiang/\">参考 南峰子： Objective-C Runtime 运行时之一：类与对象</a></p>\n</li>\n</ul>\n<h3 id=\"二、runtime-有什么用？\"><a href=\"#二、runtime-有什么用？\" class=\"headerlink\" title=\"二、runtime 有什么用？\"></a>二、runtime 有什么用？</h3><ul>\n<li><p>我们写的代码在程序运行过程中都会被转化成 runtime 的C代码执行<br>OC的类、对象、方法在运行时，最终都转换成 C语言的 结构体、函数来执行。<br>   可以在程序运行时创建，检查，修改类、对象和它们的方法。</p>\n</li>\n<li><p>常用于：</p>\n<pre><code>- 获取类的方法列表/参数列表；\n- 方法调用；\n- 方法拦截、动态添加方法；\n- 方法替换： method swizzling\n- 关联对象，动态添加属性；\n</code></pre></li>\n</ul>\n<h3 id=\"三、runtime-怎么用？\"><a href=\"#三、runtime-怎么用？\" class=\"headerlink\" title=\"三、runtime 怎么用？\"></a>三、runtime 怎么用？</h3><blockquote>\n<p>或者，说说你具体在项目中哪些地方用到过 runtime ？</p>\n</blockquote>\n<ul>\n<li><p>runtime 的 API 提供了大量的函数来操作类和对象，如：</p>\n<ul>\n<li>动态替换方法的实现、方法拦截：<code>class_replaceMethod</code></li>\n<li>获取对象的属性列表：<code>class_copyIvarList</code></li>\n<li>获取对象的方法列表： <code>class_copyMethodList</code></li>\n<li>动态添加属性: <code>class_addProperty</code></li>\n<li>动态添加方法： <code>class_addMethod</code></li>\n<li>获取方法名： <code>method_getName</code></li>\n<li>获取方法的实现： <code>class_getMethodImplementation</code></li>\n</ul>\n</li>\n<li><p>具体应用：</p>\n<ul>\n<li>给 category 添加属性：<br>  <code>给 UIAlertView 加 block 回调</code></li>\n<li>给系统的方法做替换，插入代码：<br>  <code>替换 viewDidLoad 方法的实现，NSLog 出每一个出现页面的类名</code></li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"「方法替换」demo\"><a href=\"#「方法替换」demo\" class=\"headerlink\" title=\"「方法替换」demo:\"></a>「方法替换」demo:</h2><p>声明一个<code>People</code>类<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">@interface People : NSObject</div><div class=\"line\">- (void)run;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation People</div><div class=\"line\">- (void)run &#123;</div><div class=\"line\">    NSLog(@&quot;People run&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure></p>\n<p>实现替换的方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">@implementation ViewController</div><div class=\"line\"></div><div class=\"line\">// demo 是在当前类直接定义了一个方法，也可以用代码动态生成一个方法</div><div class=\"line\">- (void)runFast &#123;</div><div class=\"line\">    NSLog(@&quot;People run fast&quot;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">/</div><div class=\"line\"> *  替换 People 类中 run 方法的实现</div><div class=\"line\"> */</div><div class=\"line\">- (void)replacePeopleRunMethod &#123;</div><div class=\"line\">    </div><div class=\"line\">    Class peopleClass = NSClassFromString(@&quot;People&quot;);</div><div class=\"line\">    SEL peopleRunSel = @selector(run);</div><div class=\"line\">    Method methodRun = class_getInstanceMethod(peopleClass, peopleRunSel);</div><div class=\"line\">    // 获取 run 方法的参数 （包括了 parameter and return types）</div><div class=\"line\">    char *typeDescription = (char *)method_getTypeEncoding(methodRun);</div><div class=\"line\">    </div><div class=\"line\">    // 获取 runFast 方法的实现</div><div class=\"line\">    IMP runFastImp = class_getMethodImplementation([self class], @selector(runFast));</div><div class=\"line\">    </div><div class=\"line\">    // 给 People 新增 runFast 方法，并指向的当前类中 runFast 的实现</div><div class=\"line\">    class_addMethod(peopleClass, @selector(runFast), runFastImp, typeDescription);</div><div class=\"line\">    </div><div class=\"line\">    // 替换 run 方法为 runFast 方法</div><div class=\"line\">    class_replaceMethod(peopleClass, peopleRunSel, runFastImp, typeDescription);</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>调用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)viewDidLoad &#123;</div><div class=\"line\">    [super viewDidLoad];</div><div class=\"line\"></div><div class=\"line\">    People *p1 = [[People alloc] init];</div><div class=\"line\">    [p1 run];</div><div class=\"line\">    </div><div class=\"line\">    [self replacePeopleRunMethod];</div><div class=\"line\">    [p1 run];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>输出如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">2016-07-02 18:11:26.707 RuntimeDemo[26972:1726702] People run</div><div class=\"line\">2016-07-02 18:11:26.712 RuntimeDemo[26972:1726702] People run fast</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>注意，这里的方法替换是永久性的，只要程序不退出，以后无论在任何地方调用<code>[p1 run]</code>都只会调用<code>runFast</code>的实现。</p>\n<p>而且，method swizzling 方法并不适合写在这里，通常写在 <code>+ (void)load</code>方法中，并且用 <code>dispatch_once</code> 来进行调度。至于为什么，可以参考<a href=\"http://blog.leichunfeng.com/blog/2015/05/02/objective-c-plus-load-vs-plus-initialize/\">Objective-C +load vs +initialize</a>。</p>\n</blockquote>\n<p>相关注释：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">    // Method : 包含了一个方法的  方法名 + 实现 + 参数个数及类型 + 返回值个数及类型 等信息</div><div class=\"line\">    // class_getInstanceMethod : 通过类名 + 方法名 获取一个 Method</div><div class=\"line\">// class_getMethodImplementation: 类名 + 方法名</div><div class=\"line\">    // class_addMethod: 类名 + 方法名 + 方法实现 + 参数信息</div><div class=\"line\">    // class_replaceMethod : 类型 + 替换的方法名 + 替换后的实现 + 参数信息</div></pre></td></tr></table></figure>\n<p>以上 demo 只是简单的在当前类<code>ViewController</code>中，定义了一个<code>runFast</code>方法，并用其替换了<code>People</code> 类中<code>run</code>方法的实现。</p>\n<p>这里需要先用 <code>class_addMethod</code>，而不是直接用<code>class_replaceMethod</code>，是为了做一层保护，因为如果 <code>People</code> 类没有实现 <code>run</code> 方法 ，但其父类实现了，那 class_getInstanceMethod 会返回父类的方法。<br>     这样 method_exchangeImplementations 替换的是父类的那个方法，这当然不是你想要的。<br>     所以我们先尝试添加 <code>runFast</code>方法，如果已经存在，就用 <code>method_exchangeImplementations</code> 把原方法的实现跟新的方法实现给交换掉。否则用<code>class_replaceMethod</code>来替换。</p>\n<hr>\n<h3 id=\"「方法替换」常规写法\"><a href=\"#「方法替换」常规写法\" class=\"headerlink\" title=\"「方法替换」常规写法\"></a>「方法替换」常规写法</h3><p>上文 demo 中的写法，只是实现了方法替换的效果，但真正在项目中用的时候会存在一些问题，如调用时机、调用次数、替换失败等问题，所以，一般实战中写法如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &quot;UIViewController+Logging.h&quot;</div><div class=\"line\">#import &lt;objc/runtime.h&gt;</div><div class=\"line\"></div><div class=\"line\">@implementation UIViewController (Logging)</div><div class=\"line\"></div><div class=\"line\">+ (void)load &#123;</div><div class=\"line\">    static dispatch_once_t onceToken;</div><div class=\"line\">    dispatch_once(&amp;onceToken, ^&#123;</div><div class=\"line\">        Class targetClass = [self class];</div><div class=\"line\">        SEL originalSelector = @selector(viewDidAppear:);</div><div class=\"line\">        SEL swizzledSelector = @selector(swizzled_viewDidAppear:);</div><div class=\"line\">        swizzleMethod(targetClass, originalSelector, swizzledSelector);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">void swizzleMethod(Class class, SEL originalSelector, SEL swizzledSelector) &#123;</div><div class=\"line\">    Method originalMethod = class_getInstanceMethod(class, originalSelector);</div><div class=\"line\">    Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);</div><div class=\"line\">    </div><div class=\"line\">    IMP swizzledImp = method_getImplementation(swizzledMethod);</div><div class=\"line\">    char *swizzledTypes = (char *)method_getTypeEncoding(swizzledMethod);</div><div class=\"line\">    </div><div class=\"line\">    IMP originalImp = method_getImplementation(originalMethod);</div><div class=\"line\">    </div><div class=\"line\">    char *originalTypes = (char *)method_getTypeEncoding(originalMethod);</div><div class=\"line\">    BOOL success = class_addMethod(class, originalSelector, swizzledImp, swizzledTypes);</div><div class=\"line\">    if (success) &#123;</div><div class=\"line\">        class_replaceMethod(class, swizzledSelector, originalImp, originalTypes);</div><div class=\"line\">    &#125;else &#123;</div><div class=\"line\">        // 添加失败，表明已经有这个方法，直接交换</div><div class=\"line\">        method_exchangeImplementations(originalMethod, swizzledMethod);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)swizzled_viewDidAppear:(BOOL)animation &#123;</div><div class=\"line\">    [self swizzled_viewDidAppear:animation];</div><div class=\"line\">    NSLog(@&quot;%@ viewDidAppear&quot;, NSStringFromClass([self class]));</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"扩展-——-用-Aspects-实现方法替换\"><a href=\"#扩展-——-用-Aspects-实现方法替换\" class=\"headerlink\" title=\"扩展 —— 用 Aspects 实现方法替换\"></a>扩展 —— 用 Aspects 实现方法替换</h3><p>上边 demo 中写了一大堆 runtime 的 api 在代码里，即不好阅读，也不便于维护。</p>\n<blockquote>\n<p>这里有现成的方案：一个基于 swizzling method 的开源框架 <a href=\"https://github.com/steipete/Aspects\">Aspects</a> 。</p>\n</blockquote>\n<p>用 <code>Aspects</code> 来实现上文 demo 如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)viewDidLoad &#123;</div><div class=\"line\">    [super viewDidLoad];</div><div class=\"line\">    </div><div class=\"line\">    People *p1 = [[People alloc] init];</div><div class=\"line\">    [p1 run];   </div><div class=\"line\">      </div><div class=\"line\">    [People aspect_hookSelector:@selector(run) withOptions:AspectPositionInstead usingBlock:^(id&lt;AspectInfo&gt; aspectInfo) &#123;</div><div class=\"line\">        NSLog(@&quot;People aspect run fast&quot;);</div><div class=\"line\">    &#125; error:nil];</div><div class=\"line\"></div><div class=\"line\">    [p1 run];</div></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">2016-07-02 18:16:38.039 RuntimeDemo[26994:1730239] People run</div><div class=\"line\">2016-07-02 18:16:38.043 RuntimeDemo[26994:1730239] People aspect run fast</div></pre></td></tr></table></figure>\n<p>需要注意的是 <code>Aspects</code> 的 <code>aspect_hookSelector:</code> 方法中，<code>AspectOptions</code>参数决定了方法替换的时机：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef NS_OPTIONS(NSUInteger, AspectOptions) &#123;</div><div class=\"line\">    AspectPositionAfter   = 0,            /// 原方法调用后 (default)</div><div class=\"line\">    AspectPositionInstead = 1,            /// 完全替换原方法</div><div class=\"line\">    AspectPositionBefore  = 2,            /// 原方法调用前</div><div class=\"line\">    AspectOptionAutomaticRemoval = 1 &lt;&lt; 3 /// 在执行一次替换的方法后，就移除替换效果</div><div class=\"line\">    &#125;;</div></pre></td></tr></table></figure>\n<p><code>Aspects</code>帮我们封装了 <code>method swizzling</code>的过程，剩下的只管用就行了。</p>\n<p><a href=\"https://github.com/yehot/RuntimeDemo\">本文 demo 代码 戳这里</a></p>\n<blockquote>\n<p>水平有限，有错误的地方，欢迎指正！</p>\n</blockquote>\n"},{"title":"新浪云搭建简单的 Node.js Web 应用","date":"2016-12-17T16:43:45.000Z","_content":"\n> 阅读本文前，需要对 node.js 、npm、常用 Git 操作、express 有基本的掌握\n\n## 一、准备工作：\n\n###  注册号新浪云账号\n\n进入 http://www.sinacloud.com/sae.html\n\n![](http://ob7o39x9f.bkt.clouddn.com/14819076463405.jpg)\n\n使用微博账号即可直接登录\n\n### 创建云应用空间\n\n> 所谓云应用空间其实就相当于一个 web 站点 + 一个有完整服务器环境的代码仓库\n\n云应用空间的创建可以参考新浪的文档：[如何创建一个云空间应用](http://www.sinacloud.com/home/index/faq_detail/doc_id/83.html)\n\n当然这里需要选择开发语言为 Node.js。\n\n\n登陆，然后进入控制台 -> 云应用SAE -> 代码管理\n\n![](http://ob7o39x9f.bkt.clouddn.com/14819077010650.jpg)\n\n![](http://ob7o39x9f.bkt.clouddn.com/14819077499116.jpg)\n\n以上步骤完成后，我们就有了一个 web 应用站点，这个站点是用来放我们的 html 页面的。准备工作做好了，接下来该配置 Node.js 服务器环境，部署 web 页面上去。\n\n## 二、Node.js 服务器配置\n\n新浪云比较方便的是，即使你对 Node.js 服务器开发没有深入接触过也没关系，新浪云的 Node.js 环境基本是傻瓜式的，即开即用。所以服务器配置，过。\n\n### node.js 简单教程\n\n安利个 [30分钟 Node.js 入门](http://www.nodebeginner.org/index-zh-cn.html) 的教程，完全没有接触过 Node.js 的同学可以快速入门一下。\n\n## 三、编写 Node.js 服务代码并部署\n\n1、先在本地创建一个代码目录，从新浪的 Git 仓库里 clone 出空项目。拉代码的过程很简单，具体可以参考 [新浪的代码部署手册](http://www.sinacloud.com/doc/sae/tutorial/code-deploy.html) 文档\n\n![](http://ob7o39x9f.bkt.clouddn.com/14819889441764.jpg)\n\n2、在本地代码路径下创建一个 server.js 文件，这里我们先使用入门教程里最简单的 Node.js 代码：\n\n```js\n// server.js\nvar http = require('http');\n\nhttp.createServer(function (request, response) {\n\n    // 发送 HTTP 头部\n    // HTTP 状态值: 200 : OK\n    // 内容类型: text/plain\n    response.writeHead(200, {'Content-Type': 'text/plain'});\n\n    // 发送响应数据 \"Hello World\"\n    response.end('Hello World\\n');\n}).listen(8888);\n\n// 终端打印如下信息\nconsole.log('Server running at http://127.0.0.1:8888/');\n\n```\n\n3、由于新浪的 Node.js 构建环境需要从 package.json 文件中读取配置信息，我们需要创建一个package.json 文件。\n\n这里我们直接使用 `npm init` 命令生成一个。 NPM 是 Node Package Manager 的缩写，也就是 Node 包管理器，类似于 iOS 开发中的 CocoaPods，而 `npm init` 就相当于`pod init`了.\n\n在 server.js 文件所在目录上，执行 `npm init`,按照命令行里的提示一步一步直接敲回车即可。\n\n![](http://ob7o39x9f.bkt.clouddn.com/14819079662795.jpg)\n\n\n4、部署\n\n这里的所谓部署 == 提交代码到新浪云 Git 服务器……\n\n所以，使用 Git 命令打 commit log，push 代码，等待云端编译即可：\n\n```c\n// 提交代码\n➜  yehot git:(master) ✗ git add .\n➜  yehot git:(master) ✗ git commit -m \"添加package.json\"\n[master a6b0d8f] 添加package.json\n 1 file changed, 20 insertions(+)\n create mode 100644 package.json\n\n// push 代码后，自动开始构建\n➜  yehot git:(master) ✗ git push sae master\nCounting objects: 3, done.\nDelta compression using up to 4 threads.\nCompressing objects: 100% (3/3), done.\nWriting objects: 100% (3/3), 377 bytes | 0 bytes/s, done.\nTotal 3 (delta 2), reused 0 (delta 0)\nremote: 导出 Git 代码中...\nremote: 构建程序中...\n-----> Node.js app detected\n\n-----> Creating runtime environment\n\n       NPM_CONFIG_LOGLEVEL=error\n       NPM_CONFIG_PRODUCTION=true\n       NODE_ENV=production\n       NODE_MODULES_CACHE=true\n\n-----> Installing binaries\n       engines.node (package.json):  unspecified\n       engines.npm (package.json):   unspecified (use default)\n\n       Resolving node version (latest stable) via semver.io...\n       Downloading and installing node 7.2.1...\n       Using default npm version: 3.10.10\n\n-----> Restoring cache\n       Loading 2 from cacheDirectories (default):\n       - node_modules\n       - bower_components (not cached - skipping)\n       - nodegyp_lib (not cached - skipping)\n\n-----> Building dependencies\n       Pruning any extraneous modules\n       Installing node modules (package.json)\n       yehot@1.0.0 /tmp/build\n       `-- formidable@1.0.17\n\n\n-----> Caching build\n       Clearing previous node cache\n       Saving 2 cacheDirectories (default):\n       - node_modules\n       - bower_components (nothing to cache)\n       - nodegyp_lib (nothing to cache)\n\n-----> Build succeeded!\n       `-- formidable@1.0.17\n\n-----> Discovering process types\n       Default types for  -> web\n-----> Compiled slug size is 16M\nremote: Generating docker image...\nremote: Pushing image registry.docker.sae.sina.com.cn/yehot:c72c679 .....\nremote: 部署程序中 .....\nTo https://git.sinacloud.com/yehot\n   a6b0d8f..c72c679  master -> master\n\n```\n\n到这里构建成功，就算部署成功了。这时我们的 Hello world 页面就可以在你的新浪云 Web 站点看到了：\n\n![](http://ob7o39x9f.bkt.clouddn.com/14819134008404.jpg)\n\n站点地址可以从这里查看到：\n\n![](http://ob7o39x9f.bkt.clouddn.com/14819900207625.jpg)\n\n\n## 四、部署 html 页面\n\n1、懒得自己写个页面了，直接用一个网站模板：[40 个 Bootstrap 网站模板](https://www.oschina.net/news/59924/free-bootstrap-templates) ,随便选一个，把代码压缩包 down 下来\n\n2、解压，将代码网站模板全部文件拷贝到我们的刚创建的本地 Node 仓库目录里。\n\n3、这次我们就不是简单的响应个 hello world 的，需要将 html 文本作为页面 send 出去。这里直接使用 node.js 流行框架 `Express` 帮我们完成这件事。\n\n首先在代码目录路径下执行命令：\n\n```\nnpm install express --save\n```\n\n这样会在 package.json 中，生成一条依赖信息：\n\n![](http://ob7o39x9f.bkt.clouddn.com/14819895856109.jpg)\n\n同时，会将 express 的源码从 npm 仓库中拉下来到本地自动生成的 node_modules 目录中。此时目录结构如下：\n\n![](http://ob7o39x9f.bkt.clouddn.com/14819914963002.jpg)\n\n4、改造 server.js 代码\n\n工具准备好了，开始使用：\n\n```js\n// server.js\n\nvar express = require('express')\nvar app = express()\n\n// 静态 html 页面，需要将当前目录下的所有文件都设置为 static\napp.use(express.static(__dirname + '/'));\n\napp.get('/', function (req, res) {\n    console.log('start server');\n    // sendFile 函数，在有 request 访问时，将当前目录下的 index.html 文件作为 response 返回\n    res.sendFile(__dirname + '/index.html');\n    console.log('start success');\n})\n\n// 监听 8000 端口\napp.listen(process.env.PORT || 8000)\n```\n\n5、Ok，再次 commit log、push ，等待编译\n\n编译完成后，刷新我们的站点，就能看到一个漂亮的 html 页面了：\n\n![](http://ob7o39x9f.bkt.clouddn.com/14819919635022.jpg)\n\nbootstrap 是 Twitter 开源的强大的响应式布局框架，已经帮我们做好了移动端浏览器的适配工作，可以在手机浏览器上访问下试试，效果还是挺不错的。\n\n## 五、作为服务器接口使用\n\n目前我们的 Node 服务，已经成功部署了一个简单的 web 应用。\n\n我们可以在 iOS 端通过 get 请求访问下我们的站点 `http://xxx.applinzi.com` 试试，以 AFNetworkign 为例：\n\n```ObjC\nAFHTTPSessionManager *sessionManager = [AFHTTPSessionManager manager];\n\nsessionManager.responseSerializer = [AFHTTPResponseSerializer serializer];\n\nsessionManager.responseSerializer.acceptableContentTypes = [NSSet setWithObject:@\"text/html\"];\n\n\nsessionManager.responseSerializer.acceptableContentTypes = [NSSet setWithObject:@\"text/html\"];\n\n[sessionManager GET:@\"http://yehot.applinzi.com/index.html\" parameters:nil progress:nil\n\nsuccess:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {\n\nNSLog(@\"%@\",responseObject);\n\n} failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {\n\nNSLog(@\"%@\",error);\n\n}];\n\n```\n\n## 六、其它\n\n###  新浪云控制台使用\n\n1、查看操作记录\n![](http://ob7o39x9f.bkt.clouddn.com/14819090622798.jpg)\n\n2、注册会送 200 云豆 == 2元\n\n没有额外流量消耗的话，每天默认扣 10 个豆\n\n![](http://ob7o39x9f.bkt.clouddn.com/14819091585001.jpg)\n\n如果欠费后显示\n\n![](http://ob7o39x9f.bkt.clouddn.com/14819093138228.jpg)\n\n3、查看日志、重启\n\n![](http://ob7o39x9f.bkt.clouddn.com/14819095502076.jpg)\n\n\n### 最后，新浪是有 node 应用的部署指南的\n\n上边这些坑，整整折腾了我5个小时后，我才发现这个：\n\n[新浪 node 应用部署指南](https://www.sinacloud.com/doc/sae/docker/nodejs-getting-started.html)\n\n不说了，都是泪。当然使用 Python、PHP 也可以查看对应的文档\nhttps://www.sinacloud.com/index/support.html\n\n\n## 参考：\n\n[在新浪云上用php+mysql搭建简单后台系列](http://www.jianshu.com/p/325288166a59)\n\n\n","source":"_posts/20161218-sina-sae-node-js-web-tutorial.md","raw":"---\ntitle: 新浪云搭建简单的 Node.js Web 应用\ndate: 2016-12-18 00:43:45\ntags: node.js node web sina\n---\n\n> 阅读本文前，需要对 node.js 、npm、常用 Git 操作、express 有基本的掌握\n\n## 一、准备工作：\n\n###  注册号新浪云账号\n\n进入 http://www.sinacloud.com/sae.html\n\n![](http://ob7o39x9f.bkt.clouddn.com/14819076463405.jpg)\n\n使用微博账号即可直接登录\n\n### 创建云应用空间\n\n> 所谓云应用空间其实就相当于一个 web 站点 + 一个有完整服务器环境的代码仓库\n\n云应用空间的创建可以参考新浪的文档：[如何创建一个云空间应用](http://www.sinacloud.com/home/index/faq_detail/doc_id/83.html)\n\n当然这里需要选择开发语言为 Node.js。\n\n\n登陆，然后进入控制台 -> 云应用SAE -> 代码管理\n\n![](http://ob7o39x9f.bkt.clouddn.com/14819077010650.jpg)\n\n![](http://ob7o39x9f.bkt.clouddn.com/14819077499116.jpg)\n\n以上步骤完成后，我们就有了一个 web 应用站点，这个站点是用来放我们的 html 页面的。准备工作做好了，接下来该配置 Node.js 服务器环境，部署 web 页面上去。\n\n## 二、Node.js 服务器配置\n\n新浪云比较方便的是，即使你对 Node.js 服务器开发没有深入接触过也没关系，新浪云的 Node.js 环境基本是傻瓜式的，即开即用。所以服务器配置，过。\n\n### node.js 简单教程\n\n安利个 [30分钟 Node.js 入门](http://www.nodebeginner.org/index-zh-cn.html) 的教程，完全没有接触过 Node.js 的同学可以快速入门一下。\n\n## 三、编写 Node.js 服务代码并部署\n\n1、先在本地创建一个代码目录，从新浪的 Git 仓库里 clone 出空项目。拉代码的过程很简单，具体可以参考 [新浪的代码部署手册](http://www.sinacloud.com/doc/sae/tutorial/code-deploy.html) 文档\n\n![](http://ob7o39x9f.bkt.clouddn.com/14819889441764.jpg)\n\n2、在本地代码路径下创建一个 server.js 文件，这里我们先使用入门教程里最简单的 Node.js 代码：\n\n```js\n// server.js\nvar http = require('http');\n\nhttp.createServer(function (request, response) {\n\n    // 发送 HTTP 头部\n    // HTTP 状态值: 200 : OK\n    // 内容类型: text/plain\n    response.writeHead(200, {'Content-Type': 'text/plain'});\n\n    // 发送响应数据 \"Hello World\"\n    response.end('Hello World\\n');\n}).listen(8888);\n\n// 终端打印如下信息\nconsole.log('Server running at http://127.0.0.1:8888/');\n\n```\n\n3、由于新浪的 Node.js 构建环境需要从 package.json 文件中读取配置信息，我们需要创建一个package.json 文件。\n\n这里我们直接使用 `npm init` 命令生成一个。 NPM 是 Node Package Manager 的缩写，也就是 Node 包管理器，类似于 iOS 开发中的 CocoaPods，而 `npm init` 就相当于`pod init`了.\n\n在 server.js 文件所在目录上，执行 `npm init`,按照命令行里的提示一步一步直接敲回车即可。\n\n![](http://ob7o39x9f.bkt.clouddn.com/14819079662795.jpg)\n\n\n4、部署\n\n这里的所谓部署 == 提交代码到新浪云 Git 服务器……\n\n所以，使用 Git 命令打 commit log，push 代码，等待云端编译即可：\n\n```c\n// 提交代码\n➜  yehot git:(master) ✗ git add .\n➜  yehot git:(master) ✗ git commit -m \"添加package.json\"\n[master a6b0d8f] 添加package.json\n 1 file changed, 20 insertions(+)\n create mode 100644 package.json\n\n// push 代码后，自动开始构建\n➜  yehot git:(master) ✗ git push sae master\nCounting objects: 3, done.\nDelta compression using up to 4 threads.\nCompressing objects: 100% (3/3), done.\nWriting objects: 100% (3/3), 377 bytes | 0 bytes/s, done.\nTotal 3 (delta 2), reused 0 (delta 0)\nremote: 导出 Git 代码中...\nremote: 构建程序中...\n-----> Node.js app detected\n\n-----> Creating runtime environment\n\n       NPM_CONFIG_LOGLEVEL=error\n       NPM_CONFIG_PRODUCTION=true\n       NODE_ENV=production\n       NODE_MODULES_CACHE=true\n\n-----> Installing binaries\n       engines.node (package.json):  unspecified\n       engines.npm (package.json):   unspecified (use default)\n\n       Resolving node version (latest stable) via semver.io...\n       Downloading and installing node 7.2.1...\n       Using default npm version: 3.10.10\n\n-----> Restoring cache\n       Loading 2 from cacheDirectories (default):\n       - node_modules\n       - bower_components (not cached - skipping)\n       - nodegyp_lib (not cached - skipping)\n\n-----> Building dependencies\n       Pruning any extraneous modules\n       Installing node modules (package.json)\n       yehot@1.0.0 /tmp/build\n       `-- formidable@1.0.17\n\n\n-----> Caching build\n       Clearing previous node cache\n       Saving 2 cacheDirectories (default):\n       - node_modules\n       - bower_components (nothing to cache)\n       - nodegyp_lib (nothing to cache)\n\n-----> Build succeeded!\n       `-- formidable@1.0.17\n\n-----> Discovering process types\n       Default types for  -> web\n-----> Compiled slug size is 16M\nremote: Generating docker image...\nremote: Pushing image registry.docker.sae.sina.com.cn/yehot:c72c679 .....\nremote: 部署程序中 .....\nTo https://git.sinacloud.com/yehot\n   a6b0d8f..c72c679  master -> master\n\n```\n\n到这里构建成功，就算部署成功了。这时我们的 Hello world 页面就可以在你的新浪云 Web 站点看到了：\n\n![](http://ob7o39x9f.bkt.clouddn.com/14819134008404.jpg)\n\n站点地址可以从这里查看到：\n\n![](http://ob7o39x9f.bkt.clouddn.com/14819900207625.jpg)\n\n\n## 四、部署 html 页面\n\n1、懒得自己写个页面了，直接用一个网站模板：[40 个 Bootstrap 网站模板](https://www.oschina.net/news/59924/free-bootstrap-templates) ,随便选一个，把代码压缩包 down 下来\n\n2、解压，将代码网站模板全部文件拷贝到我们的刚创建的本地 Node 仓库目录里。\n\n3、这次我们就不是简单的响应个 hello world 的，需要将 html 文本作为页面 send 出去。这里直接使用 node.js 流行框架 `Express` 帮我们完成这件事。\n\n首先在代码目录路径下执行命令：\n\n```\nnpm install express --save\n```\n\n这样会在 package.json 中，生成一条依赖信息：\n\n![](http://ob7o39x9f.bkt.clouddn.com/14819895856109.jpg)\n\n同时，会将 express 的源码从 npm 仓库中拉下来到本地自动生成的 node_modules 目录中。此时目录结构如下：\n\n![](http://ob7o39x9f.bkt.clouddn.com/14819914963002.jpg)\n\n4、改造 server.js 代码\n\n工具准备好了，开始使用：\n\n```js\n// server.js\n\nvar express = require('express')\nvar app = express()\n\n// 静态 html 页面，需要将当前目录下的所有文件都设置为 static\napp.use(express.static(__dirname + '/'));\n\napp.get('/', function (req, res) {\n    console.log('start server');\n    // sendFile 函数，在有 request 访问时，将当前目录下的 index.html 文件作为 response 返回\n    res.sendFile(__dirname + '/index.html');\n    console.log('start success');\n})\n\n// 监听 8000 端口\napp.listen(process.env.PORT || 8000)\n```\n\n5、Ok，再次 commit log、push ，等待编译\n\n编译完成后，刷新我们的站点，就能看到一个漂亮的 html 页面了：\n\n![](http://ob7o39x9f.bkt.clouddn.com/14819919635022.jpg)\n\nbootstrap 是 Twitter 开源的强大的响应式布局框架，已经帮我们做好了移动端浏览器的适配工作，可以在手机浏览器上访问下试试，效果还是挺不错的。\n\n## 五、作为服务器接口使用\n\n目前我们的 Node 服务，已经成功部署了一个简单的 web 应用。\n\n我们可以在 iOS 端通过 get 请求访问下我们的站点 `http://xxx.applinzi.com` 试试，以 AFNetworkign 为例：\n\n```ObjC\nAFHTTPSessionManager *sessionManager = [AFHTTPSessionManager manager];\n\nsessionManager.responseSerializer = [AFHTTPResponseSerializer serializer];\n\nsessionManager.responseSerializer.acceptableContentTypes = [NSSet setWithObject:@\"text/html\"];\n\n\nsessionManager.responseSerializer.acceptableContentTypes = [NSSet setWithObject:@\"text/html\"];\n\n[sessionManager GET:@\"http://yehot.applinzi.com/index.html\" parameters:nil progress:nil\n\nsuccess:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {\n\nNSLog(@\"%@\",responseObject);\n\n} failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {\n\nNSLog(@\"%@\",error);\n\n}];\n\n```\n\n## 六、其它\n\n###  新浪云控制台使用\n\n1、查看操作记录\n![](http://ob7o39x9f.bkt.clouddn.com/14819090622798.jpg)\n\n2、注册会送 200 云豆 == 2元\n\n没有额外流量消耗的话，每天默认扣 10 个豆\n\n![](http://ob7o39x9f.bkt.clouddn.com/14819091585001.jpg)\n\n如果欠费后显示\n\n![](http://ob7o39x9f.bkt.clouddn.com/14819093138228.jpg)\n\n3、查看日志、重启\n\n![](http://ob7o39x9f.bkt.clouddn.com/14819095502076.jpg)\n\n\n### 最后，新浪是有 node 应用的部署指南的\n\n上边这些坑，整整折腾了我5个小时后，我才发现这个：\n\n[新浪 node 应用部署指南](https://www.sinacloud.com/doc/sae/docker/nodejs-getting-started.html)\n\n不说了，都是泪。当然使用 Python、PHP 也可以查看对应的文档\nhttps://www.sinacloud.com/index/support.html\n\n\n## 参考：\n\n[在新浪云上用php+mysql搭建简单后台系列](http://www.jianshu.com/p/325288166a59)\n\n\n","slug":"20161218-sina-sae-node-js-web-tutorial","published":1,"updated":"2017-03-10T06:12:11.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj03ftfnx00057womnce2ms13","content":"<blockquote>\n<p>阅读本文前，需要对 node.js 、npm、常用 Git 操作、express 有基本的掌握</p>\n</blockquote>\n<h2 id=\"一、准备工作：\"><a href=\"#一、准备工作：\" class=\"headerlink\" title=\"一、准备工作：\"></a>一、准备工作：</h2><h3 id=\"注册号新浪云账号\"><a href=\"#注册号新浪云账号\" class=\"headerlink\" title=\"注册号新浪云账号\"></a>注册号新浪云账号</h3><p>进入 <a href=\"http://www.sinacloud.com/sae.html\" target=\"_blank\" rel=\"external\">http://www.sinacloud.com/sae.html</a></p>\n<p><img src=\"http://ob7o39x9f.bkt.clouddn.com/14819076463405.jpg\" alt=\"\"></p>\n<p>使用微博账号即可直接登录</p>\n<h3 id=\"创建云应用空间\"><a href=\"#创建云应用空间\" class=\"headerlink\" title=\"创建云应用空间\"></a>创建云应用空间</h3><blockquote>\n<p>所谓云应用空间其实就相当于一个 web 站点 + 一个有完整服务器环境的代码仓库</p>\n</blockquote>\n<p>云应用空间的创建可以参考新浪的文档：<a href=\"http://www.sinacloud.com/home/index/faq_detail/doc_id/83.html\" target=\"_blank\" rel=\"external\">如何创建一个云空间应用</a></p>\n<p>当然这里需要选择开发语言为 Node.js。</p>\n<p>登陆，然后进入控制台 -&gt; 云应用SAE -&gt; 代码管理</p>\n<p><img src=\"http://ob7o39x9f.bkt.clouddn.com/14819077010650.jpg\" alt=\"\"></p>\n<p><img src=\"http://ob7o39x9f.bkt.clouddn.com/14819077499116.jpg\" alt=\"\"></p>\n<p>以上步骤完成后，我们就有了一个 web 应用站点，这个站点是用来放我们的 html 页面的。准备工作做好了，接下来该配置 Node.js 服务器环境，部署 web 页面上去。</p>\n<h2 id=\"二、Node-js-服务器配置\"><a href=\"#二、Node-js-服务器配置\" class=\"headerlink\" title=\"二、Node.js 服务器配置\"></a>二、Node.js 服务器配置</h2><p>新浪云比较方便的是，即使你对 Node.js 服务器开发没有深入接触过也没关系，新浪云的 Node.js 环境基本是傻瓜式的，即开即用。所以服务器配置，过。</p>\n<h3 id=\"node-js-简单教程\"><a href=\"#node-js-简单教程\" class=\"headerlink\" title=\"node.js 简单教程\"></a>node.js 简单教程</h3><p>安利个 <a href=\"http://www.nodebeginner.org/index-zh-cn.html\" target=\"_blank\" rel=\"external\">30分钟 Node.js 入门</a> 的教程，完全没有接触过 Node.js 的同学可以快速入门一下。</p>\n<h2 id=\"三、编写-Node-js-服务代码并部署\"><a href=\"#三、编写-Node-js-服务代码并部署\" class=\"headerlink\" title=\"三、编写 Node.js 服务代码并部署\"></a>三、编写 Node.js 服务代码并部署</h2><p>1、先在本地创建一个代码目录，从新浪的 Git 仓库里 clone 出空项目。拉代码的过程很简单，具体可以参考 <a href=\"http://www.sinacloud.com/doc/sae/tutorial/code-deploy.html\" target=\"_blank\" rel=\"external\">新浪的代码部署手册</a> 文档</p>\n<p><img src=\"http://ob7o39x9f.bkt.clouddn.com/14819889441764.jpg\" alt=\"\"></p>\n<p>2、在本地代码路径下创建一个 server.js 文件，这里我们先使用入门教程里最简单的 Node.js 代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// server.js</span></div><div class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);</div><div class=\"line\"></div><div class=\"line\">http.createServer(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">request, response</span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 发送 HTTP 头部</span></div><div class=\"line\">    <span class=\"comment\">// HTTP 状态值: 200 : OK</span></div><div class=\"line\">    <span class=\"comment\">// 内容类型: text/plain</span></div><div class=\"line\">    response.writeHead(<span class=\"number\">200</span>, &#123;<span class=\"string\">'Content-Type'</span>: <span class=\"string\">'text/plain'</span>&#125;);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 发送响应数据 \"Hello World\"</span></div><div class=\"line\">    response.end(<span class=\"string\">'Hello World\\n'</span>);</div><div class=\"line\">&#125;).listen(<span class=\"number\">8888</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 终端打印如下信息</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'Server running at http://127.0.0.1:8888/'</span>);</div></pre></td></tr></table></figure>\n<p>3、由于新浪的 Node.js 构建环境需要从 package.json 文件中读取配置信息，我们需要创建一个package.json 文件。</p>\n<p>这里我们直接使用 <code>npm init</code> 命令生成一个。 NPM 是 Node Package Manager 的缩写，也就是 Node 包管理器，类似于 iOS 开发中的 CocoaPods，而 <code>npm init</code> 就相当于<code>pod init</code>了.</p>\n<p>在 server.js 文件所在目录上，执行 <code>npm init</code>,按照命令行里的提示一步一步直接敲回车即可。</p>\n<p><img src=\"http://ob7o39x9f.bkt.clouddn.com/14819079662795.jpg\" alt=\"\"></p>\n<p>4、部署</p>\n<p>这里的所谓部署 == 提交代码到新浪云 Git 服务器……</p>\n<p>所以，使用 Git 命令打 commit log，push 代码，等待云端编译即可：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 提交代码</span></div><div class=\"line\">➜  yehot git:(master) ✗ git add .</div><div class=\"line\">➜  yehot git:(master) ✗ git commit -m <span class=\"string\">\"添加package.json\"</span></div><div class=\"line\">[master a6b0d8f] 添加package.json</div><div class=\"line\"> <span class=\"number\">1</span> file changed, <span class=\"number\">20</span> insertions(+)</div><div class=\"line\"> create mode <span class=\"number\">100644</span> package.json</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// push 代码后，自动开始构建</span></div><div class=\"line\">➜  yehot git:(master) ✗ git push sae master</div><div class=\"line\">Counting objects: <span class=\"number\">3</span>, done.</div><div class=\"line\">Delta compression <span class=\"keyword\">using</span> up to <span class=\"number\">4</span> threads.</div><div class=\"line\">Compressing objects: <span class=\"number\">100</span>% (<span class=\"number\">3</span>/<span class=\"number\">3</span>), done.</div><div class=\"line\">Writing objects: <span class=\"number\">100</span>% (<span class=\"number\">3</span>/<span class=\"number\">3</span>), <span class=\"number\">377</span> bytes | <span class=\"number\">0</span> bytes/s, done.</div><div class=\"line\">Total <span class=\"number\">3</span> (delta <span class=\"number\">2</span>), reused <span class=\"number\">0</span> (delta <span class=\"number\">0</span>)</div><div class=\"line\">remote: 导出 Git 代码中...</div><div class=\"line\">remote: 构建程序中...</div><div class=\"line\">-----&gt; Node.js app detected</div><div class=\"line\"></div><div class=\"line\">-----&gt; Creating runtime environment</div><div class=\"line\"></div><div class=\"line\">       NPM_CONFIG_LOGLEVEL=error</div><div class=\"line\">       NPM_CONFIG_PRODUCTION=<span class=\"literal\">true</span></div><div class=\"line\">       NODE_ENV=production</div><div class=\"line\">       NODE_MODULES_CACHE=<span class=\"literal\">true</span></div><div class=\"line\"></div><div class=\"line\">-----&gt; Installing binaries</div><div class=\"line\">       engines.node (package.json):  unspecified</div><div class=\"line\">       engines.npm (package.json):   unspecified (use <span class=\"keyword\">default</span>)</div><div class=\"line\"></div><div class=\"line\">       Resolving node version (latest stable) via semver.io...</div><div class=\"line\">       Downloading and installing node <span class=\"number\">7.2</span><span class=\"number\">.1</span>...</div><div class=\"line\">       Using <span class=\"keyword\">default</span> npm version: <span class=\"number\">3.10</span><span class=\"number\">.10</span></div><div class=\"line\"></div><div class=\"line\">-----&gt; Restoring cache</div><div class=\"line\">       Loading <span class=\"number\">2</span> from cacheDirectories (<span class=\"keyword\">default</span>):</div><div class=\"line\">       - node_modules</div><div class=\"line\">       - bower_components (not cached - skipping)</div><div class=\"line\">       - nodegyp_lib (not cached - skipping)</div><div class=\"line\"></div><div class=\"line\">-----&gt; Building dependencies</div><div class=\"line\">       Pruning any extraneous modules</div><div class=\"line\">       Installing node modules (package.json)</div><div class=\"line\">       yehot@<span class=\"number\">1.0</span><span class=\"number\">.0</span> /tmp/build</div><div class=\"line\">       `-- formidable@<span class=\"number\">1.0</span><span class=\"number\">.17</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">-----&gt; Caching build</div><div class=\"line\">       Clearing previous node cache</div><div class=\"line\">       Saving <span class=\"number\">2</span> cacheDirectories (<span class=\"keyword\">default</span>):</div><div class=\"line\">       - node_modules</div><div class=\"line\">       - bower_components (nothing to cache)</div><div class=\"line\">       - nodegyp_lib (nothing to cache)</div><div class=\"line\"></div><div class=\"line\">-----&gt; Build succeeded!</div><div class=\"line\">       `-- formidable@<span class=\"number\">1.0</span><span class=\"number\">.17</span></div><div class=\"line\"></div><div class=\"line\">-----&gt; Discovering process types</div><div class=\"line\">       Default types <span class=\"keyword\">for</span>  -&gt; web</div><div class=\"line\">-----&gt; Compiled slug size is <span class=\"number\">16</span>M</div><div class=\"line\">remote: Generating docker image...</div><div class=\"line\">remote: Pushing image registry.docker.sae.sina.com.cn/yehot:c72c679 .....</div><div class=\"line\">remote: 部署程序中 .....</div><div class=\"line\">To https:<span class=\"comment\">//git.sinacloud.com/yehot</span></div><div class=\"line\">   a6b0d8f..c72c679  master -&gt; master</div></pre></td></tr></table></figure>\n<p>到这里构建成功，就算部署成功了。这时我们的 Hello world 页面就可以在你的新浪云 Web 站点看到了：</p>\n<p><img src=\"http://ob7o39x9f.bkt.clouddn.com/14819134008404.jpg\" alt=\"\"></p>\n<p>站点地址可以从这里查看到：</p>\n<p><img src=\"http://ob7o39x9f.bkt.clouddn.com/14819900207625.jpg\" alt=\"\"></p>\n<h2 id=\"四、部署-html-页面\"><a href=\"#四、部署-html-页面\" class=\"headerlink\" title=\"四、部署 html 页面\"></a>四、部署 html 页面</h2><p>1、懒得自己写个页面了，直接用一个网站模板：<a href=\"https://www.oschina.net/news/59924/free-bootstrap-templates\" target=\"_blank\" rel=\"external\">40 个 Bootstrap 网站模板</a> ,随便选一个，把代码压缩包 down 下来</p>\n<p>2、解压，将代码网站模板全部文件拷贝到我们的刚创建的本地 Node 仓库目录里。</p>\n<p>3、这次我们就不是简单的响应个 hello world 的，需要将 html 文本作为页面 send 出去。这里直接使用 node.js 流行框架 <code>Express</code> 帮我们完成这件事。</p>\n<p>首先在代码目录路径下执行命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install express --save</div></pre></td></tr></table></figure>\n<p>这样会在 package.json 中，生成一条依赖信息：</p>\n<p><img src=\"http://ob7o39x9f.bkt.clouddn.com/14819895856109.jpg\" alt=\"\"></p>\n<p>同时，会将 express 的源码从 npm 仓库中拉下来到本地自动生成的 node_modules 目录中。此时目录结构如下：</p>\n<p><img src=\"http://ob7o39x9f.bkt.clouddn.com/14819914963002.jpg\" alt=\"\"></p>\n<p>4、改造 server.js 代码</p>\n<p>工具准备好了，开始使用：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// server.js</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>)</div><div class=\"line\"><span class=\"keyword\">var</span> app = express()</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 静态 html 页面，需要将当前目录下的所有文件都设置为 static</span></div><div class=\"line\">app.use(express.static(__dirname + <span class=\"string\">'/'</span>));</div><div class=\"line\"></div><div class=\"line\">app.get(<span class=\"string\">'/'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'start server'</span>);</div><div class=\"line\">    <span class=\"comment\">// sendFile 函数，在有 request 访问时，将当前目录下的 index.html 文件作为 response 返回</span></div><div class=\"line\">    res.sendFile(__dirname + <span class=\"string\">'/index.html'</span>);</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'start success'</span>);</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 监听 8000 端口</span></div><div class=\"line\">app.listen(process.env.PORT || <span class=\"number\">8000</span>)</div></pre></td></tr></table></figure>\n<p>5、Ok，再次 commit log、push ，等待编译</p>\n<p>编译完成后，刷新我们的站点，就能看到一个漂亮的 html 页面了：</p>\n<p><img src=\"http://ob7o39x9f.bkt.clouddn.com/14819919635022.jpg\" alt=\"\"></p>\n<p>bootstrap 是 Twitter 开源的强大的响应式布局框架，已经帮我们做好了移动端浏览器的适配工作，可以在手机浏览器上访问下试试，效果还是挺不错的。</p>\n<h2 id=\"五、作为服务器接口使用\"><a href=\"#五、作为服务器接口使用\" class=\"headerlink\" title=\"五、作为服务器接口使用\"></a>五、作为服务器接口使用</h2><p>目前我们的 Node 服务，已经成功部署了一个简单的 web 应用。</p>\n<p>我们可以在 iOS 端通过 get 请求访问下我们的站点 <code>http://xxx.applinzi.com</code> 试试，以 AFNetworkign 为例：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">AFHTTPSessionManager *sessionManager = [AFHTTPSessionManager manager];</div><div class=\"line\"></div><div class=\"line\">sessionManager.responseSerializer = [AFHTTPResponseSerializer serializer];</div><div class=\"line\"></div><div class=\"line\">sessionManager.responseSerializer.acceptableContentTypes = [<span class=\"built_in\">NSSet</span> setWithObject:<span class=\"string\">@\"text/html\"</span>];</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">sessionManager.responseSerializer.acceptableContentTypes = [<span class=\"built_in\">NSSet</span> setWithObject:<span class=\"string\">@\"text/html\"</span>];</div><div class=\"line\"></div><div class=\"line\">[sessionManager GET:<span class=\"string\">@\"http://yehot.applinzi.com/index.html\"</span> parameters:<span class=\"literal\">nil</span> progress:<span class=\"literal\">nil</span></div><div class=\"line\"></div><div class=\"line\">success:^(<span class=\"built_in\">NSURLSessionDataTask</span> * _Nonnull task, <span class=\"keyword\">id</span>  _Nullable responseObject) &#123;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>,responseObject);</div><div class=\"line\"></div><div class=\"line\">&#125; failure:^(<span class=\"built_in\">NSURLSessionDataTask</span> * _Nullable task, <span class=\"built_in\">NSError</span> * _Nonnull error) &#123;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>,error);</div><div class=\"line\"></div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<h2 id=\"六、其它\"><a href=\"#六、其它\" class=\"headerlink\" title=\"六、其它\"></a>六、其它</h2><h3 id=\"新浪云控制台使用\"><a href=\"#新浪云控制台使用\" class=\"headerlink\" title=\"新浪云控制台使用\"></a>新浪云控制台使用</h3><p>1、查看操作记录<br><img src=\"http://ob7o39x9f.bkt.clouddn.com/14819090622798.jpg\" alt=\"\"></p>\n<p>2、注册会送 200 云豆 == 2元</p>\n<p>没有额外流量消耗的话，每天默认扣 10 个豆</p>\n<p><img src=\"http://ob7o39x9f.bkt.clouddn.com/14819091585001.jpg\" alt=\"\"></p>\n<p>如果欠费后显示</p>\n<p><img src=\"http://ob7o39x9f.bkt.clouddn.com/14819093138228.jpg\" alt=\"\"></p>\n<p>3、查看日志、重启</p>\n<p><img src=\"http://ob7o39x9f.bkt.clouddn.com/14819095502076.jpg\" alt=\"\"></p>\n<h3 id=\"最后，新浪是有-node-应用的部署指南的\"><a href=\"#最后，新浪是有-node-应用的部署指南的\" class=\"headerlink\" title=\"最后，新浪是有 node 应用的部署指南的\"></a>最后，新浪是有 node 应用的部署指南的</h3><p>上边这些坑，整整折腾了我5个小时后，我才发现这个：</p>\n<p><a href=\"https://www.sinacloud.com/doc/sae/docker/nodejs-getting-started.html\" target=\"_blank\" rel=\"external\">新浪 node 应用部署指南</a></p>\n<p>不说了，都是泪。当然使用 Python、PHP 也可以查看对应的文档<br><a href=\"https://www.sinacloud.com/index/support.html\" target=\"_blank\" rel=\"external\">https://www.sinacloud.com/index/support.html</a></p>\n<h2 id=\"参考：\"><a href=\"#参考：\" class=\"headerlink\" title=\"参考：\"></a>参考：</h2><p><a href=\"http://www.jianshu.com/p/325288166a59\" target=\"_blank\" rel=\"external\">在新浪云上用php+mysql搭建简单后台系列</a></p>\n","excerpt":"","more":"<blockquote>\n<p>阅读本文前，需要对 node.js 、npm、常用 Git 操作、express 有基本的掌握</p>\n</blockquote>\n<h2 id=\"一、准备工作：\"><a href=\"#一、准备工作：\" class=\"headerlink\" title=\"一、准备工作：\"></a>一、准备工作：</h2><h3 id=\"注册号新浪云账号\"><a href=\"#注册号新浪云账号\" class=\"headerlink\" title=\"注册号新浪云账号\"></a>注册号新浪云账号</h3><p>进入 <a href=\"http://www.sinacloud.com/sae.html\">http://www.sinacloud.com/sae.html</a></p>\n<p><img src=\"http://ob7o39x9f.bkt.clouddn.com/14819076463405.jpg\" alt=\"\"></p>\n<p>使用微博账号即可直接登录</p>\n<h3 id=\"创建云应用空间\"><a href=\"#创建云应用空间\" class=\"headerlink\" title=\"创建云应用空间\"></a>创建云应用空间</h3><blockquote>\n<p>所谓云应用空间其实就相当于一个 web 站点 + 一个有完整服务器环境的代码仓库</p>\n</blockquote>\n<p>云应用空间的创建可以参考新浪的文档：<a href=\"http://www.sinacloud.com/home/index/faq_detail/doc_id/83.html\">如何创建一个云空间应用</a></p>\n<p>当然这里需要选择开发语言为 Node.js。</p>\n<p>登陆，然后进入控制台 -&gt; 云应用SAE -&gt; 代码管理</p>\n<p><img src=\"http://ob7o39x9f.bkt.clouddn.com/14819077010650.jpg\" alt=\"\"></p>\n<p><img src=\"http://ob7o39x9f.bkt.clouddn.com/14819077499116.jpg\" alt=\"\"></p>\n<p>以上步骤完成后，我们就有了一个 web 应用站点，这个站点是用来放我们的 html 页面的。准备工作做好了，接下来该配置 Node.js 服务器环境，部署 web 页面上去。</p>\n<h2 id=\"二、Node-js-服务器配置\"><a href=\"#二、Node-js-服务器配置\" class=\"headerlink\" title=\"二、Node.js 服务器配置\"></a>二、Node.js 服务器配置</h2><p>新浪云比较方便的是，即使你对 Node.js 服务器开发没有深入接触过也没关系，新浪云的 Node.js 环境基本是傻瓜式的，即开即用。所以服务器配置，过。</p>\n<h3 id=\"node-js-简单教程\"><a href=\"#node-js-简单教程\" class=\"headerlink\" title=\"node.js 简单教程\"></a>node.js 简单教程</h3><p>安利个 <a href=\"http://www.nodebeginner.org/index-zh-cn.html\">30分钟 Node.js 入门</a> 的教程，完全没有接触过 Node.js 的同学可以快速入门一下。</p>\n<h2 id=\"三、编写-Node-js-服务代码并部署\"><a href=\"#三、编写-Node-js-服务代码并部署\" class=\"headerlink\" title=\"三、编写 Node.js 服务代码并部署\"></a>三、编写 Node.js 服务代码并部署</h2><p>1、先在本地创建一个代码目录，从新浪的 Git 仓库里 clone 出空项目。拉代码的过程很简单，具体可以参考 <a href=\"http://www.sinacloud.com/doc/sae/tutorial/code-deploy.html\">新浪的代码部署手册</a> 文档</p>\n<p><img src=\"http://ob7o39x9f.bkt.clouddn.com/14819889441764.jpg\" alt=\"\"></p>\n<p>2、在本地代码路径下创建一个 server.js 文件，这里我们先使用入门教程里最简单的 Node.js 代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// server.js</span></div><div class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);</div><div class=\"line\"></div><div class=\"line\">http.createServer(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">request, response</span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 发送 HTTP 头部</span></div><div class=\"line\">    <span class=\"comment\">// HTTP 状态值: 200 : OK</span></div><div class=\"line\">    <span class=\"comment\">// 内容类型: text/plain</span></div><div class=\"line\">    response.writeHead(<span class=\"number\">200</span>, &#123;<span class=\"string\">'Content-Type'</span>: <span class=\"string\">'text/plain'</span>&#125;);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 发送响应数据 \"Hello World\"</span></div><div class=\"line\">    response.end(<span class=\"string\">'Hello World\\n'</span>);</div><div class=\"line\">&#125;).listen(<span class=\"number\">8888</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 终端打印如下信息</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'Server running at http://127.0.0.1:8888/'</span>);</div></pre></td></tr></table></figure>\n<p>3、由于新浪的 Node.js 构建环境需要从 package.json 文件中读取配置信息，我们需要创建一个package.json 文件。</p>\n<p>这里我们直接使用 <code>npm init</code> 命令生成一个。 NPM 是 Node Package Manager 的缩写，也就是 Node 包管理器，类似于 iOS 开发中的 CocoaPods，而 <code>npm init</code> 就相当于<code>pod init</code>了.</p>\n<p>在 server.js 文件所在目录上，执行 <code>npm init</code>,按照命令行里的提示一步一步直接敲回车即可。</p>\n<p><img src=\"http://ob7o39x9f.bkt.clouddn.com/14819079662795.jpg\" alt=\"\"></p>\n<p>4、部署</p>\n<p>这里的所谓部署 == 提交代码到新浪云 Git 服务器……</p>\n<p>所以，使用 Git 命令打 commit log，push 代码，等待云端编译即可：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 提交代码</span></div><div class=\"line\">➜  yehot git:(master) ✗ git add .</div><div class=\"line\">➜  yehot git:(master) ✗ git commit -m <span class=\"string\">\"添加package.json\"</span></div><div class=\"line\">[master a6b0d8f] 添加package.json</div><div class=\"line\"> <span class=\"number\">1</span> file changed, <span class=\"number\">20</span> insertions(+)</div><div class=\"line\"> create mode <span class=\"number\">100644</span> package.json</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// push 代码后，自动开始构建</span></div><div class=\"line\">➜  yehot git:(master) ✗ git push sae master</div><div class=\"line\">Counting objects: <span class=\"number\">3</span>, done.</div><div class=\"line\">Delta compression <span class=\"keyword\">using</span> up to <span class=\"number\">4</span> threads.</div><div class=\"line\">Compressing objects: <span class=\"number\">100</span>% (<span class=\"number\">3</span>/<span class=\"number\">3</span>), done.</div><div class=\"line\">Writing objects: <span class=\"number\">100</span>% (<span class=\"number\">3</span>/<span class=\"number\">3</span>), <span class=\"number\">377</span> bytes | <span class=\"number\">0</span> bytes/s, done.</div><div class=\"line\">Total <span class=\"number\">3</span> (delta <span class=\"number\">2</span>), reused <span class=\"number\">0</span> (delta <span class=\"number\">0</span>)</div><div class=\"line\">remote: 导出 Git 代码中...</div><div class=\"line\">remote: 构建程序中...</div><div class=\"line\">-----&gt; Node.js app detected</div><div class=\"line\"></div><div class=\"line\">-----&gt; Creating runtime environment</div><div class=\"line\"></div><div class=\"line\">       NPM_CONFIG_LOGLEVEL=error</div><div class=\"line\">       NPM_CONFIG_PRODUCTION=<span class=\"literal\">true</span></div><div class=\"line\">       NODE_ENV=production</div><div class=\"line\">       NODE_MODULES_CACHE=<span class=\"literal\">true</span></div><div class=\"line\"></div><div class=\"line\">-----&gt; Installing binaries</div><div class=\"line\">       engines.node (package.json):  unspecified</div><div class=\"line\">       engines.npm (package.json):   unspecified (use <span class=\"keyword\">default</span>)</div><div class=\"line\"></div><div class=\"line\">       Resolving node version (latest stable) via semver.io...</div><div class=\"line\">       Downloading and installing node <span class=\"number\">7.2</span><span class=\"number\">.1</span>...</div><div class=\"line\">       Using <span class=\"keyword\">default</span> npm version: <span class=\"number\">3.10</span><span class=\"number\">.10</span></div><div class=\"line\"></div><div class=\"line\">-----&gt; Restoring cache</div><div class=\"line\">       Loading <span class=\"number\">2</span> from cacheDirectories (<span class=\"keyword\">default</span>):</div><div class=\"line\">       - node_modules</div><div class=\"line\">       - bower_components (not cached - skipping)</div><div class=\"line\">       - nodegyp_lib (not cached - skipping)</div><div class=\"line\"></div><div class=\"line\">-----&gt; Building dependencies</div><div class=\"line\">       Pruning any extraneous modules</div><div class=\"line\">       Installing node modules (package.json)</div><div class=\"line\">       yehot@<span class=\"number\">1.0</span><span class=\"number\">.0</span> /tmp/build</div><div class=\"line\">       `-- formidable@<span class=\"number\">1.0</span><span class=\"number\">.17</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">-----&gt; Caching build</div><div class=\"line\">       Clearing previous node cache</div><div class=\"line\">       Saving <span class=\"number\">2</span> cacheDirectories (<span class=\"keyword\">default</span>):</div><div class=\"line\">       - node_modules</div><div class=\"line\">       - bower_components (nothing to cache)</div><div class=\"line\">       - nodegyp_lib (nothing to cache)</div><div class=\"line\"></div><div class=\"line\">-----&gt; Build succeeded!</div><div class=\"line\">       `-- formidable@<span class=\"number\">1.0</span><span class=\"number\">.17</span></div><div class=\"line\"></div><div class=\"line\">-----&gt; Discovering process types</div><div class=\"line\">       Default types <span class=\"keyword\">for</span>  -&gt; web</div><div class=\"line\">-----&gt; Compiled slug size is <span class=\"number\">16</span>M</div><div class=\"line\">remote: Generating docker image...</div><div class=\"line\">remote: Pushing image registry.docker.sae.sina.com.cn/yehot:c72c679 .....</div><div class=\"line\">remote: 部署程序中 .....</div><div class=\"line\">To https:<span class=\"comment\">//git.sinacloud.com/yehot</span></div><div class=\"line\">   a6b0d8f..c72c679  master -&gt; master</div></pre></td></tr></table></figure>\n<p>到这里构建成功，就算部署成功了。这时我们的 Hello world 页面就可以在你的新浪云 Web 站点看到了：</p>\n<p><img src=\"http://ob7o39x9f.bkt.clouddn.com/14819134008404.jpg\" alt=\"\"></p>\n<p>站点地址可以从这里查看到：</p>\n<p><img src=\"http://ob7o39x9f.bkt.clouddn.com/14819900207625.jpg\" alt=\"\"></p>\n<h2 id=\"四、部署-html-页面\"><a href=\"#四、部署-html-页面\" class=\"headerlink\" title=\"四、部署 html 页面\"></a>四、部署 html 页面</h2><p>1、懒得自己写个页面了，直接用一个网站模板：<a href=\"https://www.oschina.net/news/59924/free-bootstrap-templates\">40 个 Bootstrap 网站模板</a> ,随便选一个，把代码压缩包 down 下来</p>\n<p>2、解压，将代码网站模板全部文件拷贝到我们的刚创建的本地 Node 仓库目录里。</p>\n<p>3、这次我们就不是简单的响应个 hello world 的，需要将 html 文本作为页面 send 出去。这里直接使用 node.js 流行框架 <code>Express</code> 帮我们完成这件事。</p>\n<p>首先在代码目录路径下执行命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install express --save</div></pre></td></tr></table></figure>\n<p>这样会在 package.json 中，生成一条依赖信息：</p>\n<p><img src=\"http://ob7o39x9f.bkt.clouddn.com/14819895856109.jpg\" alt=\"\"></p>\n<p>同时，会将 express 的源码从 npm 仓库中拉下来到本地自动生成的 node_modules 目录中。此时目录结构如下：</p>\n<p><img src=\"http://ob7o39x9f.bkt.clouddn.com/14819914963002.jpg\" alt=\"\"></p>\n<p>4、改造 server.js 代码</p>\n<p>工具准备好了，开始使用：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// server.js</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>)</div><div class=\"line\"><span class=\"keyword\">var</span> app = express()</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 静态 html 页面，需要将当前目录下的所有文件都设置为 static</span></div><div class=\"line\">app.use(express.static(__dirname + <span class=\"string\">'/'</span>));</div><div class=\"line\"></div><div class=\"line\">app.get(<span class=\"string\">'/'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'start server'</span>);</div><div class=\"line\">    <span class=\"comment\">// sendFile 函数，在有 request 访问时，将当前目录下的 index.html 文件作为 response 返回</span></div><div class=\"line\">    res.sendFile(__dirname + <span class=\"string\">'/index.html'</span>);</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'start success'</span>);</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 监听 8000 端口</span></div><div class=\"line\">app.listen(process.env.PORT || <span class=\"number\">8000</span>)</div></pre></td></tr></table></figure>\n<p>5、Ok，再次 commit log、push ，等待编译</p>\n<p>编译完成后，刷新我们的站点，就能看到一个漂亮的 html 页面了：</p>\n<p><img src=\"http://ob7o39x9f.bkt.clouddn.com/14819919635022.jpg\" alt=\"\"></p>\n<p>bootstrap 是 Twitter 开源的强大的响应式布局框架，已经帮我们做好了移动端浏览器的适配工作，可以在手机浏览器上访问下试试，效果还是挺不错的。</p>\n<h2 id=\"五、作为服务器接口使用\"><a href=\"#五、作为服务器接口使用\" class=\"headerlink\" title=\"五、作为服务器接口使用\"></a>五、作为服务器接口使用</h2><p>目前我们的 Node 服务，已经成功部署了一个简单的 web 应用。</p>\n<p>我们可以在 iOS 端通过 get 请求访问下我们的站点 <code>http://xxx.applinzi.com</code> 试试，以 AFNetworkign 为例：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">AFHTTPSessionManager *sessionManager = [AFHTTPSessionManager manager];</div><div class=\"line\"></div><div class=\"line\">sessionManager.responseSerializer = [AFHTTPResponseSerializer serializer];</div><div class=\"line\"></div><div class=\"line\">sessionManager.responseSerializer.acceptableContentTypes = [<span class=\"built_in\">NSSet</span> setWithObject:<span class=\"string\">@\"text/html\"</span>];</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">sessionManager.responseSerializer.acceptableContentTypes = [<span class=\"built_in\">NSSet</span> setWithObject:<span class=\"string\">@\"text/html\"</span>];</div><div class=\"line\"></div><div class=\"line\">[sessionManager GET:<span class=\"string\">@\"http://yehot.applinzi.com/index.html\"</span> parameters:<span class=\"literal\">nil</span> progress:<span class=\"literal\">nil</span></div><div class=\"line\"></div><div class=\"line\">success:^(<span class=\"built_in\">NSURLSessionDataTask</span> * _Nonnull task, <span class=\"keyword\">id</span>  _Nullable responseObject) &#123;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>,responseObject);</div><div class=\"line\"></div><div class=\"line\">&#125; failure:^(<span class=\"built_in\">NSURLSessionDataTask</span> * _Nullable task, <span class=\"built_in\">NSError</span> * _Nonnull error) &#123;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>,error);</div><div class=\"line\"></div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<h2 id=\"六、其它\"><a href=\"#六、其它\" class=\"headerlink\" title=\"六、其它\"></a>六、其它</h2><h3 id=\"新浪云控制台使用\"><a href=\"#新浪云控制台使用\" class=\"headerlink\" title=\"新浪云控制台使用\"></a>新浪云控制台使用</h3><p>1、查看操作记录<br><img src=\"http://ob7o39x9f.bkt.clouddn.com/14819090622798.jpg\" alt=\"\"></p>\n<p>2、注册会送 200 云豆 == 2元</p>\n<p>没有额外流量消耗的话，每天默认扣 10 个豆</p>\n<p><img src=\"http://ob7o39x9f.bkt.clouddn.com/14819091585001.jpg\" alt=\"\"></p>\n<p>如果欠费后显示</p>\n<p><img src=\"http://ob7o39x9f.bkt.clouddn.com/14819093138228.jpg\" alt=\"\"></p>\n<p>3、查看日志、重启</p>\n<p><img src=\"http://ob7o39x9f.bkt.clouddn.com/14819095502076.jpg\" alt=\"\"></p>\n<h3 id=\"最后，新浪是有-node-应用的部署指南的\"><a href=\"#最后，新浪是有-node-应用的部署指南的\" class=\"headerlink\" title=\"最后，新浪是有 node 应用的部署指南的\"></a>最后，新浪是有 node 应用的部署指南的</h3><p>上边这些坑，整整折腾了我5个小时后，我才发现这个：</p>\n<p><a href=\"https://www.sinacloud.com/doc/sae/docker/nodejs-getting-started.html\">新浪 node 应用部署指南</a></p>\n<p>不说了，都是泪。当然使用 Python、PHP 也可以查看对应的文档<br><a href=\"https://www.sinacloud.com/index/support.html\">https://www.sinacloud.com/index/support.html</a></p>\n<h2 id=\"参考：\"><a href=\"#参考：\" class=\"headerlink\" title=\"参考：\"></a>参考：</h2><p><a href=\"http://www.jianshu.com/p/325288166a59\">在新浪云上用php+mysql搭建简单后台系列</a></p>\n"},{"title":"Git常用命令清单","date":"2017-02-15T14:33:01.000Z","_content":"\n![目录](http://upload-images.jianshu.io/upload_images/332029-53b2e99ec9b33e76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n之前一直借助于 Source-tree 这种图形化 Git 工具，一次在帮同事解决 Git 分支合并问题时，用的同事电脑，没有 Source-tree ，感觉完全不会用了，什么命令也没记住。恶补一下命令，重新学一遍 Git 教程，发现好多常用的操作，用命令还是非常方便的。\n这里整理汇总下：\n\n## 一、Git alias\n\n在开始常用命令前，先推荐下使用 alias 定义 git 常用命令的别名，合理使用简写可以大幅提高效率。\n\n常用 git 命令，可以在 `~/.gitconfig` 文件中使用 alias 定义简写，以下是我个人常用 alias:\n\n```js\n[alias]\n    st = status -s\n    ci = commit\n    l  = log --oneline --decorate -12 --color\n    ll = log --oneline --decorate --color\n    lc = log --graph --color\n    co = checkout\n    br = branch\n    ba = branch -a\n    rb = rebase\n    dci = dcommit\n    lg = log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit\n```\n\n> 另，`~/.gitconfig` 文件中，可以查看当前 user 的 git 配置信息\n\n## 二、branch 分支操作\n\n### 查看分支信息\n\n```js\n\n# 列出所有本地分支\n// git br\n$ git branch\n\n# 列出所有本地分支和远程分支\n// git ba\n$ git branch -a\n```\n\n### 新建分支\n\n```js\n# 从当前分支新建一个分支。但依然停留在当前分支\n// git br [本地xxx]\n$ git branch [branch-name]\n// 常用于：对当前 分支做个备份\n\n# 从指定的远程分支，拉一个本地分支。并切换到该分支\n// 常用于： 从远端 develop 拉一个 本地 feature/xxx 分支\n$ git checkout -b newBrach origin/master\n\n# 新建一个分支，指向指定commit。但依然停留在当前分支\n$ git branch [branch] [commit]\n\n# 新建一个分支。并切换到该分支\n// git co -b [local or remote/branch-name]\n$ git checkout -b [branch-name]\n\n# 新建一个分支，指向某个tag\n$ git checkout -b [branch] [tag]\n```\n\n### 切换分支\n\n```js\n# 切换到指定分支，并更新工作区\n// git co [branch-name]\n$ git checkout [branch-name]\n\n# 切换到上一个分支\n$ git checkout -\n```\n\n### 删除分支\n\n```js\n# 删除本地分支\n// git br -d [branch-name]]\n$ git branch -d [branch-name]\n$ git branch -D //强制删除\n\n# 删除远程分支\n// git br -dr [remote/branch]\n// eg:  git br -dr origin/xxx_name\n$ git branch -dr [remote/branch]\n```\n\n### 合并分支\n\n```js\n# 合并指定分支到当前分支\n$ git merge [branch]\n\n# 选择一个commit，合并进当前分支\n$ git cherry-pick [commit]\n```\n\n\n## 三、tag 分支操作\n\n在 Git 中 tag 可以看做是指向某个 commit 的特殊分支\n\n### 列显已有 tag\n\n```js\n$ git tag\n```\n\n### 添加 tag\n\n```js\n$ git tag v1.4.0\n\n// 添加一个带 commit log 的 tag\n$ git tag -a v1.4 -m 'my version 1.4'\n\n// 为某个指定的 commit 打上 tag\n$ git tag -a v1.2 9fceb02\n\n// 查看 tag 信息\n$ git show v1.4\n```\n\n### 推送 tag\n\n```js\n// git push 不会将本地的 tag push 到 origin\n\n# push 指定 tag name\n$ git push origin v1.0\n# push 全部 tag\n$ git push origin --tags\n```\n\n### 删除 tag\n\n```js\n// 删除本地 tag\n$ git tag -d v0.9\n\n// 删除远端 tag\n$ git push origin :refs/tags/0.1.0\n## 明确的表示删除\n$ git push --delete origin v1.1\n```\n\n## 四、git pull\n\ngit pull命令的作用是，取回远程主机某个分支的更新，再与本地的指定分支合并。\n\n### Merge 型 的 pull\n\n> 如果本地分支，在 checkout 后，有 commit， git pull 就会增加一个 Merge log\n> 如果本地分支没有 新 commit，等于直接 fetch、pull\n\n![](http://upload-images.jianshu.io/upload_images/332029-6510e80758bdf307.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n```git\n\n// 将远端的 A 分支的代码，拉到本地 B 分支 (会产生一个 Merge log)\n$ git pull origin [remote_name]:[local_name]\n// 如果是往当前 本地分支 pull，则冒号后面的部分可以省略\n$ git pull origin [remote_name]\n\n\n// 实质上，这等同于先做git fetch，再做git merge。\n$ git fetch origin\n$ git merge origin/next\n\n# Git会自动在本地分支与远程分支之间，建立一种追踪关系（tracking）。 就是说，本地的master分支自动\"追踪\"origin/master分支。\n\n// 如果当前分支与远程分支存在追踪关系，git pull就可以省略远程分支名。\n$ git pull origin\n\n// 如果当前分支只有一个追踪分支，连远程主机名都可以省略。\n$ git pull\n// 上面命令表示，当前分支自动与唯一一个追踪分支进行合并\n\n```\n\n### rebase 型 pull\n\n```js\n\n// 如果合并需要采用rebase模式，可以使用--rebase选项。\n$ git pull --rebase <远程主机名> <远程分支名>:<本地分支名>\n// git pull --rebase origin [origin_name]:[local_name]\n\n// 如果是 rebase 到当前分支，可省略 ： 后\n$ git pull --rebase origin [origin_name]\n// 如果 rebase 的远端分支，是当前分支 track 的，[origin_name] 可省略\n$ git pull --rebase origin\n\n```\n\n\n## 五、Git push\n\n\n```js\n// 将当前 loca_name 分支 push 到远端，命名为 new_name\n$ git push <远程主机名> <本地分支名>:<远程分支名>\n// git push origin loca_name:new_name\n\n# 如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。\n# 如果当前分支只有一个追踪分支，那么主机名都可以省略。\n// 会将本地所有分支都 对应 push （慎用）\n$ git push\n\n// push 可以用来删除\n$ git push origin --delete master\n\n# 如果远程主机的版本比本地版本更新，推送时Git会报错，要求先在本地做git pull合并差异，然后再推送到远程主机。这时，如果你一定要推送，可以使用--force选项。\n$ git push --force origin\n\n# 最后，git push不会推送标签（tag），除非使用--tags选项。\n$ git push origin --tags\n\n```\n\n\n## 六、代码回滚\n\n### 快速合并缓存区到上一个 commit\n\n```js\n// 将 add 到缓存区的内容，和上一个 commit 一起， rebase 成了一个新的 commit\n$ git commit --amend\n\n// 便于将漏修改的，或是修改错误的内容，合并到上一个 commit 中。而不用提交两个 commit，然后 rebase 成一个\n// 注：如果修改过了， 只能 push -f 到远端\n```\n\n### checkout 到指定 commit\n\n这对于快速查看项目旧版本来说非常有用\n\n```js\n$ git checkout [commit id]\n\n// check 到往前指定此的 commit\n$ git checkout HEAD~2\n```\n\n### git Revert\n\nRevert撤销一个提交的同时会创建一个新的提交。\n\n```js\n# 新建一个commit，用来撤销指定commit\n# 后者的所有变化都将被前者抵消，并且应用到当前分支\n$ git revert [commit]\n```\n\n### git reset\n\n- 将已经加到缓存区的内容（仅打了本地 commit），移除到工作区\n\n```\n$ git reset HEAD\n\n$ git reset HEAD~2\n```\n\n- 从缓存区重置，不删除修改的地方\n\n```js\n// 将缓存区中的指定文件，移到工作区\n// 缓存区中的，指的是 add 后的\ngit reset <file>\n\n// 将缓存区中的全部文件，移到工作区\n$ git reset\n\n// 将本地 commit 历史中的 commit 移除到 工作区 （未 add 状态）\n$ git reset [commit_id]\n```\n\n### 删除式 reset\n\n```js\n// 缓存区和工作区的，都会被完全移除（删除）\n$ git reset --hard\n\n// 将本地 commit 历史中的直接删除\n$ git reset --hard <commit>\n\n# 重置当前HEAD为指定commit，但保持暂存区和工作区不变\n$ git reset --keep [commit]\n```\n\n参考：\n[常用 Git 命令清单 - 阮一峰](http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html)\n[Git远程操作详解 - 阮一峰](http://www.ruanyifeng.com/blog/2014/06/git_remote.html)\n[Git 配置别名 - 廖雪峰](http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001375234012342f90be1fc4d81446c967bbdc19e7c03d3000)\n[果壳中的 Git](https://github.com/geeeeeeeeek/git-recipes/wiki)\n\n特别推荐：\n[ jaywcjlove —— Git常用命令清单](https://github.com/jaywcjlove/handbook/blob/master/other/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B8%85%E5%8D%95.md)\n","source":"_posts/20170215-git-order-list.md","raw":"---\ntitle: Git常用命令清单\ndate: 2017-02-15 22:33:01\ntags: git\n---\n\n![目录](http://upload-images.jianshu.io/upload_images/332029-53b2e99ec9b33e76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n之前一直借助于 Source-tree 这种图形化 Git 工具，一次在帮同事解决 Git 分支合并问题时，用的同事电脑，没有 Source-tree ，感觉完全不会用了，什么命令也没记住。恶补一下命令，重新学一遍 Git 教程，发现好多常用的操作，用命令还是非常方便的。\n这里整理汇总下：\n\n## 一、Git alias\n\n在开始常用命令前，先推荐下使用 alias 定义 git 常用命令的别名，合理使用简写可以大幅提高效率。\n\n常用 git 命令，可以在 `~/.gitconfig` 文件中使用 alias 定义简写，以下是我个人常用 alias:\n\n```js\n[alias]\n    st = status -s\n    ci = commit\n    l  = log --oneline --decorate -12 --color\n    ll = log --oneline --decorate --color\n    lc = log --graph --color\n    co = checkout\n    br = branch\n    ba = branch -a\n    rb = rebase\n    dci = dcommit\n    lg = log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit\n```\n\n> 另，`~/.gitconfig` 文件中，可以查看当前 user 的 git 配置信息\n\n## 二、branch 分支操作\n\n### 查看分支信息\n\n```js\n\n# 列出所有本地分支\n// git br\n$ git branch\n\n# 列出所有本地分支和远程分支\n// git ba\n$ git branch -a\n```\n\n### 新建分支\n\n```js\n# 从当前分支新建一个分支。但依然停留在当前分支\n// git br [本地xxx]\n$ git branch [branch-name]\n// 常用于：对当前 分支做个备份\n\n# 从指定的远程分支，拉一个本地分支。并切换到该分支\n// 常用于： 从远端 develop 拉一个 本地 feature/xxx 分支\n$ git checkout -b newBrach origin/master\n\n# 新建一个分支，指向指定commit。但依然停留在当前分支\n$ git branch [branch] [commit]\n\n# 新建一个分支。并切换到该分支\n// git co -b [local or remote/branch-name]\n$ git checkout -b [branch-name]\n\n# 新建一个分支，指向某个tag\n$ git checkout -b [branch] [tag]\n```\n\n### 切换分支\n\n```js\n# 切换到指定分支，并更新工作区\n// git co [branch-name]\n$ git checkout [branch-name]\n\n# 切换到上一个分支\n$ git checkout -\n```\n\n### 删除分支\n\n```js\n# 删除本地分支\n// git br -d [branch-name]]\n$ git branch -d [branch-name]\n$ git branch -D //强制删除\n\n# 删除远程分支\n// git br -dr [remote/branch]\n// eg:  git br -dr origin/xxx_name\n$ git branch -dr [remote/branch]\n```\n\n### 合并分支\n\n```js\n# 合并指定分支到当前分支\n$ git merge [branch]\n\n# 选择一个commit，合并进当前分支\n$ git cherry-pick [commit]\n```\n\n\n## 三、tag 分支操作\n\n在 Git 中 tag 可以看做是指向某个 commit 的特殊分支\n\n### 列显已有 tag\n\n```js\n$ git tag\n```\n\n### 添加 tag\n\n```js\n$ git tag v1.4.0\n\n// 添加一个带 commit log 的 tag\n$ git tag -a v1.4 -m 'my version 1.4'\n\n// 为某个指定的 commit 打上 tag\n$ git tag -a v1.2 9fceb02\n\n// 查看 tag 信息\n$ git show v1.4\n```\n\n### 推送 tag\n\n```js\n// git push 不会将本地的 tag push 到 origin\n\n# push 指定 tag name\n$ git push origin v1.0\n# push 全部 tag\n$ git push origin --tags\n```\n\n### 删除 tag\n\n```js\n// 删除本地 tag\n$ git tag -d v0.9\n\n// 删除远端 tag\n$ git push origin :refs/tags/0.1.0\n## 明确的表示删除\n$ git push --delete origin v1.1\n```\n\n## 四、git pull\n\ngit pull命令的作用是，取回远程主机某个分支的更新，再与本地的指定分支合并。\n\n### Merge 型 的 pull\n\n> 如果本地分支，在 checkout 后，有 commit， git pull 就会增加一个 Merge log\n> 如果本地分支没有 新 commit，等于直接 fetch、pull\n\n![](http://upload-images.jianshu.io/upload_images/332029-6510e80758bdf307.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n```git\n\n// 将远端的 A 分支的代码，拉到本地 B 分支 (会产生一个 Merge log)\n$ git pull origin [remote_name]:[local_name]\n// 如果是往当前 本地分支 pull，则冒号后面的部分可以省略\n$ git pull origin [remote_name]\n\n\n// 实质上，这等同于先做git fetch，再做git merge。\n$ git fetch origin\n$ git merge origin/next\n\n# Git会自动在本地分支与远程分支之间，建立一种追踪关系（tracking）。 就是说，本地的master分支自动\"追踪\"origin/master分支。\n\n// 如果当前分支与远程分支存在追踪关系，git pull就可以省略远程分支名。\n$ git pull origin\n\n// 如果当前分支只有一个追踪分支，连远程主机名都可以省略。\n$ git pull\n// 上面命令表示，当前分支自动与唯一一个追踪分支进行合并\n\n```\n\n### rebase 型 pull\n\n```js\n\n// 如果合并需要采用rebase模式，可以使用--rebase选项。\n$ git pull --rebase <远程主机名> <远程分支名>:<本地分支名>\n// git pull --rebase origin [origin_name]:[local_name]\n\n// 如果是 rebase 到当前分支，可省略 ： 后\n$ git pull --rebase origin [origin_name]\n// 如果 rebase 的远端分支，是当前分支 track 的，[origin_name] 可省略\n$ git pull --rebase origin\n\n```\n\n\n## 五、Git push\n\n\n```js\n// 将当前 loca_name 分支 push 到远端，命名为 new_name\n$ git push <远程主机名> <本地分支名>:<远程分支名>\n// git push origin loca_name:new_name\n\n# 如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。\n# 如果当前分支只有一个追踪分支，那么主机名都可以省略。\n// 会将本地所有分支都 对应 push （慎用）\n$ git push\n\n// push 可以用来删除\n$ git push origin --delete master\n\n# 如果远程主机的版本比本地版本更新，推送时Git会报错，要求先在本地做git pull合并差异，然后再推送到远程主机。这时，如果你一定要推送，可以使用--force选项。\n$ git push --force origin\n\n# 最后，git push不会推送标签（tag），除非使用--tags选项。\n$ git push origin --tags\n\n```\n\n\n## 六、代码回滚\n\n### 快速合并缓存区到上一个 commit\n\n```js\n// 将 add 到缓存区的内容，和上一个 commit 一起， rebase 成了一个新的 commit\n$ git commit --amend\n\n// 便于将漏修改的，或是修改错误的内容，合并到上一个 commit 中。而不用提交两个 commit，然后 rebase 成一个\n// 注：如果修改过了， 只能 push -f 到远端\n```\n\n### checkout 到指定 commit\n\n这对于快速查看项目旧版本来说非常有用\n\n```js\n$ git checkout [commit id]\n\n// check 到往前指定此的 commit\n$ git checkout HEAD~2\n```\n\n### git Revert\n\nRevert撤销一个提交的同时会创建一个新的提交。\n\n```js\n# 新建一个commit，用来撤销指定commit\n# 后者的所有变化都将被前者抵消，并且应用到当前分支\n$ git revert [commit]\n```\n\n### git reset\n\n- 将已经加到缓存区的内容（仅打了本地 commit），移除到工作区\n\n```\n$ git reset HEAD\n\n$ git reset HEAD~2\n```\n\n- 从缓存区重置，不删除修改的地方\n\n```js\n// 将缓存区中的指定文件，移到工作区\n// 缓存区中的，指的是 add 后的\ngit reset <file>\n\n// 将缓存区中的全部文件，移到工作区\n$ git reset\n\n// 将本地 commit 历史中的 commit 移除到 工作区 （未 add 状态）\n$ git reset [commit_id]\n```\n\n### 删除式 reset\n\n```js\n// 缓存区和工作区的，都会被完全移除（删除）\n$ git reset --hard\n\n// 将本地 commit 历史中的直接删除\n$ git reset --hard <commit>\n\n# 重置当前HEAD为指定commit，但保持暂存区和工作区不变\n$ git reset --keep [commit]\n```\n\n参考：\n[常用 Git 命令清单 - 阮一峰](http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html)\n[Git远程操作详解 - 阮一峰](http://www.ruanyifeng.com/blog/2014/06/git_remote.html)\n[Git 配置别名 - 廖雪峰](http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001375234012342f90be1fc4d81446c967bbdc19e7c03d3000)\n[果壳中的 Git](https://github.com/geeeeeeeeek/git-recipes/wiki)\n\n特别推荐：\n[ jaywcjlove —— Git常用命令清单](https://github.com/jaywcjlove/handbook/blob/master/other/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B8%85%E5%8D%95.md)\n","slug":"20170215-git-order-list","published":1,"updated":"2017-03-10T05:35:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj03ftfnz00067womfeutcktp","content":"<p><img src=\"http://upload-images.jianshu.io/upload_images/332029-53b2e99ec9b33e76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"目录\"></p>\n<p>之前一直借助于 Source-tree 这种图形化 Git 工具，一次在帮同事解决 Git 分支合并问题时，用的同事电脑，没有 Source-tree ，感觉完全不会用了，什么命令也没记住。恶补一下命令，重新学一遍 Git 教程，发现好多常用的操作，用命令还是非常方便的。<br>这里整理汇总下：</p>\n<h2 id=\"一、Git-alias\"><a href=\"#一、Git-alias\" class=\"headerlink\" title=\"一、Git alias\"></a>一、Git alias</h2><p>在开始常用命令前，先推荐下使用 alias 定义 git 常用命令的别名，合理使用简写可以大幅提高效率。</p>\n<p>常用 git 命令，可以在 <code>~/.gitconfig</code> 文件中使用 alias 定义简写，以下是我个人常用 alias:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">[alias]</div><div class=\"line\">    st = status -s</div><div class=\"line\">    ci = commit</div><div class=\"line\">    l  = log --oneline --decorate <span class=\"number\">-12</span> --color</div><div class=\"line\">    ll = log --oneline --decorate --color</div><div class=\"line\">    lc = log --graph --color</div><div class=\"line\">    co = checkout</div><div class=\"line\">    br = branch</div><div class=\"line\">    ba = branch -a</div><div class=\"line\">    rb = rebase</div><div class=\"line\">    dci = dcommit</div><div class=\"line\">    lg = log --color --graph --pretty=format:<span class=\"string\">'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset'</span> --abbrev-commit</div></pre></td></tr></table></figure>\n<blockquote>\n<p>另，<code>~/.gitconfig</code> 文件中，可以查看当前 user 的 git 配置信息</p>\n</blockquote>\n<h2 id=\"二、branch-分支操作\"><a href=\"#二、branch-分支操作\" class=\"headerlink\" title=\"二、branch 分支操作\"></a>二、branch 分支操作</h2><h3 id=\"查看分支信息\"><a href=\"#查看分支信息\" class=\"headerlink\" title=\"查看分支信息\"></a>查看分支信息</h3><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"># 列出所有本地分支</div><div class=\"line\">// git br</div><div class=\"line\">$ git branch</div><div class=\"line\"></div><div class=\"line\"># 列出所有本地分支和远程分支</div><div class=\"line\">// git ba</div><div class=\"line\">$ git branch -a</div></pre></td></tr></table></figure>\n<h3 id=\"新建分支\"><a href=\"#新建分支\" class=\"headerlink\" title=\"新建分支\"></a>新建分支</h3><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 从当前分支新建一个分支。但依然停留在当前分支</div><div class=\"line\">// git br [本地xxx]</div><div class=\"line\">$ git branch [branch-name]</div><div class=\"line\">// 常用于：对当前 分支做个备份</div><div class=\"line\"></div><div class=\"line\"># 从指定的远程分支，拉一个本地分支。并切换到该分支</div><div class=\"line\">// 常用于： 从远端 develop 拉一个 本地 feature/xxx 分支</div><div class=\"line\">$ git checkout -b newBrach origin/master</div><div class=\"line\"></div><div class=\"line\"># 新建一个分支，指向指定commit。但依然停留在当前分支</div><div class=\"line\">$ git branch [branch] [commit]</div><div class=\"line\"></div><div class=\"line\"># 新建一个分支。并切换到该分支</div><div class=\"line\">// git co -b [local or remote/branch-name]</div><div class=\"line\">$ git checkout -b [branch-name]</div><div class=\"line\"></div><div class=\"line\"># 新建一个分支，指向某个tag</div><div class=\"line\">$ git checkout -b [branch] [tag]</div></pre></td></tr></table></figure>\n<h3 id=\"切换分支\"><a href=\"#切换分支\" class=\"headerlink\" title=\"切换分支\"></a>切换分支</h3><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 切换到指定分支，并更新工作区</div><div class=\"line\">// git co [branch-name]</div><div class=\"line\">$ git checkout [branch-name]</div><div class=\"line\"></div><div class=\"line\"># 切换到上一个分支</div><div class=\"line\">$ git checkout -</div></pre></td></tr></table></figure>\n<h3 id=\"删除分支\"><a href=\"#删除分支\" class=\"headerlink\" title=\"删除分支\"></a>删除分支</h3><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 删除本地分支</div><div class=\"line\">// git br -d [branch-name]]</div><div class=\"line\">$ git branch -d [branch-name]</div><div class=\"line\">$ git branch -D //强制删除</div><div class=\"line\"></div><div class=\"line\"># 删除远程分支</div><div class=\"line\">// git br -dr [remote/branch]</div><div class=\"line\">// eg:  git br -dr origin/xxx_name</div><div class=\"line\">$ git branch -dr [remote/branch]</div></pre></td></tr></table></figure>\n<h3 id=\"合并分支\"><a href=\"#合并分支\" class=\"headerlink\" title=\"合并分支\"></a>合并分支</h3><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 合并指定分支到当前分支</div><div class=\"line\">$ git merge [branch]</div><div class=\"line\"></div><div class=\"line\"># 选择一个commit，合并进当前分支</div><div class=\"line\">$ git cherry-pick [commit]</div></pre></td></tr></table></figure>\n<h2 id=\"三、tag-分支操作\"><a href=\"#三、tag-分支操作\" class=\"headerlink\" title=\"三、tag 分支操作\"></a>三、tag 分支操作</h2><p>在 Git 中 tag 可以看做是指向某个 commit 的特殊分支</p>\n<h3 id=\"列显已有-tag\"><a href=\"#列显已有-tag\" class=\"headerlink\" title=\"列显已有 tag\"></a>列显已有 tag</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git tag</div></pre></td></tr></table></figure>\n<h3 id=\"添加-tag\"><a href=\"#添加-tag\" class=\"headerlink\" title=\"添加 tag\"></a>添加 tag</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git tag v1<span class=\"number\">.4</span><span class=\"number\">.0</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 添加一个带 commit log 的 tag</span></div><div class=\"line\">$ git tag -a v1<span class=\"number\">.4</span> -m <span class=\"string\">'my version 1.4'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 为某个指定的 commit 打上 tag</span></div><div class=\"line\">$ git tag -a v1<span class=\"number\">.2</span> <span class=\"number\">9</span>fceb02</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 查看 tag 信息</span></div><div class=\"line\">$ git show v1<span class=\"number\">.4</span></div></pre></td></tr></table></figure>\n<h3 id=\"推送-tag\"><a href=\"#推送-tag\" class=\"headerlink\" title=\"推送 tag\"></a>推送 tag</h3><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">// git push 不会将本地的 tag push 到 origin</div><div class=\"line\"></div><div class=\"line\"># push 指定 tag name</div><div class=\"line\">$ git push origin v1.0</div><div class=\"line\"># push 全部 tag</div><div class=\"line\">$ git push origin --tags</div></pre></td></tr></table></figure>\n<h3 id=\"删除-tag\"><a href=\"#删除-tag\" class=\"headerlink\" title=\"删除 tag\"></a>删除 tag</h3><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 删除本地 tag</div><div class=\"line\">$ git tag -d v0.9</div><div class=\"line\"></div><div class=\"line\">// 删除远端 tag</div><div class=\"line\">$ git push origin :refs/tags/0.1.0</div><div class=\"line\">## 明确的表示删除</div><div class=\"line\">$ git push --delete origin v1.1</div></pre></td></tr></table></figure>\n<h2 id=\"四、git-pull\"><a href=\"#四、git-pull\" class=\"headerlink\" title=\"四、git pull\"></a>四、git pull</h2><p>git pull命令的作用是，取回远程主机某个分支的更新，再与本地的指定分支合并。</p>\n<h3 id=\"Merge-型-的-pull\"><a href=\"#Merge-型-的-pull\" class=\"headerlink\" title=\"Merge 型 的 pull\"></a>Merge 型 的 pull</h3><blockquote>\n<p>如果本地分支，在 checkout 后，有 commit， git pull 就会增加一个 Merge log<br>如果本地分支没有 新 commit，等于直接 fetch、pull</p>\n</blockquote>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/332029-6510e80758bdf307.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">// 将远端的 A 分支的代码，拉到本地 B 分支 (会产生一个 Merge log)</div><div class=\"line\">$ git pull origin [remote_name]:[local_name]</div><div class=\"line\">// 如果是往当前 本地分支 pull，则冒号后面的部分可以省略</div><div class=\"line\">$ git pull origin [remote_name]</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">// 实质上，这等同于先做git fetch，再做git merge。</div><div class=\"line\">$ git fetch origin</div><div class=\"line\">$ git merge origin/next</div><div class=\"line\"></div><div class=\"line\"># Git会自动在本地分支与远程分支之间，建立一种追踪关系（tracking）。 就是说，本地的master分支自动&quot;追踪&quot;origin/master分支。</div><div class=\"line\"></div><div class=\"line\">// 如果当前分支与远程分支存在追踪关系，git pull就可以省略远程分支名。</div><div class=\"line\">$ git pull origin</div><div class=\"line\"></div><div class=\"line\">// 如果当前分支只有一个追踪分支，连远程主机名都可以省略。</div><div class=\"line\">$ git pull</div><div class=\"line\">// 上面命令表示，当前分支自动与唯一一个追踪分支进行合并</div></pre></td></tr></table></figure>\n<h3 id=\"rebase-型-pull\"><a href=\"#rebase-型-pull\" class=\"headerlink\" title=\"rebase 型 pull\"></a>rebase 型 pull</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 如果合并需要采用rebase模式，可以使用--rebase选项。</span></div><div class=\"line\">$ git pull --rebase &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</div><div class=\"line\">// git pull --rebase origin [origin_name]:[local_name]</div><div class=\"line\"></div><div class=\"line\">// 如果是 rebase 到当前分支，可省略 ： 后</div><div class=\"line\">$ git pull --rebase origin [origin_name]</div><div class=\"line\">// 如果 rebase 的远端分支，是当前分支 track 的，[origin_name] 可省略</div><div class=\"line\">$ git pull --rebase origin</div></pre></td></tr></table></figure>\n<h2 id=\"五、Git-push\"><a href=\"#五、Git-push\" class=\"headerlink\" title=\"五、Git push\"></a>五、Git push</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 将当前 loca_name 分支 push 到远端，命名为 new_name</span></div><div class=\"line\">$ git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</div><div class=\"line\">// git push origin loca_name:new_name</div><div class=\"line\"></div><div class=\"line\"># 如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。</div><div class=\"line\"># 如果当前分支只有一个追踪分支，那么主机名都可以省略。</div><div class=\"line\">// 会将本地所有分支都 对应 push （慎用）</div><div class=\"line\">$ git push</div><div class=\"line\"></div><div class=\"line\">// push 可以用来删除</div><div class=\"line\">$ git push origin --delete master</div><div class=\"line\"></div><div class=\"line\"># 如果远程主机的版本比本地版本更新，推送时Git会报错，要求先在本地做git pull合并差异，然后再推送到远程主机。这时，如果你一定要推送，可以使用--force选项。</div><div class=\"line\">$ git push --force origin</div><div class=\"line\"></div><div class=\"line\"># 最后，git push不会推送标签（tag），除非使用--tags选项。</div><div class=\"line\">$ git push origin --tags</div></pre></td></tr></table></figure>\n<h2 id=\"六、代码回滚\"><a href=\"#六、代码回滚\" class=\"headerlink\" title=\"六、代码回滚\"></a>六、代码回滚</h2><h3 id=\"快速合并缓存区到上一个-commit\"><a href=\"#快速合并缓存区到上一个-commit\" class=\"headerlink\" title=\"快速合并缓存区到上一个 commit\"></a>快速合并缓存区到上一个 commit</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 将 add 到缓存区的内容，和上一个 commit 一起， rebase 成了一个新的 commit</span></div><div class=\"line\">$ git commit --amend</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 便于将漏修改的，或是修改错误的内容，合并到上一个 commit 中。而不用提交两个 commit，然后 rebase 成一个</span></div><div class=\"line\"><span class=\"comment\">// 注：如果修改过了， 只能 push -f 到远端</span></div></pre></td></tr></table></figure>\n<h3 id=\"checkout-到指定-commit\"><a href=\"#checkout-到指定-commit\" class=\"headerlink\" title=\"checkout 到指定 commit\"></a>checkout 到指定 commit</h3><p>这对于快速查看项目旧版本来说非常有用</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git checkout [commit id]</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// check 到往前指定此的 commit</span></div><div class=\"line\">$ git checkout HEAD~<span class=\"number\">2</span></div></pre></td></tr></table></figure>\n<h3 id=\"git-Revert\"><a href=\"#git-Revert\" class=\"headerlink\" title=\"git Revert\"></a>git Revert</h3><p>Revert撤销一个提交的同时会创建一个新的提交。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 新建一个commit，用来撤销指定commit</div><div class=\"line\"># 后者的所有变化都将被前者抵消，并且应用到当前分支</div><div class=\"line\">$ git revert [commit]</div></pre></td></tr></table></figure>\n<h3 id=\"git-reset\"><a href=\"#git-reset\" class=\"headerlink\" title=\"git reset\"></a>git reset</h3><ul>\n<li>将已经加到缓存区的内容（仅打了本地 commit），移除到工作区</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git reset HEAD</div><div class=\"line\"></div><div class=\"line\">$ git reset HEAD~2</div></pre></td></tr></table></figure>\n<ul>\n<li>从缓存区重置，不删除修改的地方</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 将缓存区中的指定文件，移到工作区</span></div><div class=\"line\"><span class=\"comment\">// 缓存区中的，指的是 add 后的</span></div><div class=\"line\">git reset &lt;file&gt;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 将缓存区中的全部文件，移到工作区</span></div><div class=\"line\">$ git reset</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 将本地 commit 历史中的 commit 移除到 工作区 （未 add 状态）</span></div><div class=\"line\">$ git reset [commit_id]</div></pre></td></tr></table></figure>\n<h3 id=\"删除式-reset\"><a href=\"#删除式-reset\" class=\"headerlink\" title=\"删除式 reset\"></a>删除式 reset</h3><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 缓存区和工作区的，都会被完全移除（删除）</div><div class=\"line\">$ git reset --hard</div><div class=\"line\"></div><div class=\"line\">// 将本地 commit 历史中的直接删除</div><div class=\"line\">$ git reset --hard &lt;commit&gt;</div><div class=\"line\"></div><div class=\"line\"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</div><div class=\"line\">$ git reset --keep [commit]</div></pre></td></tr></table></figure>\n<p>参考：<br><a href=\"http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html\" target=\"_blank\" rel=\"external\">常用 Git 命令清单 - 阮一峰</a><br><a href=\"http://www.ruanyifeng.com/blog/2014/06/git_remote.html\" target=\"_blank\" rel=\"external\">Git远程操作详解 - 阮一峰</a><br><a href=\"http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001375234012342f90be1fc4d81446c967bbdc19e7c03d3000\" target=\"_blank\" rel=\"external\">Git 配置别名 - 廖雪峰</a><br><a href=\"https://github.com/geeeeeeeeek/git-recipes/wiki\" target=\"_blank\" rel=\"external\">果壳中的 Git</a></p>\n<p>特别推荐：<br><a href=\"https://github.com/jaywcjlove/handbook/blob/master/other/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B8%85%E5%8D%95.md\" target=\"_blank\" rel=\"external\"> jaywcjlove —— Git常用命令清单</a></p>\n","excerpt":"","more":"<p><img src=\"http://upload-images.jianshu.io/upload_images/332029-53b2e99ec9b33e76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"目录\"></p>\n<p>之前一直借助于 Source-tree 这种图形化 Git 工具，一次在帮同事解决 Git 分支合并问题时，用的同事电脑，没有 Source-tree ，感觉完全不会用了，什么命令也没记住。恶补一下命令，重新学一遍 Git 教程，发现好多常用的操作，用命令还是非常方便的。<br>这里整理汇总下：</p>\n<h2 id=\"一、Git-alias\"><a href=\"#一、Git-alias\" class=\"headerlink\" title=\"一、Git alias\"></a>一、Git alias</h2><p>在开始常用命令前，先推荐下使用 alias 定义 git 常用命令的别名，合理使用简写可以大幅提高效率。</p>\n<p>常用 git 命令，可以在 <code>~/.gitconfig</code> 文件中使用 alias 定义简写，以下是我个人常用 alias:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">[alias]</div><div class=\"line\">    st = status -s</div><div class=\"line\">    ci = commit</div><div class=\"line\">    l  = log --oneline --decorate <span class=\"number\">-12</span> --color</div><div class=\"line\">    ll = log --oneline --decorate --color</div><div class=\"line\">    lc = log --graph --color</div><div class=\"line\">    co = checkout</div><div class=\"line\">    br = branch</div><div class=\"line\">    ba = branch -a</div><div class=\"line\">    rb = rebase</div><div class=\"line\">    dci = dcommit</div><div class=\"line\">    lg = log --color --graph --pretty=format:<span class=\"string\">'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset'</span> --abbrev-commit</div></pre></td></tr></table></figure>\n<blockquote>\n<p>另，<code>~/.gitconfig</code> 文件中，可以查看当前 user 的 git 配置信息</p>\n</blockquote>\n<h2 id=\"二、branch-分支操作\"><a href=\"#二、branch-分支操作\" class=\"headerlink\" title=\"二、branch 分支操作\"></a>二、branch 分支操作</h2><h3 id=\"查看分支信息\"><a href=\"#查看分支信息\" class=\"headerlink\" title=\"查看分支信息\"></a>查看分支信息</h3><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"># 列出所有本地分支</div><div class=\"line\">// git br</div><div class=\"line\">$ git branch</div><div class=\"line\"></div><div class=\"line\"># 列出所有本地分支和远程分支</div><div class=\"line\">// git ba</div><div class=\"line\">$ git branch -a</div></pre></td></tr></table></figure>\n<h3 id=\"新建分支\"><a href=\"#新建分支\" class=\"headerlink\" title=\"新建分支\"></a>新建分支</h3><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 从当前分支新建一个分支。但依然停留在当前分支</div><div class=\"line\">// git br [本地xxx]</div><div class=\"line\">$ git branch [branch-name]</div><div class=\"line\">// 常用于：对当前 分支做个备份</div><div class=\"line\"></div><div class=\"line\"># 从指定的远程分支，拉一个本地分支。并切换到该分支</div><div class=\"line\">// 常用于： 从远端 develop 拉一个 本地 feature/xxx 分支</div><div class=\"line\">$ git checkout -b newBrach origin/master</div><div class=\"line\"></div><div class=\"line\"># 新建一个分支，指向指定commit。但依然停留在当前分支</div><div class=\"line\">$ git branch [branch] [commit]</div><div class=\"line\"></div><div class=\"line\"># 新建一个分支。并切换到该分支</div><div class=\"line\">// git co -b [local or remote/branch-name]</div><div class=\"line\">$ git checkout -b [branch-name]</div><div class=\"line\"></div><div class=\"line\"># 新建一个分支，指向某个tag</div><div class=\"line\">$ git checkout -b [branch] [tag]</div></pre></td></tr></table></figure>\n<h3 id=\"切换分支\"><a href=\"#切换分支\" class=\"headerlink\" title=\"切换分支\"></a>切换分支</h3><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 切换到指定分支，并更新工作区</div><div class=\"line\">// git co [branch-name]</div><div class=\"line\">$ git checkout [branch-name]</div><div class=\"line\"></div><div class=\"line\"># 切换到上一个分支</div><div class=\"line\">$ git checkout -</div></pre></td></tr></table></figure>\n<h3 id=\"删除分支\"><a href=\"#删除分支\" class=\"headerlink\" title=\"删除分支\"></a>删除分支</h3><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 删除本地分支</div><div class=\"line\">// git br -d [branch-name]]</div><div class=\"line\">$ git branch -d [branch-name]</div><div class=\"line\">$ git branch -D //强制删除</div><div class=\"line\"></div><div class=\"line\"># 删除远程分支</div><div class=\"line\">// git br -dr [remote/branch]</div><div class=\"line\">// eg:  git br -dr origin/xxx_name</div><div class=\"line\">$ git branch -dr [remote/branch]</div></pre></td></tr></table></figure>\n<h3 id=\"合并分支\"><a href=\"#合并分支\" class=\"headerlink\" title=\"合并分支\"></a>合并分支</h3><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 合并指定分支到当前分支</div><div class=\"line\">$ git merge [branch]</div><div class=\"line\"></div><div class=\"line\"># 选择一个commit，合并进当前分支</div><div class=\"line\">$ git cherry-pick [commit]</div></pre></td></tr></table></figure>\n<h2 id=\"三、tag-分支操作\"><a href=\"#三、tag-分支操作\" class=\"headerlink\" title=\"三、tag 分支操作\"></a>三、tag 分支操作</h2><p>在 Git 中 tag 可以看做是指向某个 commit 的特殊分支</p>\n<h3 id=\"列显已有-tag\"><a href=\"#列显已有-tag\" class=\"headerlink\" title=\"列显已有 tag\"></a>列显已有 tag</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git tag</div></pre></td></tr></table></figure>\n<h3 id=\"添加-tag\"><a href=\"#添加-tag\" class=\"headerlink\" title=\"添加 tag\"></a>添加 tag</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git tag v1<span class=\"number\">.4</span><span class=\"number\">.0</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 添加一个带 commit log 的 tag</span></div><div class=\"line\">$ git tag -a v1<span class=\"number\">.4</span> -m <span class=\"string\">'my version 1.4'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 为某个指定的 commit 打上 tag</span></div><div class=\"line\">$ git tag -a v1<span class=\"number\">.2</span> <span class=\"number\">9</span>fceb02</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 查看 tag 信息</span></div><div class=\"line\">$ git show v1<span class=\"number\">.4</span></div></pre></td></tr></table></figure>\n<h3 id=\"推送-tag\"><a href=\"#推送-tag\" class=\"headerlink\" title=\"推送 tag\"></a>推送 tag</h3><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">// git push 不会将本地的 tag push 到 origin</div><div class=\"line\"></div><div class=\"line\"># push 指定 tag name</div><div class=\"line\">$ git push origin v1.0</div><div class=\"line\"># push 全部 tag</div><div class=\"line\">$ git push origin --tags</div></pre></td></tr></table></figure>\n<h3 id=\"删除-tag\"><a href=\"#删除-tag\" class=\"headerlink\" title=\"删除 tag\"></a>删除 tag</h3><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 删除本地 tag</div><div class=\"line\">$ git tag -d v0.9</div><div class=\"line\"></div><div class=\"line\">// 删除远端 tag</div><div class=\"line\">$ git push origin :refs/tags/0.1.0</div><div class=\"line\">## 明确的表示删除</div><div class=\"line\">$ git push --delete origin v1.1</div></pre></td></tr></table></figure>\n<h2 id=\"四、git-pull\"><a href=\"#四、git-pull\" class=\"headerlink\" title=\"四、git pull\"></a>四、git pull</h2><p>git pull命令的作用是，取回远程主机某个分支的更新，再与本地的指定分支合并。</p>\n<h3 id=\"Merge-型-的-pull\"><a href=\"#Merge-型-的-pull\" class=\"headerlink\" title=\"Merge 型 的 pull\"></a>Merge 型 的 pull</h3><blockquote>\n<p>如果本地分支，在 checkout 后，有 commit， git pull 就会增加一个 Merge log<br>如果本地分支没有 新 commit，等于直接 fetch、pull</p>\n</blockquote>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/332029-6510e80758bdf307.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">// 将远端的 A 分支的代码，拉到本地 B 分支 (会产生一个 Merge log)</div><div class=\"line\">$ git pull origin [remote_name]:[local_name]</div><div class=\"line\">// 如果是往当前 本地分支 pull，则冒号后面的部分可以省略</div><div class=\"line\">$ git pull origin [remote_name]</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">// 实质上，这等同于先做git fetch，再做git merge。</div><div class=\"line\">$ git fetch origin</div><div class=\"line\">$ git merge origin/next</div><div class=\"line\"></div><div class=\"line\"># Git会自动在本地分支与远程分支之间，建立一种追踪关系（tracking）。 就是说，本地的master分支自动&quot;追踪&quot;origin/master分支。</div><div class=\"line\"></div><div class=\"line\">// 如果当前分支与远程分支存在追踪关系，git pull就可以省略远程分支名。</div><div class=\"line\">$ git pull origin</div><div class=\"line\"></div><div class=\"line\">// 如果当前分支只有一个追踪分支，连远程主机名都可以省略。</div><div class=\"line\">$ git pull</div><div class=\"line\">// 上面命令表示，当前分支自动与唯一一个追踪分支进行合并</div></pre></td></tr></table></figure>\n<h3 id=\"rebase-型-pull\"><a href=\"#rebase-型-pull\" class=\"headerlink\" title=\"rebase 型 pull\"></a>rebase 型 pull</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 如果合并需要采用rebase模式，可以使用--rebase选项。</span></div><div class=\"line\">$ git pull --rebase &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</div><div class=\"line\">// git pull --rebase origin [origin_name]:[local_name]</div><div class=\"line\"></div><div class=\"line\">// 如果是 rebase 到当前分支，可省略 ： 后</div><div class=\"line\">$ git pull --rebase origin [origin_name]</div><div class=\"line\">// 如果 rebase 的远端分支，是当前分支 track 的，[origin_name] 可省略</div><div class=\"line\">$ git pull --rebase origin</div></pre></td></tr></table></figure>\n<h2 id=\"五、Git-push\"><a href=\"#五、Git-push\" class=\"headerlink\" title=\"五、Git push\"></a>五、Git push</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 将当前 loca_name 分支 push 到远端，命名为 new_name</span></div><div class=\"line\">$ git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</div><div class=\"line\">// git push origin loca_name:new_name</div><div class=\"line\"></div><div class=\"line\"># 如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。</div><div class=\"line\"># 如果当前分支只有一个追踪分支，那么主机名都可以省略。</div><div class=\"line\">// 会将本地所有分支都 对应 push （慎用）</div><div class=\"line\">$ git push</div><div class=\"line\"></div><div class=\"line\">// push 可以用来删除</div><div class=\"line\">$ git push origin --delete master</div><div class=\"line\"></div><div class=\"line\"># 如果远程主机的版本比本地版本更新，推送时Git会报错，要求先在本地做git pull合并差异，然后再推送到远程主机。这时，如果你一定要推送，可以使用--force选项。</div><div class=\"line\">$ git push --force origin</div><div class=\"line\"></div><div class=\"line\"># 最后，git push不会推送标签（tag），除非使用--tags选项。</div><div class=\"line\">$ git push origin --tags</div></pre></td></tr></table></figure>\n<h2 id=\"六、代码回滚\"><a href=\"#六、代码回滚\" class=\"headerlink\" title=\"六、代码回滚\"></a>六、代码回滚</h2><h3 id=\"快速合并缓存区到上一个-commit\"><a href=\"#快速合并缓存区到上一个-commit\" class=\"headerlink\" title=\"快速合并缓存区到上一个 commit\"></a>快速合并缓存区到上一个 commit</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 将 add 到缓存区的内容，和上一个 commit 一起， rebase 成了一个新的 commit</span></div><div class=\"line\">$ git commit --amend</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 便于将漏修改的，或是修改错误的内容，合并到上一个 commit 中。而不用提交两个 commit，然后 rebase 成一个</span></div><div class=\"line\"><span class=\"comment\">// 注：如果修改过了， 只能 push -f 到远端</span></div></pre></td></tr></table></figure>\n<h3 id=\"checkout-到指定-commit\"><a href=\"#checkout-到指定-commit\" class=\"headerlink\" title=\"checkout 到指定 commit\"></a>checkout 到指定 commit</h3><p>这对于快速查看项目旧版本来说非常有用</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git checkout [commit id]</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// check 到往前指定此的 commit</span></div><div class=\"line\">$ git checkout HEAD~<span class=\"number\">2</span></div></pre></td></tr></table></figure>\n<h3 id=\"git-Revert\"><a href=\"#git-Revert\" class=\"headerlink\" title=\"git Revert\"></a>git Revert</h3><p>Revert撤销一个提交的同时会创建一个新的提交。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 新建一个commit，用来撤销指定commit</div><div class=\"line\"># 后者的所有变化都将被前者抵消，并且应用到当前分支</div><div class=\"line\">$ git revert [commit]</div></pre></td></tr></table></figure>\n<h3 id=\"git-reset\"><a href=\"#git-reset\" class=\"headerlink\" title=\"git reset\"></a>git reset</h3><ul>\n<li>将已经加到缓存区的内容（仅打了本地 commit），移除到工作区</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git reset HEAD</div><div class=\"line\"></div><div class=\"line\">$ git reset HEAD~2</div></pre></td></tr></table></figure>\n<ul>\n<li>从缓存区重置，不删除修改的地方</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 将缓存区中的指定文件，移到工作区</span></div><div class=\"line\"><span class=\"comment\">// 缓存区中的，指的是 add 后的</span></div><div class=\"line\">git reset &lt;file&gt;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 将缓存区中的全部文件，移到工作区</span></div><div class=\"line\">$ git reset</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 将本地 commit 历史中的 commit 移除到 工作区 （未 add 状态）</span></div><div class=\"line\">$ git reset [commit_id]</div></pre></td></tr></table></figure>\n<h3 id=\"删除式-reset\"><a href=\"#删除式-reset\" class=\"headerlink\" title=\"删除式 reset\"></a>删除式 reset</h3><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 缓存区和工作区的，都会被完全移除（删除）</div><div class=\"line\">$ git reset --hard</div><div class=\"line\"></div><div class=\"line\">// 将本地 commit 历史中的直接删除</div><div class=\"line\">$ git reset --hard &lt;commit&gt;</div><div class=\"line\"></div><div class=\"line\"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</div><div class=\"line\">$ git reset --keep [commit]</div></pre></td></tr></table></figure>\n<p>参考：<br><a href=\"http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html\">常用 Git 命令清单 - 阮一峰</a><br><a href=\"http://www.ruanyifeng.com/blog/2014/06/git_remote.html\">Git远程操作详解 - 阮一峰</a><br><a href=\"http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001375234012342f90be1fc4d81446c967bbdc19e7c03d3000\">Git 配置别名 - 廖雪峰</a><br><a href=\"https://github.com/geeeeeeeeek/git-recipes/wiki\">果壳中的 Git</a></p>\n<p>特别推荐：<br><a href=\"https://github.com/jaywcjlove/handbook/blob/master/other/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B8%85%E5%8D%95.md\"> jaywcjlove —— Git常用命令清单</a></p>\n"},{"title":"Hello World","date":"2015-02-15T14:33:01.000Z","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ndate: 2015-02-15 22:33:01\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"updated":"2017-03-10T05:57:40.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj03ftfo500097womrmux9r6o","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"external\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"external\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"external\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"external\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"external\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo server</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"external\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo generate</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"external\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo deploy</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"external\">Deployment</a></p>\n","excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo server</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo generate</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo deploy</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\">Deployment</a></p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cj03ftfnb00017womcu5jbum8","tag_id":"cj03ftfnj00037womoya78j8y","_id":"cj03ftfo500087womvuefwbrp"},{"post_id":"cj03ftfnh00027wom7vdahjuh","tag_id":"cj03ftfo300077wom2ij35z7l","_id":"cj03ftfo7000b7womz3vq7vma"},{"post_id":"cj03ftfnw00047womlvsok456","tag_id":"cj03ftfo7000a7woml1lrmond","_id":"cj03ftfok000d7womreb9j6c6"},{"post_id":"cj03ftfnx00057womnce2ms13","tag_id":"cj03ftfo8000c7womsxwu9nm9","_id":"cj03ftfol000f7wom6sltuq2h"},{"post_id":"cj03ftfnz00067womfeutcktp","tag_id":"cj03ftfok000e7wom3se249fu","_id":"cj03ftfol000g7wom2mj2v1k9"}],"Tag":[{"name":"YYFPSLabel","_id":"cj03ftfnj00037womoya78j8y"},{"name":"module","_id":"cj03ftfo300077wom2ij35z7l"},{"name":"runtime swizzling","_id":"cj03ftfo7000a7woml1lrmond"},{"name":"node.js node web sina","_id":"cj03ftfo8000c7womsxwu9nm9"},{"name":"git","_id":"cj03ftfok000e7wom3se249fu"}]}}