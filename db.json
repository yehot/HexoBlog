{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/favicon.ico","path":"favicon.ico","modified":0,"renderable":0},{"_id":"themes/anatole/source/css/blog_basic.css","path":"css/blog_basic.css","modified":0,"renderable":1},{"_id":"themes/anatole/source/css/font-awesome.min.css","path":"css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/anatole/source/css/style.css","path":"css/style.css","modified":0,"renderable":1},{"_id":"themes/anatole/source/css/style.scss","path":"css/style.scss","modified":0,"renderable":1},{"_id":"themes/anatole/source/fonts/fontawesome-webfont.eot","path":"fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/anatole/source/images/favicon.png","path":"images/favicon.png","modified":0,"renderable":1},{"_id":"themes/anatole/source/images/logo.png","path":"images/logo.png","modified":0,"renderable":1},{"_id":"themes/anatole/source/js/jquery-migrate-1.2.1.min.js","path":"js/jquery-migrate-1.2.1.min.js","modified":0,"renderable":1},{"_id":"themes/anatole/source/js/jquery.appear.js","path":"js/jquery.appear.js","modified":0,"renderable":1},{"_id":"themes/anatole/source/images/logo@2x.png","path":"images/logo@2x.png","modified":0,"renderable":1},{"_id":"themes/anatole/source/fonts/fontawesome-webfont.woff","path":"fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/anatole/source/fonts/fontawesome-webfont.ttf","path":"fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/anatole/source/fonts/fontawesome-webfont.svg","path":"fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/anatole/source/js/jquery.js","path":"js/jquery.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"3205aabc34963c44e02e69e0c765b7c0e6af1623","modified":1555604362959},{"_id":"source/favicon.ico","hash":"0f788e715691c76ce6364ae9d38cffdd71a10615","modified":1555585608752},{"_id":"themes/anatole/LICENSE","hash":"359cb81298c1fdbccf531548fc097466b0151be4","modified":1555603343026},{"_id":"themes/anatole/.gitignore","hash":"9fcbb05b158b5d3ba1ee60d38889e05e8b0f3f2a","modified":1555603343026},{"_id":"themes/anatole/README.md","hash":"88d58e69eda2435ce074bc6cafb1817346089a88","modified":1555603343026},{"_id":"themes/anatole/_config.sample.yml","hash":"c6bce49d93a37e9ed5f0c4b104decc0bd7832e04","modified":1555603343026},{"_id":"themes/anatole/package.json","hash":"cf731a3ebf3913747fccb6c4c6615eba7d7e88a4","modified":1555603343030},{"_id":"source/_posts/20150819-CAReplicatorLayer.md","hash":"076a67cbe6b4e5f1a1a6d8b9f5500d96bf499080","modified":1555585608745},{"_id":"source/_posts/20150901-CAShapeLayer.md","hash":"8b8df68a23fa553dc5e39c561c6b576600977d1d","modified":1555585608745},{"_id":"source/_posts/20150909-custom-NSLog.md","hash":"8e9df5edda58f07a124dad11e961de1e638e512d","modified":1555585608746},{"_id":"source/_posts/20151129-project-contents.md","hash":"ff98a62926fe558038b63ee0ad354fca8f0a1eb7","modified":1555585608746},{"_id":"source/_posts/20151128-why-cocoaPods.md","hash":"27d96c7e2e4794a48a516a394c45c94237f75215","modified":1555585608746},{"_id":"source/_posts/20160405-YYFPSLabel-source-read.md","hash":"92c9125dbe7d30aace3746a0e1fd79089facd4a2","modified":1555585608747},{"_id":"source/_posts/20160531-ios-module-investigation.md","hash":"16f7985505179fef654d61e9ae77d85bba9752d5","modified":1555585608747},{"_id":"source/_posts/20160702-rutime-method-swiizzling.md","hash":"6612d15dbc9bd98f0ec104efce5412f61578dd84","modified":1555585608747},{"_id":"source/_posts/20160915-CTMediator-tutorials.md","hash":"7b76fde87cd49e58c79c19f3dcdb85d4b0eb644c","modified":1555605465208},{"_id":"source/_posts/20161218-sina-sae-node-js-web-tutorial.md","hash":"e8cccf2ea53c8feaa48288e888c22614017a230e","modified":1555585608750},{"_id":"source/_posts/hello-world.md","hash":"5a05db0e9179b6279f0ccffd0fb5236fefc3809a","modified":1555585608751},{"_id":"source/_posts/20170326-sina-blog-spider.md","hash":"e3f72e662aab32292bae9a04b989d49acf67e17c","modified":1555585608750},{"_id":"source/_posts/20170215-git-order-list.md","hash":"a1c2f2f00fd6323d48d35b1e6e621887a8883043","modified":1555585608750},{"_id":"source/about/index.md","hash":"c86e6e88b84bb0d789353e48b4a46572dd559ce6","modified":1555585608752},{"_id":"source/categories/index.md","hash":"e2c6e0a2a25c211929cf4ab536c71da54b22ddb1","modified":1555585608752},{"_id":"source/tags/index.md","hash":"8113d18dfd8251f3e7e5f71174dd1b0ba63cdc90","modified":1555585608753},{"_id":"themes/anatole/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1555603343018},{"_id":"themes/anatole/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1555603315975},{"_id":"themes/anatole/.git/config","hash":"831e9fdc6bb9fa56130a1292e248c5ad420f7229","modified":1555603343020},{"_id":"themes/anatole/.git/index","hash":"bcd6bfa2c2d34daf5d1eb58e98f1740d4515daaa","modified":1555605235537},{"_id":"themes/anatole/.git/packed-refs","hash":"1b6b58240cb6ba507347e8f64e18aca873ba8cdd","modified":1555603343016},{"_id":"themes/anatole/languages/pt-BR.yml","hash":"ac5a0003d7793aade51f70643b2e2a631b6a65c3","modified":1555603343026},{"_id":"themes/anatole/languages/zh-cn.yml","hash":"dab1823e036f4adb3b7ae9efe95a37a15e47bec2","modified":1555603343027},{"_id":"themes/anatole/layout/archive.pug","hash":"1a161404966000b25a84762f08da3ca60af146bc","modified":1555603343027},{"_id":"themes/anatole/layout/category.pug","hash":"ae894ef4baee4a0c7c8e66641166061e789f1fa7","modified":1555603343027},{"_id":"themes/anatole/layout/index.pug","hash":"53da3cfd498951148acb33de1574df80ae282dc5","modified":1555603343027},{"_id":"themes/anatole/layout/mixins.pug","hash":"107bfd2fe10de0d8b110c13bb1168af79e62a37c","modified":1555603343028},{"_id":"themes/anatole/layout/page.pug","hash":"15142c94e5c2247aba8efb64cffd695b3f133670","modified":1555603343028},{"_id":"themes/anatole/layout/post.pug","hash":"012f8e272cf4713a0f08e3b702dab08ef6593b31","modified":1555603343029},{"_id":"themes/anatole/layout/tag.pug","hash":"7017a8bae4f4a412dafb556772bdcf2cfddeb79f","modified":1555603343029},{"_id":"themes/anatole/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1555603315976},{"_id":"themes/anatole/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1555603315977},{"_id":"themes/anatole/.git/hooks/fsmonitor-watchman.sample","hash":"f7c0aa40cb0d620ff0bca3efe3521ec79e5d7156","modified":1555603315978},{"_id":"themes/anatole/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1555603315979},{"_id":"themes/anatole/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1555603315980},{"_id":"themes/anatole/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1555603315977},{"_id":"themes/anatole/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1555603315981},{"_id":"themes/anatole/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1555603315977},{"_id":"themes/anatole/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1555603315978},{"_id":"themes/anatole/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1555603315979},{"_id":"themes/anatole/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1555603315981},{"_id":"themes/anatole/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1555603315974},{"_id":"themes/anatole/.git/logs/HEAD","hash":"ef98aeea5b7720ab1ceed27de8f3b257999dbb8d","modified":1555603343019},{"_id":"themes/anatole/layout/partial/footer.pug","hash":"772f03a2dd9fa4fed422c4eb4d5d1ace84c65580","modified":1555603343028},{"_id":"themes/anatole/layout/partial/comments.pug","hash":"fad5bbe7c2a134c892fcb1c731d979463145a49b","modified":1555603343028},{"_id":"themes/anatole/layout/partial/head.pug","hash":"3d6126d0b53a889a46ad61eb8cc0ab1b35446c49","modified":1555603343028},{"_id":"themes/anatole/layout/partial/layout.pug","hash":"174050fa9ee919f5bcb2c5426224ec1968db672c","modified":1555603343029},{"_id":"themes/anatole/layout/partial/sidebar.pug","hash":"6721b1e0b1e59e54d031a4978e7f82aece336efc","modified":1555603343029},{"_id":"themes/anatole/layout/partial/nav.pug","hash":"6ef30551de7b22d99b6a0980caf7899d7c303093","modified":1555603343029},{"_id":"themes/anatole/source/css/blog_basic.css","hash":"7db88f0873e858b21a4c981c8481708ad9117478","modified":1555603343030},{"_id":"themes/anatole/source/css/font-awesome.min.css","hash":"95d0b0c4d11105c81be1857b744076a1d2bed918","modified":1555603343030},{"_id":"themes/anatole/source/css/style.css","hash":"871a5c940cbc0ce5488a670f2285f2c3015cf71c","modified":1555603343031},{"_id":"themes/anatole/source/css/style.scss","hash":"175c9237798207f705c62777b5f51509adec6d0a","modified":1555603343031},{"_id":"themes/anatole/source/fonts/fontawesome-webfont.eot","hash":"0183979056f0b87616cd99d5c54a48f3b771eee6","modified":1555603343032},{"_id":"themes/anatole/source/images/favicon.png","hash":"d659236704308954da9d64b101c4f54cc3f3255c","modified":1555603343036},{"_id":"themes/anatole/source/images/logo.png","hash":"41bdf2ebd8cc193ad82a211758af827d891b1a90","modified":1555603343036},{"_id":"themes/anatole/source/js/jquery-migrate-1.2.1.min.js","hash":"743052320809514fb788fe1d3df37fc87ce90452","modified":1555603343036},{"_id":"themes/anatole/source/js/jquery.appear.js","hash":"1f8067d7bd4c0bde30785e8016100f239e14394f","modified":1555603343037},{"_id":"themes/anatole/source/images/logo@2x.png","hash":"49c3fa97724abf53861bf11356ea9ba5bcb11576","modified":1555603343036},{"_id":"themes/anatole/source/fonts/fontawesome-webfont.woff","hash":"7d65e0227d0d7cdc1718119cd2a7dce0638f151c","modified":1555603343035},{"_id":"themes/anatole/source/fonts/fontawesome-webfont.ttf","hash":"6225ccc4ec94d060f19efab97ca42d842845b949","modified":1555603343035},{"_id":"themes/anatole/.git/objects/pack/pack-a1978a0c4fdc701078c675218192a7e6c7a709a9.idx","hash":"83fc4a0423ba57a9085d17b2fba48aa398682d8d","modified":1555603343008},{"_id":"themes/anatole/.git/refs/heads/master","hash":"925503d46c26d7a61b09317360241cba55ee3974","modified":1555603343019},{"_id":"themes/anatole/.git/logs/refs/heads/master","hash":"ef98aeea5b7720ab1ceed27de8f3b257999dbb8d","modified":1555603343019},{"_id":"themes/anatole/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1555603343018},{"_id":"themes/anatole/source/fonts/fontawesome-webfont.svg","hash":"cd980eab6db5fa57db670cb2e4278e67e1a4d6c9","modified":1555603343034},{"_id":"themes/anatole/.git/logs/refs/remotes/origin/HEAD","hash":"ef98aeea5b7720ab1ceed27de8f3b257999dbb8d","modified":1555603343018},{"_id":"themes/anatole/source/js/jquery.js","hash":"bfc05b695dfa4f23e11d04b84993585da7a764bf","modified":1555603343038},{"_id":"themes/anatole/.git/objects/pack/pack-a1978a0c4fdc701078c675218192a7e6c7a709a9.pack","hash":"cc823f2dc8d86c0e30577338c3cc3ea9d580f312","modified":1555603343008},{"_id":"public/about/index.html","hash":"15142c94e5c2247aba8efb64cffd695b3f133670","modified":1555605981801},{"_id":"public/categories/index.html","hash":"15142c94e5c2247aba8efb64cffd695b3f133670","modified":1555605981802},{"_id":"public/tags/index.html","hash":"15142c94e5c2247aba8efb64cffd695b3f133670","modified":1555605981802},{"_id":"public/2017/03/27/20170326-sina-blog-spider/index.html","hash":"012f8e272cf4713a0f08e3b702dab08ef6593b31","modified":1555605981802},{"_id":"public/2017/02/15/20170215-git-order-list/index.html","hash":"012f8e272cf4713a0f08e3b702dab08ef6593b31","modified":1555605981802},{"_id":"public/2016/12/18/20161218-sina-sae-node-js-web-tutorial/index.html","hash":"012f8e272cf4713a0f08e3b702dab08ef6593b31","modified":1555605981802},{"_id":"public/2016/09/15/20160915-CTMediator-tutorials/index.html","hash":"012f8e272cf4713a0f08e3b702dab08ef6593b31","modified":1555605981802},{"_id":"public/2016/07/02/20160702-rutime-method-swiizzling/index.html","hash":"012f8e272cf4713a0f08e3b702dab08ef6593b31","modified":1555605981802},{"_id":"public/2016/05/31/20160531-ios-module-investigation/index.html","hash":"012f8e272cf4713a0f08e3b702dab08ef6593b31","modified":1555605981802},{"_id":"public/2016/04/05/20160405-YYFPSLabel-source-read/index.html","hash":"012f8e272cf4713a0f08e3b702dab08ef6593b31","modified":1555605981803},{"_id":"public/2015/11/29/20151129-project-contents/index.html","hash":"012f8e272cf4713a0f08e3b702dab08ef6593b31","modified":1555605981803},{"_id":"public/2015/11/28/20151128-why-cocoaPods/index.html","hash":"012f8e272cf4713a0f08e3b702dab08ef6593b31","modified":1555605981803},{"_id":"public/2015/09/09/20150909-custom-NSLog/index.html","hash":"012f8e272cf4713a0f08e3b702dab08ef6593b31","modified":1555605981803},{"_id":"public/2015/09/01/20150901-CAShapeLayer/index.html","hash":"012f8e272cf4713a0f08e3b702dab08ef6593b31","modified":1555605981803},{"_id":"public/2015/08/19/20150819-CAReplicatorLayer/index.html","hash":"012f8e272cf4713a0f08e3b702dab08ef6593b31","modified":1555605981803},{"_id":"public/2015/02/15/hello-world/index.html","hash":"012f8e272cf4713a0f08e3b702dab08ef6593b31","modified":1555605981803},{"_id":"public/categories/Animation/index.html","hash":"ae894ef4baee4a0c7c8e66641166061e789f1fa7","modified":1555605981803},{"_id":"public/categories/Tool/index.html","hash":"ae894ef4baee4a0c7c8e66641166061e789f1fa7","modified":1555605981803},{"_id":"public/categories/iOS组件化/index.html","hash":"ae894ef4baee4a0c7c8e66641166061e789f1fa7","modified":1555605981803},{"_id":"public/categories/Python/index.html","hash":"ae894ef4baee4a0c7c8e66641166061e789f1fa7","modified":1555605981803},{"_id":"public/categories/Node-js/index.html","hash":"ae894ef4baee4a0c7c8e66641166061e789f1fa7","modified":1555605981803},{"_id":"public/index.html","hash":"53da3cfd498951148acb33de1574df80ae282dc5","modified":1555605981803},{"_id":"public/page/2/index.html","hash":"53da3cfd498951148acb33de1574df80ae282dc5","modified":1555605981803},{"_id":"public/tags/CALayer/index.html","hash":"7017a8bae4f4a412dafb556772bdcf2cfddeb79f","modified":1555605981804},{"_id":"public/tags/CocoaPods/index.html","hash":"7017a8bae4f4a412dafb556772bdcf2cfddeb79f","modified":1555605981804},{"_id":"public/tags/spider/index.html","hash":"7017a8bae4f4a412dafb556772bdcf2cfddeb79f","modified":1555605981804},{"_id":"public/tags/runtime-swizzling/index.html","hash":"7017a8bae4f4a412dafb556772bdcf2cfddeb79f","modified":1555605981804},{"_id":"public/tags/node-js/index.html","hash":"7017a8bae4f4a412dafb556772bdcf2cfddeb79f","modified":1555605981804},{"_id":"public/tags/Git/index.html","hash":"7017a8bae4f4a412dafb556772bdcf2cfddeb79f","modified":1555605981804},{"_id":"public/archives/index.html","hash":"1a161404966000b25a84762f08da3ca60af146bc","modified":1555605981804},{"_id":"public/favicon.ico","hash":"0f788e715691c76ce6364ae9d38cffdd71a10615","modified":1555605981808},{"_id":"public/css/style.scss","hash":"175c9237798207f705c62777b5f51509adec6d0a","modified":1555605981808},{"_id":"public/images/favicon.png","hash":"d659236704308954da9d64b101c4f54cc3f3255c","modified":1555605981808},{"_id":"public/images/logo.png","hash":"41bdf2ebd8cc193ad82a211758af827d891b1a90","modified":1555605981808},{"_id":"public/fonts/fontawesome-webfont.eot","hash":"0183979056f0b87616cd99d5c54a48f3b771eee6","modified":1555605981810},{"_id":"public/images/logo@2x.png","hash":"49c3fa97724abf53861bf11356ea9ba5bcb11576","modified":1555605981810},{"_id":"public/fonts/fontawesome-webfont.woff","hash":"7d65e0227d0d7cdc1718119cd2a7dce0638f151c","modified":1555605981811},{"_id":"public/fonts/fontawesome-webfont.ttf","hash":"6225ccc4ec94d060f19efab97ca42d842845b949","modified":1555605981812},{"_id":"public/js/jquery-migrate-1.2.1.min.js","hash":"743052320809514fb788fe1d3df37fc87ce90452","modified":1555605981813},{"_id":"public/js/jquery.appear.js","hash":"1f8067d7bd4c0bde30785e8016100f239e14394f","modified":1555605981813},{"_id":"public/css/blog_basic.css","hash":"7db88f0873e858b21a4c981c8481708ad9117478","modified":1555605981817},{"_id":"public/css/style.css","hash":"871a5c940cbc0ce5488a670f2285f2c3015cf71c","modified":1555605981817},{"_id":"public/css/font-awesome.min.css","hash":"95d0b0c4d11105c81be1857b744076a1d2bed918","modified":1555605981819},{"_id":"public/fonts/fontawesome-webfont.svg","hash":"cd980eab6db5fa57db670cb2e4278e67e1a4d6c9","modified":1555605981820},{"_id":"public/js/jquery.js","hash":"bfc05b695dfa4f23e11d04b84993585da7a764bf","modified":1555605981824}],"Category":[{"name":"Animation","_id":"cjumvmx9l0004raxerk26ova5"},{"name":"Tool","_id":"cjumvmx9v000eraxewyudm331"},{"name":"iOS组件化","_id":"cjumvmx9x000mraxeqp4hw1g1"},{"name":"Python","_id":"cjumvmx9y000qraxe76fv3hya"},{"name":"Node.js","_id":"cjumvmxae0017raxe0nfhz110"}],"Data":[],"Page":[{"title":"关于","date":"2017-03-22T16:40:16.000Z","_content":"","source":"about/index.md","raw":"---\ntitle: 关于\ndate: 2017-03-23 00:40:16\n---\n","updated":"2019-04-18T11:06:48.752Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjumvmx9h0001raxed4vggg71","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"categories","date":"2017-03-22T16:42:32.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2017-03-23 00:42:32\ntype: \"categories\"\n---\n","updated":"2019-04-18T11:06:48.752Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cjumvmx9k0003raxexxoq13x3","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"标签","date":"2017-03-22T16:38:49.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2017-03-23 00:38:49\ntype: \"tags\"\n---\n","updated":"2019-04-18T11:06:48.753Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cjumvmxa7000uraxeyuu0mf5r","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"CAReplicatorLayer 创建炫酷动画","date":"2015-08-19T13:56:39.000Z","_content":"\n\n使用CAReplicatorLayer创建以下动画效果:\n\n\n![](http://upload-images.jianshu.io/upload_images/332029-0c58f125ff1e1708.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240/q/100)\n\n\nCAReplicatorLayerz 使用：\n\n- 作为子 Layer 添加到容器 Layer;\n- 可以复制若干份；\n- 可以设定子Layer复制份数、设定副本之间的距离、透明度、颜色、旋转、位置等状态属性;\n- 动画效果的性能较好，内存使用低;\n\n\n\n[原文链接](http://www.jianshu.com/p/76c588893b19?utm_campaign=hugo)\n\n> 这里是将原译者的代码翻译成 OC 版本实现了一遍，添加了详细的注释：\n\n[戳这里](https://github.com/yehot/CAReplicatorLayerDemo)\n\n","source":"_posts/20150819-CAReplicatorLayer.md","raw":"---\ntitle: CAReplicatorLayer 创建炫酷动画\ndate: 2015-08-19 21:56:39\ntags: CALayer\ncategories: Animation\n---\n\n\n使用CAReplicatorLayer创建以下动画效果:\n\n\n![](http://upload-images.jianshu.io/upload_images/332029-0c58f125ff1e1708.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240/q/100)\n\n\nCAReplicatorLayerz 使用：\n\n- 作为子 Layer 添加到容器 Layer;\n- 可以复制若干份；\n- 可以设定子Layer复制份数、设定副本之间的距离、透明度、颜色、旋转、位置等状态属性;\n- 动画效果的性能较好，内存使用低;\n\n\n\n[原文链接](http://www.jianshu.com/p/76c588893b19?utm_campaign=hugo)\n\n> 这里是将原译者的代码翻译成 OC 版本实现了一遍，添加了详细的注释：\n\n[戳这里](https://github.com/yehot/CAReplicatorLayerDemo)\n\n","slug":"20150819-CAReplicatorLayer","published":1,"updated":"2019-04-18T11:06:48.745Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjumvmx9c0000raxezm38r3fq","content":"<p>使用CAReplicatorLayer创建以下动画效果:</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/332029-0c58f125ff1e1708.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240/q/100\" alt></p>\n<p>CAReplicatorLayerz 使用：</p>\n<ul>\n<li>作为子 Layer 添加到容器 Layer;</li>\n<li>可以复制若干份；</li>\n<li>可以设定子Layer复制份数、设定副本之间的距离、透明度、颜色、旋转、位置等状态属性;</li>\n<li>动画效果的性能较好，内存使用低;</li>\n</ul>\n<p><a href=\"http://www.jianshu.com/p/76c588893b19?utm_campaign=hugo\" target=\"_blank\" rel=\"noopener\">原文链接</a></p>\n<blockquote>\n<p>这里是将原译者的代码翻译成 OC 版本实现了一遍，添加了详细的注释：</p>\n</blockquote>\n<p><a href=\"https://github.com/yehot/CAReplicatorLayerDemo\" target=\"_blank\" rel=\"noopener\">戳这里</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>使用CAReplicatorLayer创建以下动画效果:</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/332029-0c58f125ff1e1708.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240/q/100\" alt></p>\n<p>CAReplicatorLayerz 使用：</p>\n<ul>\n<li>作为子 Layer 添加到容器 Layer;</li>\n<li>可以复制若干份；</li>\n<li>可以设定子Layer复制份数、设定副本之间的距离、透明度、颜色、旋转、位置等状态属性;</li>\n<li>动画效果的性能较好，内存使用低;</li>\n</ul>\n<p><a href=\"http://www.jianshu.com/p/76c588893b19?utm_campaign=hugo\" target=\"_blank\" rel=\"noopener\">原文链接</a></p>\n<blockquote>\n<p>这里是将原译者的代码翻译成 OC 版本实现了一遍，添加了详细的注释：</p>\n</blockquote>\n<p><a href=\"https://github.com/yehot/CAReplicatorLayerDemo\" target=\"_blank\" rel=\"noopener\">戳这里</a></p>\n"},{"title":"CAShapeLayer 实现圆形图片加载动画","date":"2015-09-01T14:06:30.000Z","_content":"\n> 原文链接 :[How To Implement A Circular Image Loader Animation with CAShapeLayer](https://www.raywenderlich.com/94302/implement-circular-image-loader-animation-cashapelayer)\n> 原文作者 :Rounak Jain\n> 译文出自 :[开发技术前线 www.devtf.cn](http://www.devtf.cn/)\n> 译者 :Sam Lau\n> 校对者:Lollypo\n> 译者简书：[使用CAShapeLayer来实现圆形图片加载动画 译](http://www.jianshu.com/p/16ef46c14515)\n\n原文使用swift实现。这里我用OC实现了一遍，并添加了详细的注释。\n\n效果如下：\n\n\n![](http://upload-images.jianshu.io/upload_images/332029-ca6768881f0529a5.gif?imageMogr2/auto-orient/strip)\n\n代码及注释：\n[戳这里](https://github.com/yehot/CircularImageLoder)\n\n\n","source":"_posts/20150901-CAShapeLayer.md","raw":"---\ntitle: CAShapeLayer 实现圆形图片加载动画\ndate: 2015-09-01 22:06:30\ntags: CALayer\ncategories: Animation\n---\n\n> 原文链接 :[How To Implement A Circular Image Loader Animation with CAShapeLayer](https://www.raywenderlich.com/94302/implement-circular-image-loader-animation-cashapelayer)\n> 原文作者 :Rounak Jain\n> 译文出自 :[开发技术前线 www.devtf.cn](http://www.devtf.cn/)\n> 译者 :Sam Lau\n> 校对者:Lollypo\n> 译者简书：[使用CAShapeLayer来实现圆形图片加载动画 译](http://www.jianshu.com/p/16ef46c14515)\n\n原文使用swift实现。这里我用OC实现了一遍，并添加了详细的注释。\n\n效果如下：\n\n\n![](http://upload-images.jianshu.io/upload_images/332029-ca6768881f0529a5.gif?imageMogr2/auto-orient/strip)\n\n代码及注释：\n[戳这里](https://github.com/yehot/CircularImageLoder)\n\n\n","slug":"20150901-CAShapeLayer","published":1,"updated":"2019-04-18T11:06:48.745Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjumvmx9i0002raxe45yc8cg3","content":"<blockquote>\n<p>原文链接 :<a href=\"https://www.raywenderlich.com/94302/implement-circular-image-loader-animation-cashapelayer\" target=\"_blank\" rel=\"noopener\">How To Implement A Circular Image Loader Animation with CAShapeLayer</a><br>原文作者 :Rounak Jain<br>译文出自 :<a href=\"http://www.devtf.cn/\" target=\"_blank\" rel=\"noopener\">开发技术前线 www.devtf.cn</a><br>译者 :Sam Lau<br>校对者:Lollypo<br>译者简书：<a href=\"http://www.jianshu.com/p/16ef46c14515\" target=\"_blank\" rel=\"noopener\">使用CAShapeLayer来实现圆形图片加载动画 译</a></p>\n</blockquote>\n<p>原文使用swift实现。这里我用OC实现了一遍，并添加了详细的注释。</p>\n<p>效果如下：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/332029-ca6768881f0529a5.gif?imageMogr2/auto-orient/strip\" alt></p>\n<p>代码及注释：<br><a href=\"https://github.com/yehot/CircularImageLoder\" target=\"_blank\" rel=\"noopener\">戳这里</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>原文链接 :<a href=\"https://www.raywenderlich.com/94302/implement-circular-image-loader-animation-cashapelayer\" target=\"_blank\" rel=\"noopener\">How To Implement A Circular Image Loader Animation with CAShapeLayer</a><br>原文作者 :Rounak Jain<br>译文出自 :<a href=\"http://www.devtf.cn/\" target=\"_blank\" rel=\"noopener\">开发技术前线 www.devtf.cn</a><br>译者 :Sam Lau<br>校对者:Lollypo<br>译者简书：<a href=\"http://www.jianshu.com/p/16ef46c14515\" target=\"_blank\" rel=\"noopener\">使用CAShapeLayer来实现圆形图片加载动画 译</a></p>\n</blockquote>\n<p>原文使用swift实现。这里我用OC实现了一遍，并添加了详细的注释。</p>\n<p>效果如下：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/332029-ca6768881f0529a5.gif?imageMogr2/auto-orient/strip\" alt></p>\n<p>代码及注释：<br><a href=\"https://github.com/yehot/CircularImageLoder\" target=\"_blank\" rel=\"noopener\">戳这里</a></p>\n"},{"title":"自定义可配置开关的NSLog","date":"2015-09-09T13:55:34.000Z","_content":"\n#自定义可配置开关的NSLog\n\n参考：[iOS自定义NSLog日志](http://www.verydemo.com/demo_c134_i22023.html)\n\n>最近公司要求封装一套打包成 .a 静态库的SDK，需要在SDK中输出一些Log信息。\n>参考友盟、JPush等SDK写法，想给Log配置一个开关，方便使用SDK时可以控制打开或关闭Log输出。\n\n***\n###以下是SDK只提供 .a 静态库时的一种解决思路：\n\n#import <Foundation/Foundation.h>\n\n\n```\n\n/**\n *  自定义Log，可配置开关（用于替换NSLog）\n */\n#define KDS_Log(format,...) CustomLog(__FUNCTION__,__LINE__,format,##__VA_ARGS__)\n\n/**\n *  自定义Log\n *  @warning 外部可直接调用 KDS_Log\n *\n *  @param func         方法名\n *  @param lineNumber   行号\n *  @param format       Log内容\n *  @param ...          个数可变的Log参数\n */\nvoid CustomLog(const char *func, int lineNumber, NSString *format, ...);\n\n/**\n *  自定义Log类，外部控制Log开关\n */\n@interface KDS_CustomLog : NSObject\n\n/**\n *  Log 输出开关 (默认关闭)\n *\n *  @param flag 是否开启\n */\n+ (void)setLogEnable:(BOOL)flag;\n\n/**\n *  是否开启了 Log 输出\n *\n *  @return Log 开关状态\n */\n+ (BOOL)logEnable;\n\n@end\n```\n\n```\n#import \"KDS_CustomLog.h\"\n\n// Log 开关状态，默认不输出log信息\nstatic BOOL KDS_Log_Switch = NO;\n\n@implementation KDS_CustomLog\n\nvoid CustomLog(const char *func, int lineNumber, NSString *format, ...)\n{\n    if ([KDS_CustomLog logEnable]) {  // 开启了Log\n        va_list args;\n        va_start(args, format);\n        NSString *string = [[NSString alloc] initWithFormat:format arguments:args];\n        va_end(args);\n        \n        NSString *strFormat = [NSString stringWithFormat:@\"%s, Line:%i, SDK_Log:%@\",func,lineNumber,string];\n        NSLog(@\"%@\", strFormat);\n    }\n}\n\n+ (BOOL)logEnable {\n    return KDS_Log_Switch;\n}\n\n+ (void)setLogEnable:(BOOL)flag {\n    KDS_Log_Switch = flag;\n}\n\n@end\n```\n\n***\n>以下是调用方式:\n\n```\n#import \"KDS_CustomLog.h\"\n\n- (void)logTest\n{\n    [KDS_CustomLog setLogEnable:YES];\n    KDS_Log(@\"打开\");\n    NSLog(@\"%d\",[KDS_CustomLog logEnable]);\n    \n    [KDS_CustomLog setLogEnable:NO];\n    KDS_Log(@\"关闭\");\n    NSLog(@\"%d\",[KDS_CustomLog logEnable]);\n    \n    [KDS_CustomLog setLogEnable:YES];\n    KDS_Log(@\"打开\");\n    NSLog(@\"%d\",[KDS_CustomLog logEnable]);\n}\n```\n\n***\n>和控制台输出结果:\n\n![输出结果.png](http://upload-images.jianshu.io/upload_images/332029-ca2146bba67d2629.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n***\n\n\n（如果有任何问题，欢迎指出！）\n\n***\n","source":"_posts/20150909-custom-NSLog.md","raw":"---\ntitle: 自定义可配置开关的NSLog\ndate: 2015-09-09 21:55:34\ntags:\ncategories: Tool\n---\n\n#自定义可配置开关的NSLog\n\n参考：[iOS自定义NSLog日志](http://www.verydemo.com/demo_c134_i22023.html)\n\n>最近公司要求封装一套打包成 .a 静态库的SDK，需要在SDK中输出一些Log信息。\n>参考友盟、JPush等SDK写法，想给Log配置一个开关，方便使用SDK时可以控制打开或关闭Log输出。\n\n***\n###以下是SDK只提供 .a 静态库时的一种解决思路：\n\n#import <Foundation/Foundation.h>\n\n\n```\n\n/**\n *  自定义Log，可配置开关（用于替换NSLog）\n */\n#define KDS_Log(format,...) CustomLog(__FUNCTION__,__LINE__,format,##__VA_ARGS__)\n\n/**\n *  自定义Log\n *  @warning 外部可直接调用 KDS_Log\n *\n *  @param func         方法名\n *  @param lineNumber   行号\n *  @param format       Log内容\n *  @param ...          个数可变的Log参数\n */\nvoid CustomLog(const char *func, int lineNumber, NSString *format, ...);\n\n/**\n *  自定义Log类，外部控制Log开关\n */\n@interface KDS_CustomLog : NSObject\n\n/**\n *  Log 输出开关 (默认关闭)\n *\n *  @param flag 是否开启\n */\n+ (void)setLogEnable:(BOOL)flag;\n\n/**\n *  是否开启了 Log 输出\n *\n *  @return Log 开关状态\n */\n+ (BOOL)logEnable;\n\n@end\n```\n\n```\n#import \"KDS_CustomLog.h\"\n\n// Log 开关状态，默认不输出log信息\nstatic BOOL KDS_Log_Switch = NO;\n\n@implementation KDS_CustomLog\n\nvoid CustomLog(const char *func, int lineNumber, NSString *format, ...)\n{\n    if ([KDS_CustomLog logEnable]) {  // 开启了Log\n        va_list args;\n        va_start(args, format);\n        NSString *string = [[NSString alloc] initWithFormat:format arguments:args];\n        va_end(args);\n        \n        NSString *strFormat = [NSString stringWithFormat:@\"%s, Line:%i, SDK_Log:%@\",func,lineNumber,string];\n        NSLog(@\"%@\", strFormat);\n    }\n}\n\n+ (BOOL)logEnable {\n    return KDS_Log_Switch;\n}\n\n+ (void)setLogEnable:(BOOL)flag {\n    KDS_Log_Switch = flag;\n}\n\n@end\n```\n\n***\n>以下是调用方式:\n\n```\n#import \"KDS_CustomLog.h\"\n\n- (void)logTest\n{\n    [KDS_CustomLog setLogEnable:YES];\n    KDS_Log(@\"打开\");\n    NSLog(@\"%d\",[KDS_CustomLog logEnable]);\n    \n    [KDS_CustomLog setLogEnable:NO];\n    KDS_Log(@\"关闭\");\n    NSLog(@\"%d\",[KDS_CustomLog logEnable]);\n    \n    [KDS_CustomLog setLogEnable:YES];\n    KDS_Log(@\"打开\");\n    NSLog(@\"%d\",[KDS_CustomLog logEnable]);\n}\n```\n\n***\n>和控制台输出结果:\n\n![输出结果.png](http://upload-images.jianshu.io/upload_images/332029-ca2146bba67d2629.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n***\n\n\n（如果有任何问题，欢迎指出！）\n\n***\n","slug":"20150909-custom-NSLog","published":1,"updated":"2019-04-18T11:06:48.746Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjumvmx9n0006raxe2mb93ezo","content":"<p>#自定义可配置开关的NSLog</p>\n<p>参考：<a href=\"http://www.verydemo.com/demo_c134_i22023.html\" target=\"_blank\" rel=\"noopener\">iOS自定义NSLog日志</a></p>\n<blockquote>\n<p>最近公司要求封装一套打包成 .a 静态库的SDK，需要在SDK中输出一些Log信息。<br>参考友盟、JPush等SDK写法，想给Log配置一个开关，方便使用SDK时可以控制打开或关闭Log输出。</p>\n</blockquote>\n<hr>\n<p>###以下是SDK只提供 .a 静态库时的一种解决思路：</p>\n<p>#import &lt;Foundation/Foundation.h&gt;</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> *  自定义Log，可配置开关（用于替换NSLog）</span><br><span class=\"line\"> */</span><br><span class=\"line\">#define KDS_Log(format,...) CustomLog(__FUNCTION__,__LINE__,format,##__VA_ARGS__)</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> *  自定义Log</span><br><span class=\"line\"> *  @warning 外部可直接调用 KDS_Log</span><br><span class=\"line\"> *</span><br><span class=\"line\"> *  @param func         方法名</span><br><span class=\"line\"> *  @param lineNumber   行号</span><br><span class=\"line\"> *  @param format       Log内容</span><br><span class=\"line\"> *  @param ...          个数可变的Log参数</span><br><span class=\"line\"> */</span><br><span class=\"line\">void CustomLog(const char *func, int lineNumber, NSString *format, ...);</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> *  自定义Log类，外部控制Log开关</span><br><span class=\"line\"> */</span><br><span class=\"line\">@interface KDS_CustomLog : NSObject</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> *  Log 输出开关 (默认关闭)</span><br><span class=\"line\"> *</span><br><span class=\"line\"> *  @param flag 是否开启</span><br><span class=\"line\"> */</span><br><span class=\"line\">+ (void)setLogEnable:(BOOL)flag;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> *  是否开启了 Log 输出</span><br><span class=\"line\"> *</span><br><span class=\"line\"> *  @return Log 开关状态</span><br><span class=\"line\"> */</span><br><span class=\"line\">+ (BOOL)logEnable;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;KDS_CustomLog.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">// Log 开关状态，默认不输出log信息</span><br><span class=\"line\">static BOOL KDS_Log_Switch = NO;</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation KDS_CustomLog</span><br><span class=\"line\"></span><br><span class=\"line\">void CustomLog(const char *func, int lineNumber, NSString *format, ...)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if ([KDS_CustomLog logEnable]) &#123;  // 开启了Log</span><br><span class=\"line\">        va_list args;</span><br><span class=\"line\">        va_start(args, format);</span><br><span class=\"line\">        NSString *string = [[NSString alloc] initWithFormat:format arguments:args];</span><br><span class=\"line\">        va_end(args);</span><br><span class=\"line\">        </span><br><span class=\"line\">        NSString *strFormat = [NSString stringWithFormat:@&quot;%s, Line:%i, SDK_Log:%@&quot;,func,lineNumber,string];</span><br><span class=\"line\">        NSLog(@&quot;%@&quot;, strFormat);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (BOOL)logEnable &#123;</span><br><span class=\"line\">    return KDS_Log_Switch;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)setLogEnable:(BOOL)flag &#123;</span><br><span class=\"line\">    KDS_Log_Switch = flag;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<hr>\n<blockquote>\n<p>以下是调用方式:</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;KDS_CustomLog.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)logTest</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [KDS_CustomLog setLogEnable:YES];</span><br><span class=\"line\">    KDS_Log(@&quot;打开&quot;);</span><br><span class=\"line\">    NSLog(@&quot;%d&quot;,[KDS_CustomLog logEnable]);</span><br><span class=\"line\">    </span><br><span class=\"line\">    [KDS_CustomLog setLogEnable:NO];</span><br><span class=\"line\">    KDS_Log(@&quot;关闭&quot;);</span><br><span class=\"line\">    NSLog(@&quot;%d&quot;,[KDS_CustomLog logEnable]);</span><br><span class=\"line\">    </span><br><span class=\"line\">    [KDS_CustomLog setLogEnable:YES];</span><br><span class=\"line\">    KDS_Log(@&quot;打开&quot;);</span><br><span class=\"line\">    NSLog(@&quot;%d&quot;,[KDS_CustomLog logEnable]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<blockquote>\n<p>和控制台输出结果:</p>\n</blockquote>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/332029-ca2146bba67d2629.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"输出结果.png\"></p>\n<hr>\n<p>（如果有任何问题，欢迎指出！）</p>\n<hr>\n","site":{"data":{}},"excerpt":"","more":"<p>#自定义可配置开关的NSLog</p>\n<p>参考：<a href=\"http://www.verydemo.com/demo_c134_i22023.html\" target=\"_blank\" rel=\"noopener\">iOS自定义NSLog日志</a></p>\n<blockquote>\n<p>最近公司要求封装一套打包成 .a 静态库的SDK，需要在SDK中输出一些Log信息。<br>参考友盟、JPush等SDK写法，想给Log配置一个开关，方便使用SDK时可以控制打开或关闭Log输出。</p>\n</blockquote>\n<hr>\n<p>###以下是SDK只提供 .a 静态库时的一种解决思路：</p>\n<p>#import &lt;Foundation/Foundation.h&gt;</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> *  自定义Log，可配置开关（用于替换NSLog）</span><br><span class=\"line\"> */</span><br><span class=\"line\">#define KDS_Log(format,...) CustomLog(__FUNCTION__,__LINE__,format,##__VA_ARGS__)</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> *  自定义Log</span><br><span class=\"line\"> *  @warning 外部可直接调用 KDS_Log</span><br><span class=\"line\"> *</span><br><span class=\"line\"> *  @param func         方法名</span><br><span class=\"line\"> *  @param lineNumber   行号</span><br><span class=\"line\"> *  @param format       Log内容</span><br><span class=\"line\"> *  @param ...          个数可变的Log参数</span><br><span class=\"line\"> */</span><br><span class=\"line\">void CustomLog(const char *func, int lineNumber, NSString *format, ...);</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> *  自定义Log类，外部控制Log开关</span><br><span class=\"line\"> */</span><br><span class=\"line\">@interface KDS_CustomLog : NSObject</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> *  Log 输出开关 (默认关闭)</span><br><span class=\"line\"> *</span><br><span class=\"line\"> *  @param flag 是否开启</span><br><span class=\"line\"> */</span><br><span class=\"line\">+ (void)setLogEnable:(BOOL)flag;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> *  是否开启了 Log 输出</span><br><span class=\"line\"> *</span><br><span class=\"line\"> *  @return Log 开关状态</span><br><span class=\"line\"> */</span><br><span class=\"line\">+ (BOOL)logEnable;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;KDS_CustomLog.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">// Log 开关状态，默认不输出log信息</span><br><span class=\"line\">static BOOL KDS_Log_Switch = NO;</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation KDS_CustomLog</span><br><span class=\"line\"></span><br><span class=\"line\">void CustomLog(const char *func, int lineNumber, NSString *format, ...)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if ([KDS_CustomLog logEnable]) &#123;  // 开启了Log</span><br><span class=\"line\">        va_list args;</span><br><span class=\"line\">        va_start(args, format);</span><br><span class=\"line\">        NSString *string = [[NSString alloc] initWithFormat:format arguments:args];</span><br><span class=\"line\">        va_end(args);</span><br><span class=\"line\">        </span><br><span class=\"line\">        NSString *strFormat = [NSString stringWithFormat:@&quot;%s, Line:%i, SDK_Log:%@&quot;,func,lineNumber,string];</span><br><span class=\"line\">        NSLog(@&quot;%@&quot;, strFormat);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (BOOL)logEnable &#123;</span><br><span class=\"line\">    return KDS_Log_Switch;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)setLogEnable:(BOOL)flag &#123;</span><br><span class=\"line\">    KDS_Log_Switch = flag;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<hr>\n<blockquote>\n<p>以下是调用方式:</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;KDS_CustomLog.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)logTest</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [KDS_CustomLog setLogEnable:YES];</span><br><span class=\"line\">    KDS_Log(@&quot;打开&quot;);</span><br><span class=\"line\">    NSLog(@&quot;%d&quot;,[KDS_CustomLog logEnable]);</span><br><span class=\"line\">    </span><br><span class=\"line\">    [KDS_CustomLog setLogEnable:NO];</span><br><span class=\"line\">    KDS_Log(@&quot;关闭&quot;);</span><br><span class=\"line\">    NSLog(@&quot;%d&quot;,[KDS_CustomLog logEnable]);</span><br><span class=\"line\">    </span><br><span class=\"line\">    [KDS_CustomLog setLogEnable:YES];</span><br><span class=\"line\">    KDS_Log(@&quot;打开&quot;);</span><br><span class=\"line\">    NSLog(@&quot;%d&quot;,[KDS_CustomLog logEnable]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<blockquote>\n<p>和控制台输出结果:</p>\n</blockquote>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/332029-ca2146bba67d2629.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"输出结果.png\"></p>\n<hr>\n<p>（如果有任何问题，欢迎指出！）</p>\n<hr>\n"},{"title":"iOS查看屏幕帧数工具--YYFPSLabel","date":"2016-04-05T15:23:36.000Z","_content":"\n学习 **[YYKit](https://github.com/ibireme/YYKit)** 代码时，发现 [ibireme](https://github.com/ibireme) 在项目里加入的一个查看当前屏幕帧数的小工具，效果如下：\n\n![](http://upload-images.jianshu.io/upload_images/332029-36fb1bdbfb423531.gif?imageMogr2/auto-orient/strip)\n\n挺实用的，实现方法也很简单，但是思路特别棒。\n\n####这里是Demo： **[YYFPSLabel](https://github.com/yehot/YYFPSLabel)**\n\n\n这里我把这个小工具从 YYKit 中抽出来，在学习大牛的代码的过程中，收货了不少东西，这里**做个笔记**：\n\n###1、FPSLabel 实现思路：\n使用 CADisplayLink 的 timestamp 属性，配合 timer 的执行次数计算得出 FPS数，详见[代码](https://github.com/yehot/YYFPSLabel/blob/master/YYFPSLabel/YYFPSLabel/YYFPSLabel.m)。\n\n###2、NSTimer、CADisplayLink 常见问题：\n>**问题1：** UIScrollView 在滑动时，timer 会被暂停的问题。\n\n—— 原因：runloop mode 导致。iOS处理滑动时，mainloop 中UIScrollView的mode是 UITrackingRunLoopMode，会优先保证界面流畅，而 timer 默认的model是 NSDefaultRunLoopMode，所以会出现被暂停。\n—— 解决办法：将timer加到 NSRunLoopCommonModes 中。\n```\n    [_link addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes];\n```\n\n详见：[深入理解RunLoop](http://blog.ibireme.com/2015/05/18/runloop/) 一文中关于 [定时器](http://blog.ibireme.com/2015/05/18/runloop/#timer)  和 [RunLoop 的 Mode](http://blog.ibireme.com/2015/05/18/runloop/#mode) 的部分\n>**问题2：**NSTimer 对于 target 的循环引用问题：\n\n以下代码很常见：\n```\n    CADisplayLink *_link = [CADisplayLink displayLinkWithTarget:self selector:@selector(tick:)];\n\n    [NSTimer timerWithTimeInterval:1.f target:self selector:@selector(tick:) userInfo:nil repeats:YES];\n\n```\n—— 原因：以上两种用法，都会对self强引用，此时 timer持有 self，self 也持有 timer，循环引用导致页面 dismiss 时，双方都无法释放，造成循环引用。\n此时使用 __weak 也不能有效解决:\n```\n    __weak typeof(self) weakSelf = self;\n    _link = [CADisplayLink displayLinkWithTarget:weakSelf selector:@selector(tick:)];\n```\n效果如下：\n\n![](http://upload-images.jianshu.io/upload_images/332029-6b2957fc2ff9cc8b.gif?imageMogr2/auto-orient/strip)\n\n**可以看到 页面 dismiss 后，计时器仍然在打印**\n\n**—— 解决办法：1、**在页面退出前，或者合适的时候，手动停止 timer，结束循环引用。\n\n注意：在 dealloc 方法中是肯定不行的！由于循环引用，dealloc 方法不会进。\n![](http://upload-images.jianshu.io/upload_images/332029-90b68a2f2381e4f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n**——解决办法：2、**YYFPSLabel 作者提供的 [YYWeakProxy](https://github.com/yehot/YYFPSLabel/blob/master/YYFPSLabel/YYFPSLabel/YYWeakProxy.m)\n\n```\n@interface YYWeakProxy : NSProxy\n@end\n\n// 使用方式：\n    _link = [CADisplayLink displayLinkWithTarget:[YYWeakProxy proxyWithTarget:self] selector:@selector(tick:)];\n\n```\n代码很少，有兴趣可以自己看下源码。\n**Tips：** OC中 NSProxy 是不继承自 NSObject 的。\n\n###3、探索环节：iOS中子线程检测主线程\n>在和小伙伴分享这个小工具的时候，潘神抛出了这样一个**问题**：\n这里组件是在主线程绘制的label，如果主线程阻塞了还能用吗？\n\n\n结果是不能。\n####以下是探索阶段：\n\n1、模拟主线程阻塞，将 link 放在子线程，发现 timer 不能启动\n\n```OC\n    // 模拟 主线程阻塞 （不应该模拟主线程卡死，模拟卡顿即可）\n    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0f * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{  \n        NSLog(@\"即将阻塞\");\n        dispatch_sync(dispatch_get_main_queue(), ^{\n            NSLog(@\"同步阻塞主线程\");\n        });\n        NSLog(@\"不会执行\");\n    });\n```\n\n2、使用CFRunLoopAddObserver检测主线程是否卡顿：\n\n```\n//将观察者添加到主线程runloop的common模式下的观察中\nCFRunLoopAddObserver(CFRunLoopGetMain(), runLoopObserver, kCFRunLoopCommonModes);\n```\n\n这里是能检测到主线程是否卡顿了，但是 timer 在子线程中还是跑不起来。\n\n参考 [Starming星光社](https://www.google.com.hk/url?sa=t&rct=j&q=&esrc=s&source=web&cd=1&ved=0ahUKEwjx0Zjw4_fLAhWVj44KHdkUAvwQFggbMAA&url=%68%74%74%70%3a%2f%2f%77%77%77%2e%73%74%61%72%6d%69%6e%67%2e%63%6f%6d%2f&usg=AFQjCNF2xjShwXV0aXfKo1yXQHN95DRCAA&sig2=C_ywHG5vt8byOOqA6x-bOw) 的 [检测iOS的APP性能的一些方法](http://www.starming.com/index.php?v=index&view=91)\n\n3、在子线程手动创建一个 runloop，提供给 timer。\n```\n    dispatch_async(dispatch_get_global_queue(0, 0), ^{\n        _link = [CADisplayLink displayLinkWithTarget:self selector:@selector(tick:)];\n        // NOTE: 子线程的runloop默认不创建； 在子线程获取 currentRunLoop 对象的时候，就会自动创建RunLoop\n        // 这里不加到 main loop，必须创建一个 runloop\n        NSRunLoop *runloop = [NSRunLoop currentRunLoop];\n        [_link addToRunLoop:runloop forMode:NSRunLoopCommonModes];\n        // 必须 timer addToRunLoop 后，再run\n        [runloop run];\n    });\n```\n\n这样，就可以在子线程中使用 timer 了，但是此时只能 log，无法获通知主线程更新UI： (这里先不在主线程更新UI了)\n```\n// 尝试1：主线程阻塞， 这里就不能获取到主线程了\n//    dispatch_async(dispatch_get_main_queue(), ^{\n//        阻塞时，想通过 在主线程更新UI 来查看是不可行了\n//        label_.text = text;\n//    });\n    \n    // 尝试2：不在主线程操作 UI ，界面会发生变化\n    label_.text = text;\n```\n\n参考: [【iOS程序启动与运转】- RunLoop个人小结](http://www.jianshu.com/p/37ab0397fec7)\n\n\n以上是学习 YYFPSLabel 时的收获，和对于在子线程中检测主线程的探索。详情可以戳代码：\n**[YYFPSLabel](https://github.com/yehot/YYFPSLabel)**\n","source":"_posts/20160405-YYFPSLabel-source-read.md","raw":"---\ntitle: iOS查看屏幕帧数工具--YYFPSLabel\ndate: 2016-04-05 23:23:36\ntags:\ncategories: Tool\n---\n\n学习 **[YYKit](https://github.com/ibireme/YYKit)** 代码时，发现 [ibireme](https://github.com/ibireme) 在项目里加入的一个查看当前屏幕帧数的小工具，效果如下：\n\n![](http://upload-images.jianshu.io/upload_images/332029-36fb1bdbfb423531.gif?imageMogr2/auto-orient/strip)\n\n挺实用的，实现方法也很简单，但是思路特别棒。\n\n####这里是Demo： **[YYFPSLabel](https://github.com/yehot/YYFPSLabel)**\n\n\n这里我把这个小工具从 YYKit 中抽出来，在学习大牛的代码的过程中，收货了不少东西，这里**做个笔记**：\n\n###1、FPSLabel 实现思路：\n使用 CADisplayLink 的 timestamp 属性，配合 timer 的执行次数计算得出 FPS数，详见[代码](https://github.com/yehot/YYFPSLabel/blob/master/YYFPSLabel/YYFPSLabel/YYFPSLabel.m)。\n\n###2、NSTimer、CADisplayLink 常见问题：\n>**问题1：** UIScrollView 在滑动时，timer 会被暂停的问题。\n\n—— 原因：runloop mode 导致。iOS处理滑动时，mainloop 中UIScrollView的mode是 UITrackingRunLoopMode，会优先保证界面流畅，而 timer 默认的model是 NSDefaultRunLoopMode，所以会出现被暂停。\n—— 解决办法：将timer加到 NSRunLoopCommonModes 中。\n```\n    [_link addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes];\n```\n\n详见：[深入理解RunLoop](http://blog.ibireme.com/2015/05/18/runloop/) 一文中关于 [定时器](http://blog.ibireme.com/2015/05/18/runloop/#timer)  和 [RunLoop 的 Mode](http://blog.ibireme.com/2015/05/18/runloop/#mode) 的部分\n>**问题2：**NSTimer 对于 target 的循环引用问题：\n\n以下代码很常见：\n```\n    CADisplayLink *_link = [CADisplayLink displayLinkWithTarget:self selector:@selector(tick:)];\n\n    [NSTimer timerWithTimeInterval:1.f target:self selector:@selector(tick:) userInfo:nil repeats:YES];\n\n```\n—— 原因：以上两种用法，都会对self强引用，此时 timer持有 self，self 也持有 timer，循环引用导致页面 dismiss 时，双方都无法释放，造成循环引用。\n此时使用 __weak 也不能有效解决:\n```\n    __weak typeof(self) weakSelf = self;\n    _link = [CADisplayLink displayLinkWithTarget:weakSelf selector:@selector(tick:)];\n```\n效果如下：\n\n![](http://upload-images.jianshu.io/upload_images/332029-6b2957fc2ff9cc8b.gif?imageMogr2/auto-orient/strip)\n\n**可以看到 页面 dismiss 后，计时器仍然在打印**\n\n**—— 解决办法：1、**在页面退出前，或者合适的时候，手动停止 timer，结束循环引用。\n\n注意：在 dealloc 方法中是肯定不行的！由于循环引用，dealloc 方法不会进。\n![](http://upload-images.jianshu.io/upload_images/332029-90b68a2f2381e4f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n**——解决办法：2、**YYFPSLabel 作者提供的 [YYWeakProxy](https://github.com/yehot/YYFPSLabel/blob/master/YYFPSLabel/YYFPSLabel/YYWeakProxy.m)\n\n```\n@interface YYWeakProxy : NSProxy\n@end\n\n// 使用方式：\n    _link = [CADisplayLink displayLinkWithTarget:[YYWeakProxy proxyWithTarget:self] selector:@selector(tick:)];\n\n```\n代码很少，有兴趣可以自己看下源码。\n**Tips：** OC中 NSProxy 是不继承自 NSObject 的。\n\n###3、探索环节：iOS中子线程检测主线程\n>在和小伙伴分享这个小工具的时候，潘神抛出了这样一个**问题**：\n这里组件是在主线程绘制的label，如果主线程阻塞了还能用吗？\n\n\n结果是不能。\n####以下是探索阶段：\n\n1、模拟主线程阻塞，将 link 放在子线程，发现 timer 不能启动\n\n```OC\n    // 模拟 主线程阻塞 （不应该模拟主线程卡死，模拟卡顿即可）\n    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0f * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{  \n        NSLog(@\"即将阻塞\");\n        dispatch_sync(dispatch_get_main_queue(), ^{\n            NSLog(@\"同步阻塞主线程\");\n        });\n        NSLog(@\"不会执行\");\n    });\n```\n\n2、使用CFRunLoopAddObserver检测主线程是否卡顿：\n\n```\n//将观察者添加到主线程runloop的common模式下的观察中\nCFRunLoopAddObserver(CFRunLoopGetMain(), runLoopObserver, kCFRunLoopCommonModes);\n```\n\n这里是能检测到主线程是否卡顿了，但是 timer 在子线程中还是跑不起来。\n\n参考 [Starming星光社](https://www.google.com.hk/url?sa=t&rct=j&q=&esrc=s&source=web&cd=1&ved=0ahUKEwjx0Zjw4_fLAhWVj44KHdkUAvwQFggbMAA&url=%68%74%74%70%3a%2f%2f%77%77%77%2e%73%74%61%72%6d%69%6e%67%2e%63%6f%6d%2f&usg=AFQjCNF2xjShwXV0aXfKo1yXQHN95DRCAA&sig2=C_ywHG5vt8byOOqA6x-bOw) 的 [检测iOS的APP性能的一些方法](http://www.starming.com/index.php?v=index&view=91)\n\n3、在子线程手动创建一个 runloop，提供给 timer。\n```\n    dispatch_async(dispatch_get_global_queue(0, 0), ^{\n        _link = [CADisplayLink displayLinkWithTarget:self selector:@selector(tick:)];\n        // NOTE: 子线程的runloop默认不创建； 在子线程获取 currentRunLoop 对象的时候，就会自动创建RunLoop\n        // 这里不加到 main loop，必须创建一个 runloop\n        NSRunLoop *runloop = [NSRunLoop currentRunLoop];\n        [_link addToRunLoop:runloop forMode:NSRunLoopCommonModes];\n        // 必须 timer addToRunLoop 后，再run\n        [runloop run];\n    });\n```\n\n这样，就可以在子线程中使用 timer 了，但是此时只能 log，无法获通知主线程更新UI： (这里先不在主线程更新UI了)\n```\n// 尝试1：主线程阻塞， 这里就不能获取到主线程了\n//    dispatch_async(dispatch_get_main_queue(), ^{\n//        阻塞时，想通过 在主线程更新UI 来查看是不可行了\n//        label_.text = text;\n//    });\n    \n    // 尝试2：不在主线程操作 UI ，界面会发生变化\n    label_.text = text;\n```\n\n参考: [【iOS程序启动与运转】- RunLoop个人小结](http://www.jianshu.com/p/37ab0397fec7)\n\n\n以上是学习 YYFPSLabel 时的收获，和对于在子线程中检测主线程的探索。详情可以戳代码：\n**[YYFPSLabel](https://github.com/yehot/YYFPSLabel)**\n","slug":"20160405-YYFPSLabel-source-read","published":1,"updated":"2019-04-18T11:06:48.747Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjumvmx9o0007raxegfoijiz0","content":"<p>学习 <strong><a href=\"https://github.com/ibireme/YYKit\" target=\"_blank\" rel=\"noopener\">YYKit</a></strong> 代码时，发现 <a href=\"https://github.com/ibireme\" target=\"_blank\" rel=\"noopener\">ibireme</a> 在项目里加入的一个查看当前屏幕帧数的小工具，效果如下：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/332029-36fb1bdbfb423531.gif?imageMogr2/auto-orient/strip\" alt></p>\n<p>挺实用的，实现方法也很简单，但是思路特别棒。</p>\n<p>####这里是Demo： <strong><a href=\"https://github.com/yehot/YYFPSLabel\" target=\"_blank\" rel=\"noopener\">YYFPSLabel</a></strong></p>\n<p>这里我把这个小工具从 YYKit 中抽出来，在学习大牛的代码的过程中，收货了不少东西，这里<strong>做个笔记</strong>：</p>\n<p>###1、FPSLabel 实现思路：<br>使用 CADisplayLink 的 timestamp 属性，配合 timer 的执行次数计算得出 FPS数，详见<a href=\"https://github.com/yehot/YYFPSLabel/blob/master/YYFPSLabel/YYFPSLabel/YYFPSLabel.m\" target=\"_blank\" rel=\"noopener\">代码</a>。</p>\n<p>###2、NSTimer、CADisplayLink 常见问题：</p>\n<blockquote>\n<p><strong>问题1：</strong> UIScrollView 在滑动时，timer 会被暂停的问题。</p>\n</blockquote>\n<p>—— 原因：runloop mode 导致。iOS处理滑动时，mainloop 中UIScrollView的mode是 UITrackingRunLoopMode，会优先保证界面流畅，而 timer 默认的model是 NSDefaultRunLoopMode，所以会出现被暂停。<br>—— 解决办法：将timer加到 NSRunLoopCommonModes 中。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    [_link addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes];</span><br></pre></td></tr></table></figure></p>\n<p>详见：<a href=\"http://blog.ibireme.com/2015/05/18/runloop/\" target=\"_blank\" rel=\"noopener\">深入理解RunLoop</a> 一文中关于 <a href=\"http://blog.ibireme.com/2015/05/18/runloop/#timer\" target=\"_blank\" rel=\"noopener\">定时器</a>  和 <a href=\"http://blog.ibireme.com/2015/05/18/runloop/#mode\" target=\"_blank\" rel=\"noopener\">RunLoop 的 Mode</a> 的部分</p>\n<blockquote>\n<p><strong>问题2：</strong>NSTimer 对于 target 的循环引用问题：</p>\n</blockquote>\n<p>以下代码很常见：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CADisplayLink *_link = [CADisplayLink displayLinkWithTarget:self selector:@selector(tick:)];</span><br><span class=\"line\"></span><br><span class=\"line\">    [NSTimer timerWithTimeInterval:1.f target:self selector:@selector(tick:) userInfo:nil repeats:YES];</span><br></pre></td></tr></table></figure></p>\n<p>—— 原因：以上两种用法，都会对self强引用，此时 timer持有 self，self 也持有 timer，循环引用导致页面 dismiss 时，双方都无法释放，造成循环引用。<br>此时使用 __weak 也不能有效解决:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    __weak typeof(self) weakSelf = self;</span><br><span class=\"line\">    _link = [CADisplayLink displayLinkWithTarget:weakSelf selector:@selector(tick:)];</span><br></pre></td></tr></table></figure></p>\n<p>效果如下：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/332029-6b2957fc2ff9cc8b.gif?imageMogr2/auto-orient/strip\" alt></p>\n<p><strong>可以看到 页面 dismiss 后，计时器仍然在打印</strong></p>\n<p><strong>—— 解决办法：1、</strong>在页面退出前，或者合适的时候，手动停止 timer，结束循环引用。</p>\n<p>注意：在 dealloc 方法中是肯定不行的！由于循环引用，dealloc 方法不会进。<br><img src=\"http://upload-images.jianshu.io/upload_images/332029-90b68a2f2381e4f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt></p>\n<p><strong>——解决办法：2、</strong>YYFPSLabel 作者提供的 <a href=\"https://github.com/yehot/YYFPSLabel/blob/master/YYFPSLabel/YYFPSLabel/YYWeakProxy.m\" target=\"_blank\" rel=\"noopener\">YYWeakProxy</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface YYWeakProxy : NSProxy</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">// 使用方式：</span><br><span class=\"line\">    _link = [CADisplayLink displayLinkWithTarget:[YYWeakProxy proxyWithTarget:self] selector:@selector(tick:)];</span><br></pre></td></tr></table></figure>\n<p>代码很少，有兴趣可以自己看下源码。<br><strong>Tips：</strong> OC中 NSProxy 是不继承自 NSObject 的。</p>\n<p>###3、探索环节：iOS中子线程检测主线程</p>\n<blockquote>\n<p>在和小伙伴分享这个小工具的时候，潘神抛出了这样一个<strong>问题</strong>：<br>这里组件是在主线程绘制的label，如果主线程阻塞了还能用吗？</p>\n</blockquote>\n<p>结果是不能。</p>\n<p>####以下是探索阶段：</p>\n<p>1、模拟主线程阻塞，将 link 放在子线程，发现 timer 不能启动</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    // 模拟 主线程阻塞 （不应该模拟主线程卡死，模拟卡顿即可）</span><br><span class=\"line\">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0f * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;  </span><br><span class=\"line\">        NSLog(@&quot;即将阻塞&quot;);</span><br><span class=\"line\">        dispatch_sync(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">            NSLog(@&quot;同步阻塞主线程&quot;);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        NSLog(@&quot;不会执行&quot;);</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n<p>2、使用CFRunLoopAddObserver检测主线程是否卡顿：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//将观察者添加到主线程runloop的common模式下的观察中</span><br><span class=\"line\">CFRunLoopAddObserver(CFRunLoopGetMain(), runLoopObserver, kCFRunLoopCommonModes);</span><br></pre></td></tr></table></figure>\n<p>这里是能检测到主线程是否卡顿了，但是 timer 在子线程中还是跑不起来。</p>\n<p>参考 <a href=\"https://www.google.com.hk/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;ved=0ahUKEwjx0Zjw4_fLAhWVj44KHdkUAvwQFggbMAA&amp;url=%68%74%74%70%3a%2f%2f%77%77%77%2e%73%74%61%72%6d%69%6e%67%2e%63%6f%6d%2f&amp;usg=AFQjCNF2xjShwXV0aXfKo1yXQHN95DRCAA&amp;sig2=C_ywHG5vt8byOOqA6x-bOw\" target=\"_blank\" rel=\"noopener\">Starming星光社</a> 的 <a href=\"http://www.starming.com/index.php?v=index&amp;view=91\" target=\"_blank\" rel=\"noopener\">检测iOS的APP性能的一些方法</a></p>\n<p>3、在子线程手动创建一个 runloop，提供给 timer。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class=\"line\">        _link = [CADisplayLink displayLinkWithTarget:self selector:@selector(tick:)];</span><br><span class=\"line\">        // NOTE: 子线程的runloop默认不创建； 在子线程获取 currentRunLoop 对象的时候，就会自动创建RunLoop</span><br><span class=\"line\">        // 这里不加到 main loop，必须创建一个 runloop</span><br><span class=\"line\">        NSRunLoop *runloop = [NSRunLoop currentRunLoop];</span><br><span class=\"line\">        [_link addToRunLoop:runloop forMode:NSRunLoopCommonModes];</span><br><span class=\"line\">        // 必须 timer addToRunLoop 后，再run</span><br><span class=\"line\">        [runloop run];</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure></p>\n<p>这样，就可以在子线程中使用 timer 了，但是此时只能 log，无法获通知主线程更新UI： (这里先不在主线程更新UI了)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 尝试1：主线程阻塞， 这里就不能获取到主线程了</span><br><span class=\"line\">//    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">//        阻塞时，想通过 在主线程更新UI 来查看是不可行了</span><br><span class=\"line\">//        label_.text = text;</span><br><span class=\"line\">//    &#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 尝试2：不在主线程操作 UI ，界面会发生变化</span><br><span class=\"line\">    label_.text = text;</span><br></pre></td></tr></table></figure></p>\n<p>参考: <a href=\"http://www.jianshu.com/p/37ab0397fec7\" target=\"_blank\" rel=\"noopener\">【iOS程序启动与运转】- RunLoop个人小结</a></p>\n<p>以上是学习 YYFPSLabel 时的收获，和对于在子线程中检测主线程的探索。详情可以戳代码：<br><strong><a href=\"https://github.com/yehot/YYFPSLabel\" target=\"_blank\" rel=\"noopener\">YYFPSLabel</a></strong></p>\n","site":{"data":{}},"excerpt":"","more":"<p>学习 <strong><a href=\"https://github.com/ibireme/YYKit\" target=\"_blank\" rel=\"noopener\">YYKit</a></strong> 代码时，发现 <a href=\"https://github.com/ibireme\" target=\"_blank\" rel=\"noopener\">ibireme</a> 在项目里加入的一个查看当前屏幕帧数的小工具，效果如下：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/332029-36fb1bdbfb423531.gif?imageMogr2/auto-orient/strip\" alt></p>\n<p>挺实用的，实现方法也很简单，但是思路特别棒。</p>\n<p>####这里是Demo： <strong><a href=\"https://github.com/yehot/YYFPSLabel\" target=\"_blank\" rel=\"noopener\">YYFPSLabel</a></strong></p>\n<p>这里我把这个小工具从 YYKit 中抽出来，在学习大牛的代码的过程中，收货了不少东西，这里<strong>做个笔记</strong>：</p>\n<p>###1、FPSLabel 实现思路：<br>使用 CADisplayLink 的 timestamp 属性，配合 timer 的执行次数计算得出 FPS数，详见<a href=\"https://github.com/yehot/YYFPSLabel/blob/master/YYFPSLabel/YYFPSLabel/YYFPSLabel.m\" target=\"_blank\" rel=\"noopener\">代码</a>。</p>\n<p>###2、NSTimer、CADisplayLink 常见问题：</p>\n<blockquote>\n<p><strong>问题1：</strong> UIScrollView 在滑动时，timer 会被暂停的问题。</p>\n</blockquote>\n<p>—— 原因：runloop mode 导致。iOS处理滑动时，mainloop 中UIScrollView的mode是 UITrackingRunLoopMode，会优先保证界面流畅，而 timer 默认的model是 NSDefaultRunLoopMode，所以会出现被暂停。<br>—— 解决办法：将timer加到 NSRunLoopCommonModes 中。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    [_link addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes];</span><br></pre></td></tr></table></figure></p>\n<p>详见：<a href=\"http://blog.ibireme.com/2015/05/18/runloop/\" target=\"_blank\" rel=\"noopener\">深入理解RunLoop</a> 一文中关于 <a href=\"http://blog.ibireme.com/2015/05/18/runloop/#timer\" target=\"_blank\" rel=\"noopener\">定时器</a>  和 <a href=\"http://blog.ibireme.com/2015/05/18/runloop/#mode\" target=\"_blank\" rel=\"noopener\">RunLoop 的 Mode</a> 的部分</p>\n<blockquote>\n<p><strong>问题2：</strong>NSTimer 对于 target 的循环引用问题：</p>\n</blockquote>\n<p>以下代码很常见：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CADisplayLink *_link = [CADisplayLink displayLinkWithTarget:self selector:@selector(tick:)];</span><br><span class=\"line\"></span><br><span class=\"line\">    [NSTimer timerWithTimeInterval:1.f target:self selector:@selector(tick:) userInfo:nil repeats:YES];</span><br></pre></td></tr></table></figure></p>\n<p>—— 原因：以上两种用法，都会对self强引用，此时 timer持有 self，self 也持有 timer，循环引用导致页面 dismiss 时，双方都无法释放，造成循环引用。<br>此时使用 __weak 也不能有效解决:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    __weak typeof(self) weakSelf = self;</span><br><span class=\"line\">    _link = [CADisplayLink displayLinkWithTarget:weakSelf selector:@selector(tick:)];</span><br></pre></td></tr></table></figure></p>\n<p>效果如下：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/332029-6b2957fc2ff9cc8b.gif?imageMogr2/auto-orient/strip\" alt></p>\n<p><strong>可以看到 页面 dismiss 后，计时器仍然在打印</strong></p>\n<p><strong>—— 解决办法：1、</strong>在页面退出前，或者合适的时候，手动停止 timer，结束循环引用。</p>\n<p>注意：在 dealloc 方法中是肯定不行的！由于循环引用，dealloc 方法不会进。<br><img src=\"http://upload-images.jianshu.io/upload_images/332029-90b68a2f2381e4f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt></p>\n<p><strong>——解决办法：2、</strong>YYFPSLabel 作者提供的 <a href=\"https://github.com/yehot/YYFPSLabel/blob/master/YYFPSLabel/YYFPSLabel/YYWeakProxy.m\" target=\"_blank\" rel=\"noopener\">YYWeakProxy</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface YYWeakProxy : NSProxy</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">// 使用方式：</span><br><span class=\"line\">    _link = [CADisplayLink displayLinkWithTarget:[YYWeakProxy proxyWithTarget:self] selector:@selector(tick:)];</span><br></pre></td></tr></table></figure>\n<p>代码很少，有兴趣可以自己看下源码。<br><strong>Tips：</strong> OC中 NSProxy 是不继承自 NSObject 的。</p>\n<p>###3、探索环节：iOS中子线程检测主线程</p>\n<blockquote>\n<p>在和小伙伴分享这个小工具的时候，潘神抛出了这样一个<strong>问题</strong>：<br>这里组件是在主线程绘制的label，如果主线程阻塞了还能用吗？</p>\n</blockquote>\n<p>结果是不能。</p>\n<p>####以下是探索阶段：</p>\n<p>1、模拟主线程阻塞，将 link 放在子线程，发现 timer 不能启动</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    // 模拟 主线程阻塞 （不应该模拟主线程卡死，模拟卡顿即可）</span><br><span class=\"line\">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0f * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;  </span><br><span class=\"line\">        NSLog(@&quot;即将阻塞&quot;);</span><br><span class=\"line\">        dispatch_sync(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">            NSLog(@&quot;同步阻塞主线程&quot;);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        NSLog(@&quot;不会执行&quot;);</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n<p>2、使用CFRunLoopAddObserver检测主线程是否卡顿：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//将观察者添加到主线程runloop的common模式下的观察中</span><br><span class=\"line\">CFRunLoopAddObserver(CFRunLoopGetMain(), runLoopObserver, kCFRunLoopCommonModes);</span><br></pre></td></tr></table></figure>\n<p>这里是能检测到主线程是否卡顿了，但是 timer 在子线程中还是跑不起来。</p>\n<p>参考 <a href=\"https://www.google.com.hk/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;ved=0ahUKEwjx0Zjw4_fLAhWVj44KHdkUAvwQFggbMAA&amp;url=%68%74%74%70%3a%2f%2f%77%77%77%2e%73%74%61%72%6d%69%6e%67%2e%63%6f%6d%2f&amp;usg=AFQjCNF2xjShwXV0aXfKo1yXQHN95DRCAA&amp;sig2=C_ywHG5vt8byOOqA6x-bOw\" target=\"_blank\" rel=\"noopener\">Starming星光社</a> 的 <a href=\"http://www.starming.com/index.php?v=index&amp;view=91\" target=\"_blank\" rel=\"noopener\">检测iOS的APP性能的一些方法</a></p>\n<p>3、在子线程手动创建一个 runloop，提供给 timer。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class=\"line\">        _link = [CADisplayLink displayLinkWithTarget:self selector:@selector(tick:)];</span><br><span class=\"line\">        // NOTE: 子线程的runloop默认不创建； 在子线程获取 currentRunLoop 对象的时候，就会自动创建RunLoop</span><br><span class=\"line\">        // 这里不加到 main loop，必须创建一个 runloop</span><br><span class=\"line\">        NSRunLoop *runloop = [NSRunLoop currentRunLoop];</span><br><span class=\"line\">        [_link addToRunLoop:runloop forMode:NSRunLoopCommonModes];</span><br><span class=\"line\">        // 必须 timer addToRunLoop 后，再run</span><br><span class=\"line\">        [runloop run];</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure></p>\n<p>这样，就可以在子线程中使用 timer 了，但是此时只能 log，无法获通知主线程更新UI： (这里先不在主线程更新UI了)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 尝试1：主线程阻塞， 这里就不能获取到主线程了</span><br><span class=\"line\">//    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">//        阻塞时，想通过 在主线程更新UI 来查看是不可行了</span><br><span class=\"line\">//        label_.text = text;</span><br><span class=\"line\">//    &#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 尝试2：不在主线程操作 UI ，界面会发生变化</span><br><span class=\"line\">    label_.text = text;</span><br></pre></td></tr></table></figure></p>\n<p>参考: <a href=\"http://www.jianshu.com/p/37ab0397fec7\" target=\"_blank\" rel=\"noopener\">【iOS程序启动与运转】- RunLoop个人小结</a></p>\n<p>以上是学习 YYFPSLabel 时的收获，和对于在子线程中检测主线程的探索。详情可以戳代码：<br><strong><a href=\"https://github.com/yehot/YYFPSLabel\" target=\"_blank\" rel=\"noopener\">YYFPSLabel</a></strong></p>\n"},{"title":"Target-Action 实现组件解耦 —— CTMediator使用教程","date":"2016-09-15T06:20:28.000Z","_content":"\n> 在 [iOS组件化方案调研](http://www.jianshu.com/p/34f23b694412) 这篇中，对组件化的应用场景和实现方式做了简单的调研。最终在项目中采用的是 casa 的 `CTMediator` 这套方案。以下是CTMediator 的一个简单的使用教程。\n\n## 一、普通页面跳转用法\n\n假设我们有个页面叫 `OneViewController`，当前页面为 `HomeViewController`，普通情况下页面的间的跳转方式如下：\n\n```\n#import \"HomeViewController.h\"\n#import \"OneViewController.h\"\n\n@implementation HomeViewController\n\n- (void)aButtonClick:(UIButton *)sender {\n    OneViewController *viewController = [[OneViewController alloc] init];\n    viewController.name = @\"普通用法\";  //传递必要参数\n    [self.navigationController pushViewController:viewController animated:YES];\n}\n\n@end\n```\n\n这样做看上去没什么问题，实际也没什么问题。\n但是，考虑以下情况：\n\n1. 如果 `HomeViewController` 里有 N 个这样的 button 事件，每个点击后的跳转都是不同的页面，那么则 `HomeViewController` 里，需要导入 N 个这样的 `OneViewController.h`;\n2. 如果 `HomeViewController` 是一个可以移植到其它项目的业务模块，在拖出首页 `HomeVC` 相关的业务代码时，难道还要把 'HomeViewController.m' 导入的 N 个其它 `XxxViewController.h` 都一块拖到新项目中么？\n\n这点就是因为代码的耦合导致了首页 `HomeVC` 没法方便的移植。\n\n说这样没有问题，是因为普通情况下，我们并没有移植 `HomeVC` 到其它项目的需求。\n\n至于什么时候会有这样的问题，以及，这样的问题如果解决，在 [iOS组件化方案调研](http://www.jianshu.com/p/34f23b694412) 这篇中，已经做过简单的讨论，这篇主要是选取了我个人较偏向的 `Target-Action` 这套方案，简单讲一下实现方式。\n\n## 二、Target-Action 实现页面跳转\n\n采用的是 `CTMediator` 这套方案\n[Demo地址](https://github.com/yehot/YT_TargetAction)\n\n还是假设我们有个页面叫 `NewsViewController`, 当前页面为`HomeViewController`\n那么，我们按照`CTMediator`设计的架构来写一遍这个流程\n\n### 1.创建Target-Action\n\n创建一个 `Target_News` 类，在这个文件里，我们主要生成 NewsViewController 实例并为其进行一些必要的赋值。例如:\n\n```\n// Target_News.h\n\n#import <Foundation/Foundation.h>\n#import <UIKit/UIKit.h>\n\n@interface Target_News : NSObject\n\n- (UIViewController *)Action_NativeToNewsViewController:(NSDictionary *)params;\n\n@end\n\n```\n\n这个类需要直接 `#import \"NewsViewController.h\"`\n\n```\n// Target_News.m\n\n#import \"Target_News.h\"\n#import \"NewsViewController.h\"\n\n@implementation Target_News\n\n- (UIViewController *)Action_NativeToNewsViewController:(NSDictionary *)params {\n    NewsViewController *newsVC = [[NewsViewController alloc] init];\n\n    if ([params valueForKey:@\"newsID\"]) {\n        newsVC.newsID = params[@\"newsID\"];\n    }\n\n    return newsVC;\n}\n\n@end\n```\n\n\n### 2.创建 CTMediator 的Category.\n\nCTMediator+NewsActions.这个Category利用Runtime调用我们刚刚生成的Target_News。\n\n由于利用了Runtime，导致我们完全不用#import刚刚生成的Target_News即可执行里面的方法，所以这一步，两个类是完全解耦的。也即是说，我们在完全解耦的情况下获取到了我们需要的NewsViewController。例如：\n\n```\n// CTMediator+NewsActions.h\n\n#import \"CTMediator.h\"\n#import <UIKit/UIKit.h>\n\n@interface CTMediator (NewsActions)\n\n- (UIViewController *)yt_mediator_newsViewControllerWithParams:(NSDictionary *)dict;\n\n@end\n```\n\n\n```\n// CTMediator+NewsActions.m\n\n#import \"CTMediator+NewsActions.h\"\n\nNSString * const kCTMediatorTarget_News = @\"News\";\nNSString * const kCTMediatorActionNativTo_NewsViewController = @\"NativeToNewsViewController\";\n\n@implementation CTMediator (NewsActions)\n\n- (UIViewController *)yt_mediator_newsViewControllerWithParams:(NSDictionary *)dict {\n\n    UIViewController *viewController = [self performTarget:kCTMediatorTarget_News\n                                                    action:kCTMediatorActionNativTo_NewsViewController\n                                                    params:dict];\n    if ([viewController isKindOfClass:[UIViewController class]]) {\n        return viewController;\n    } else {\n        NSLog(@\"%@ 未能实例化页面\", NSStringFromSelector(_cmd));\n        return [[UIViewController alloc] init];\n    }\n}\n\n@end\n```\n\n### 3.最终使用\n\n由于在Target中，传递值得方式采用了去Model化得方式，导致我们在整个过程中也没有#import任何Model。所以，我们的每个类都与Model解耦。\n\n```\n// HomeViewController.m\n\n#import \"HomeViewController.h\"\n#import \"CTMediator+NewsActions.h\"\n\n@implementation HomeViewController\n\n- (void)bButtonClick:(UIButton *)sender {\n    UIViewController *viewController = [[CTMediator sharedInstance] yt_mediator_newsViewControllerWithParams:@{@\"newsID\":@\"123456\"}];\n    [self.navigationController pushViewController:viewController animated:YES];\n}\n@end\n```\n\n### 4.不足\n\n这里其实唯一的问题就是，Target_Action里不得不填入一些 Hard Code，就是对创建的VC的赋值语句。不过这也是为了达到最大限度的解耦和灵活度而做的权衡。\n\n```\n//  1. kCTMediatorTarget_News字符串 是 Target_xxx.h 中的 xxx 部分\nNSString * const kCTMediatorTarget_News = @\"News\";\n\n//  2. kCTMediatorActionNativTo_NewsViewController 是 Target_xxx.h 中 定义的 Action_xxxx 函数名的 xxx 部分\nNSString * const kCTMediatorActionNativTo_NewsViewController = @\"NativeToNewsViewController\";\n```\n\n> 注：这篇写的较早。作者前段时间也亲自写了篇教程：[在现有工程中实施基于CTMediator的组件化方案](http://casatwy.com/modulization_in_action.html)  比这篇详尽，各位还是移步原 po 的教程吧……\n","source":"_posts/20160915-CTMediator-tutorials.md","raw":"---\ntitle: Target-Action 实现组件解耦 —— CTMediator使用教程\ndate: 2016-09-15 14:20:28\ntags: CocoaPods\ncategories: iOS组件化\n---\n\n> 在 [iOS组件化方案调研](http://www.jianshu.com/p/34f23b694412) 这篇中，对组件化的应用场景和实现方式做了简单的调研。最终在项目中采用的是 casa 的 `CTMediator` 这套方案。以下是CTMediator 的一个简单的使用教程。\n\n## 一、普通页面跳转用法\n\n假设我们有个页面叫 `OneViewController`，当前页面为 `HomeViewController`，普通情况下页面的间的跳转方式如下：\n\n```\n#import \"HomeViewController.h\"\n#import \"OneViewController.h\"\n\n@implementation HomeViewController\n\n- (void)aButtonClick:(UIButton *)sender {\n    OneViewController *viewController = [[OneViewController alloc] init];\n    viewController.name = @\"普通用法\";  //传递必要参数\n    [self.navigationController pushViewController:viewController animated:YES];\n}\n\n@end\n```\n\n这样做看上去没什么问题，实际也没什么问题。\n但是，考虑以下情况：\n\n1. 如果 `HomeViewController` 里有 N 个这样的 button 事件，每个点击后的跳转都是不同的页面，那么则 `HomeViewController` 里，需要导入 N 个这样的 `OneViewController.h`;\n2. 如果 `HomeViewController` 是一个可以移植到其它项目的业务模块，在拖出首页 `HomeVC` 相关的业务代码时，难道还要把 'HomeViewController.m' 导入的 N 个其它 `XxxViewController.h` 都一块拖到新项目中么？\n\n这点就是因为代码的耦合导致了首页 `HomeVC` 没法方便的移植。\n\n说这样没有问题，是因为普通情况下，我们并没有移植 `HomeVC` 到其它项目的需求。\n\n至于什么时候会有这样的问题，以及，这样的问题如果解决，在 [iOS组件化方案调研](http://www.jianshu.com/p/34f23b694412) 这篇中，已经做过简单的讨论，这篇主要是选取了我个人较偏向的 `Target-Action` 这套方案，简单讲一下实现方式。\n\n## 二、Target-Action 实现页面跳转\n\n采用的是 `CTMediator` 这套方案\n[Demo地址](https://github.com/yehot/YT_TargetAction)\n\n还是假设我们有个页面叫 `NewsViewController`, 当前页面为`HomeViewController`\n那么，我们按照`CTMediator`设计的架构来写一遍这个流程\n\n### 1.创建Target-Action\n\n创建一个 `Target_News` 类，在这个文件里，我们主要生成 NewsViewController 实例并为其进行一些必要的赋值。例如:\n\n```\n// Target_News.h\n\n#import <Foundation/Foundation.h>\n#import <UIKit/UIKit.h>\n\n@interface Target_News : NSObject\n\n- (UIViewController *)Action_NativeToNewsViewController:(NSDictionary *)params;\n\n@end\n\n```\n\n这个类需要直接 `#import \"NewsViewController.h\"`\n\n```\n// Target_News.m\n\n#import \"Target_News.h\"\n#import \"NewsViewController.h\"\n\n@implementation Target_News\n\n- (UIViewController *)Action_NativeToNewsViewController:(NSDictionary *)params {\n    NewsViewController *newsVC = [[NewsViewController alloc] init];\n\n    if ([params valueForKey:@\"newsID\"]) {\n        newsVC.newsID = params[@\"newsID\"];\n    }\n\n    return newsVC;\n}\n\n@end\n```\n\n\n### 2.创建 CTMediator 的Category.\n\nCTMediator+NewsActions.这个Category利用Runtime调用我们刚刚生成的Target_News。\n\n由于利用了Runtime，导致我们完全不用#import刚刚生成的Target_News即可执行里面的方法，所以这一步，两个类是完全解耦的。也即是说，我们在完全解耦的情况下获取到了我们需要的NewsViewController。例如：\n\n```\n// CTMediator+NewsActions.h\n\n#import \"CTMediator.h\"\n#import <UIKit/UIKit.h>\n\n@interface CTMediator (NewsActions)\n\n- (UIViewController *)yt_mediator_newsViewControllerWithParams:(NSDictionary *)dict;\n\n@end\n```\n\n\n```\n// CTMediator+NewsActions.m\n\n#import \"CTMediator+NewsActions.h\"\n\nNSString * const kCTMediatorTarget_News = @\"News\";\nNSString * const kCTMediatorActionNativTo_NewsViewController = @\"NativeToNewsViewController\";\n\n@implementation CTMediator (NewsActions)\n\n- (UIViewController *)yt_mediator_newsViewControllerWithParams:(NSDictionary *)dict {\n\n    UIViewController *viewController = [self performTarget:kCTMediatorTarget_News\n                                                    action:kCTMediatorActionNativTo_NewsViewController\n                                                    params:dict];\n    if ([viewController isKindOfClass:[UIViewController class]]) {\n        return viewController;\n    } else {\n        NSLog(@\"%@ 未能实例化页面\", NSStringFromSelector(_cmd));\n        return [[UIViewController alloc] init];\n    }\n}\n\n@end\n```\n\n### 3.最终使用\n\n由于在Target中，传递值得方式采用了去Model化得方式，导致我们在整个过程中也没有#import任何Model。所以，我们的每个类都与Model解耦。\n\n```\n// HomeViewController.m\n\n#import \"HomeViewController.h\"\n#import \"CTMediator+NewsActions.h\"\n\n@implementation HomeViewController\n\n- (void)bButtonClick:(UIButton *)sender {\n    UIViewController *viewController = [[CTMediator sharedInstance] yt_mediator_newsViewControllerWithParams:@{@\"newsID\":@\"123456\"}];\n    [self.navigationController pushViewController:viewController animated:YES];\n}\n@end\n```\n\n### 4.不足\n\n这里其实唯一的问题就是，Target_Action里不得不填入一些 Hard Code，就是对创建的VC的赋值语句。不过这也是为了达到最大限度的解耦和灵活度而做的权衡。\n\n```\n//  1. kCTMediatorTarget_News字符串 是 Target_xxx.h 中的 xxx 部分\nNSString * const kCTMediatorTarget_News = @\"News\";\n\n//  2. kCTMediatorActionNativTo_NewsViewController 是 Target_xxx.h 中 定义的 Action_xxxx 函数名的 xxx 部分\nNSString * const kCTMediatorActionNativTo_NewsViewController = @\"NativeToNewsViewController\";\n```\n\n> 注：这篇写的较早。作者前段时间也亲自写了篇教程：[在现有工程中实施基于CTMediator的组件化方案](http://casatwy.com/modulization_in_action.html)  比这篇详尽，各位还是移步原 po 的教程吧……\n","slug":"20160915-CTMediator-tutorials","published":1,"updated":"2019-04-18T16:37:45.208Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjumvmx9q0008raxef9fnimws","content":"<blockquote>\n<p>在 <a href=\"http://www.jianshu.com/p/34f23b694412\" target=\"_blank\" rel=\"noopener\">iOS组件化方案调研</a> 这篇中，对组件化的应用场景和实现方式做了简单的调研。最终在项目中采用的是 casa 的 <code>CTMediator</code> 这套方案。以下是CTMediator 的一个简单的使用教程。</p>\n</blockquote>\n<h2 id=\"一、普通页面跳转用法\"><a href=\"#一、普通页面跳转用法\" class=\"headerlink\" title=\"一、普通页面跳转用法\"></a>一、普通页面跳转用法</h2><p>假设我们有个页面叫 <code>OneViewController</code>，当前页面为 <code>HomeViewController</code>，普通情况下页面的间的跳转方式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;HomeViewController.h&quot;</span><br><span class=\"line\">#import &quot;OneViewController.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation HomeViewController</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)aButtonClick:(UIButton *)sender &#123;</span><br><span class=\"line\">    OneViewController *viewController = [[OneViewController alloc] init];</span><br><span class=\"line\">    viewController.name = @&quot;普通用法&quot;;  //传递必要参数</span><br><span class=\"line\">    [self.navigationController pushViewController:viewController animated:YES];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<p>这样做看上去没什么问题，实际也没什么问题。<br>但是，考虑以下情况：</p>\n<ol>\n<li>如果 <code>HomeViewController</code> 里有 N 个这样的 button 事件，每个点击后的跳转都是不同的页面，那么则 <code>HomeViewController</code> 里，需要导入 N 个这样的 <code>OneViewController.h</code>;</li>\n<li>如果 <code>HomeViewController</code> 是一个可以移植到其它项目的业务模块，在拖出首页 <code>HomeVC</code> 相关的业务代码时，难道还要把 ‘HomeViewController.m’ 导入的 N 个其它 <code>XxxViewController.h</code> 都一块拖到新项目中么？</li>\n</ol>\n<p>这点就是因为代码的耦合导致了首页 <code>HomeVC</code> 没法方便的移植。</p>\n<p>说这样没有问题，是因为普通情况下，我们并没有移植 <code>HomeVC</code> 到其它项目的需求。</p>\n<p>至于什么时候会有这样的问题，以及，这样的问题如果解决，在 <a href=\"http://www.jianshu.com/p/34f23b694412\" target=\"_blank\" rel=\"noopener\">iOS组件化方案调研</a> 这篇中，已经做过简单的讨论，这篇主要是选取了我个人较偏向的 <code>Target-Action</code> 这套方案，简单讲一下实现方式。</p>\n<h2 id=\"二、Target-Action-实现页面跳转\"><a href=\"#二、Target-Action-实现页面跳转\" class=\"headerlink\" title=\"二、Target-Action 实现页面跳转\"></a>二、Target-Action 实现页面跳转</h2><p>采用的是 <code>CTMediator</code> 这套方案<br><a href=\"https://github.com/yehot/YT_TargetAction\" target=\"_blank\" rel=\"noopener\">Demo地址</a></p>\n<p>还是假设我们有个页面叫 <code>NewsViewController</code>, 当前页面为<code>HomeViewController</code><br>那么，我们按照<code>CTMediator</code>设计的架构来写一遍这个流程</p>\n<h3 id=\"1-创建Target-Action\"><a href=\"#1-创建Target-Action\" class=\"headerlink\" title=\"1.创建Target-Action\"></a>1.创建Target-Action</h3><p>创建一个 <code>Target_News</code> 类，在这个文件里，我们主要生成 NewsViewController 实例并为其进行一些必要的赋值。例如:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Target_News.h</span><br><span class=\"line\"></span><br><span class=\"line\">#import &lt;Foundation/Foundation.h&gt;</span><br><span class=\"line\">#import &lt;UIKit/UIKit.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface Target_News : NSObject</span><br><span class=\"line\"></span><br><span class=\"line\">- (UIViewController *)Action_NativeToNewsViewController:(NSDictionary *)params;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<p>这个类需要直接 <code>#import &quot;NewsViewController.h&quot;</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Target_News.m</span><br><span class=\"line\"></span><br><span class=\"line\">#import &quot;Target_News.h&quot;</span><br><span class=\"line\">#import &quot;NewsViewController.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation Target_News</span><br><span class=\"line\"></span><br><span class=\"line\">- (UIViewController *)Action_NativeToNewsViewController:(NSDictionary *)params &#123;</span><br><span class=\"line\">    NewsViewController *newsVC = [[NewsViewController alloc] init];</span><br><span class=\"line\"></span><br><span class=\"line\">    if ([params valueForKey:@&quot;newsID&quot;]) &#123;</span><br><span class=\"line\">        newsVC.newsID = params[@&quot;newsID&quot;];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return newsVC;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-创建-CTMediator-的Category\"><a href=\"#2-创建-CTMediator-的Category\" class=\"headerlink\" title=\"2.创建 CTMediator 的Category.\"></a>2.创建 CTMediator 的Category.</h3><p>CTMediator+NewsActions.这个Category利用Runtime调用我们刚刚生成的Target_News。</p>\n<p>由于利用了Runtime，导致我们完全不用#import刚刚生成的Target_News即可执行里面的方法，所以这一步，两个类是完全解耦的。也即是说，我们在完全解耦的情况下获取到了我们需要的NewsViewController。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// CTMediator+NewsActions.h</span><br><span class=\"line\"></span><br><span class=\"line\">#import &quot;CTMediator.h&quot;</span><br><span class=\"line\">#import &lt;UIKit/UIKit.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface CTMediator (NewsActions)</span><br><span class=\"line\"></span><br><span class=\"line\">- (UIViewController *)yt_mediator_newsViewControllerWithParams:(NSDictionary *)dict;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// CTMediator+NewsActions.m</span><br><span class=\"line\"></span><br><span class=\"line\">#import &quot;CTMediator+NewsActions.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">NSString * const kCTMediatorTarget_News = @&quot;News&quot;;</span><br><span class=\"line\">NSString * const kCTMediatorActionNativTo_NewsViewController = @&quot;NativeToNewsViewController&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation CTMediator (NewsActions)</span><br><span class=\"line\"></span><br><span class=\"line\">- (UIViewController *)yt_mediator_newsViewControllerWithParams:(NSDictionary *)dict &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    UIViewController *viewController = [self performTarget:kCTMediatorTarget_News</span><br><span class=\"line\">                                                    action:kCTMediatorActionNativTo_NewsViewController</span><br><span class=\"line\">                                                    params:dict];</span><br><span class=\"line\">    if ([viewController isKindOfClass:[UIViewController class]]) &#123;</span><br><span class=\"line\">        return viewController;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        NSLog(@&quot;%@ 未能实例化页面&quot;, NSStringFromSelector(_cmd));</span><br><span class=\"line\">        return [[UIViewController alloc] init];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-最终使用\"><a href=\"#3-最终使用\" class=\"headerlink\" title=\"3.最终使用\"></a>3.最终使用</h3><p>由于在Target中，传递值得方式采用了去Model化得方式，导致我们在整个过程中也没有#import任何Model。所以，我们的每个类都与Model解耦。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// HomeViewController.m</span><br><span class=\"line\"></span><br><span class=\"line\">#import &quot;HomeViewController.h&quot;</span><br><span class=\"line\">#import &quot;CTMediator+NewsActions.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation HomeViewController</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)bButtonClick:(UIButton *)sender &#123;</span><br><span class=\"line\">    UIViewController *viewController = [[CTMediator sharedInstance] yt_mediator_newsViewControllerWithParams:@&#123;@&quot;newsID&quot;:@&quot;123456&quot;&#125;];</span><br><span class=\"line\">    [self.navigationController pushViewController:viewController animated:YES];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-不足\"><a href=\"#4-不足\" class=\"headerlink\" title=\"4.不足\"></a>4.不足</h3><p>这里其实唯一的问题就是，Target_Action里不得不填入一些 Hard Code，就是对创建的VC的赋值语句。不过这也是为了达到最大限度的解耦和灵活度而做的权衡。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//  1. kCTMediatorTarget_News字符串 是 Target_xxx.h 中的 xxx 部分</span><br><span class=\"line\">NSString * const kCTMediatorTarget_News = @&quot;News&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">//  2. kCTMediatorActionNativTo_NewsViewController 是 Target_xxx.h 中 定义的 Action_xxxx 函数名的 xxx 部分</span><br><span class=\"line\">NSString * const kCTMediatorActionNativTo_NewsViewController = @&quot;NativeToNewsViewController&quot;;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注：这篇写的较早。作者前段时间也亲自写了篇教程：<a href=\"http://casatwy.com/modulization_in_action.html\" target=\"_blank\" rel=\"noopener\">在现有工程中实施基于CTMediator的组件化方案</a>  比这篇详尽，各位还是移步原 po 的教程吧……</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>在 <a href=\"http://www.jianshu.com/p/34f23b694412\" target=\"_blank\" rel=\"noopener\">iOS组件化方案调研</a> 这篇中，对组件化的应用场景和实现方式做了简单的调研。最终在项目中采用的是 casa 的 <code>CTMediator</code> 这套方案。以下是CTMediator 的一个简单的使用教程。</p>\n</blockquote>\n<h2 id=\"一、普通页面跳转用法\"><a href=\"#一、普通页面跳转用法\" class=\"headerlink\" title=\"一、普通页面跳转用法\"></a>一、普通页面跳转用法</h2><p>假设我们有个页面叫 <code>OneViewController</code>，当前页面为 <code>HomeViewController</code>，普通情况下页面的间的跳转方式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;HomeViewController.h&quot;</span><br><span class=\"line\">#import &quot;OneViewController.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation HomeViewController</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)aButtonClick:(UIButton *)sender &#123;</span><br><span class=\"line\">    OneViewController *viewController = [[OneViewController alloc] init];</span><br><span class=\"line\">    viewController.name = @&quot;普通用法&quot;;  //传递必要参数</span><br><span class=\"line\">    [self.navigationController pushViewController:viewController animated:YES];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<p>这样做看上去没什么问题，实际也没什么问题。<br>但是，考虑以下情况：</p>\n<ol>\n<li>如果 <code>HomeViewController</code> 里有 N 个这样的 button 事件，每个点击后的跳转都是不同的页面，那么则 <code>HomeViewController</code> 里，需要导入 N 个这样的 <code>OneViewController.h</code>;</li>\n<li>如果 <code>HomeViewController</code> 是一个可以移植到其它项目的业务模块，在拖出首页 <code>HomeVC</code> 相关的业务代码时，难道还要把 ‘HomeViewController.m’ 导入的 N 个其它 <code>XxxViewController.h</code> 都一块拖到新项目中么？</li>\n</ol>\n<p>这点就是因为代码的耦合导致了首页 <code>HomeVC</code> 没法方便的移植。</p>\n<p>说这样没有问题，是因为普通情况下，我们并没有移植 <code>HomeVC</code> 到其它项目的需求。</p>\n<p>至于什么时候会有这样的问题，以及，这样的问题如果解决，在 <a href=\"http://www.jianshu.com/p/34f23b694412\" target=\"_blank\" rel=\"noopener\">iOS组件化方案调研</a> 这篇中，已经做过简单的讨论，这篇主要是选取了我个人较偏向的 <code>Target-Action</code> 这套方案，简单讲一下实现方式。</p>\n<h2 id=\"二、Target-Action-实现页面跳转\"><a href=\"#二、Target-Action-实现页面跳转\" class=\"headerlink\" title=\"二、Target-Action 实现页面跳转\"></a>二、Target-Action 实现页面跳转</h2><p>采用的是 <code>CTMediator</code> 这套方案<br><a href=\"https://github.com/yehot/YT_TargetAction\" target=\"_blank\" rel=\"noopener\">Demo地址</a></p>\n<p>还是假设我们有个页面叫 <code>NewsViewController</code>, 当前页面为<code>HomeViewController</code><br>那么，我们按照<code>CTMediator</code>设计的架构来写一遍这个流程</p>\n<h3 id=\"1-创建Target-Action\"><a href=\"#1-创建Target-Action\" class=\"headerlink\" title=\"1.创建Target-Action\"></a>1.创建Target-Action</h3><p>创建一个 <code>Target_News</code> 类，在这个文件里，我们主要生成 NewsViewController 实例并为其进行一些必要的赋值。例如:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Target_News.h</span><br><span class=\"line\"></span><br><span class=\"line\">#import &lt;Foundation/Foundation.h&gt;</span><br><span class=\"line\">#import &lt;UIKit/UIKit.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface Target_News : NSObject</span><br><span class=\"line\"></span><br><span class=\"line\">- (UIViewController *)Action_NativeToNewsViewController:(NSDictionary *)params;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<p>这个类需要直接 <code>#import &quot;NewsViewController.h&quot;</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Target_News.m</span><br><span class=\"line\"></span><br><span class=\"line\">#import &quot;Target_News.h&quot;</span><br><span class=\"line\">#import &quot;NewsViewController.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation Target_News</span><br><span class=\"line\"></span><br><span class=\"line\">- (UIViewController *)Action_NativeToNewsViewController:(NSDictionary *)params &#123;</span><br><span class=\"line\">    NewsViewController *newsVC = [[NewsViewController alloc] init];</span><br><span class=\"line\"></span><br><span class=\"line\">    if ([params valueForKey:@&quot;newsID&quot;]) &#123;</span><br><span class=\"line\">        newsVC.newsID = params[@&quot;newsID&quot;];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return newsVC;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-创建-CTMediator-的Category\"><a href=\"#2-创建-CTMediator-的Category\" class=\"headerlink\" title=\"2.创建 CTMediator 的Category.\"></a>2.创建 CTMediator 的Category.</h3><p>CTMediator+NewsActions.这个Category利用Runtime调用我们刚刚生成的Target_News。</p>\n<p>由于利用了Runtime，导致我们完全不用#import刚刚生成的Target_News即可执行里面的方法，所以这一步，两个类是完全解耦的。也即是说，我们在完全解耦的情况下获取到了我们需要的NewsViewController。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// CTMediator+NewsActions.h</span><br><span class=\"line\"></span><br><span class=\"line\">#import &quot;CTMediator.h&quot;</span><br><span class=\"line\">#import &lt;UIKit/UIKit.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface CTMediator (NewsActions)</span><br><span class=\"line\"></span><br><span class=\"line\">- (UIViewController *)yt_mediator_newsViewControllerWithParams:(NSDictionary *)dict;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// CTMediator+NewsActions.m</span><br><span class=\"line\"></span><br><span class=\"line\">#import &quot;CTMediator+NewsActions.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">NSString * const kCTMediatorTarget_News = @&quot;News&quot;;</span><br><span class=\"line\">NSString * const kCTMediatorActionNativTo_NewsViewController = @&quot;NativeToNewsViewController&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation CTMediator (NewsActions)</span><br><span class=\"line\"></span><br><span class=\"line\">- (UIViewController *)yt_mediator_newsViewControllerWithParams:(NSDictionary *)dict &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    UIViewController *viewController = [self performTarget:kCTMediatorTarget_News</span><br><span class=\"line\">                                                    action:kCTMediatorActionNativTo_NewsViewController</span><br><span class=\"line\">                                                    params:dict];</span><br><span class=\"line\">    if ([viewController isKindOfClass:[UIViewController class]]) &#123;</span><br><span class=\"line\">        return viewController;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        NSLog(@&quot;%@ 未能实例化页面&quot;, NSStringFromSelector(_cmd));</span><br><span class=\"line\">        return [[UIViewController alloc] init];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-最终使用\"><a href=\"#3-最终使用\" class=\"headerlink\" title=\"3.最终使用\"></a>3.最终使用</h3><p>由于在Target中，传递值得方式采用了去Model化得方式，导致我们在整个过程中也没有#import任何Model。所以，我们的每个类都与Model解耦。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// HomeViewController.m</span><br><span class=\"line\"></span><br><span class=\"line\">#import &quot;HomeViewController.h&quot;</span><br><span class=\"line\">#import &quot;CTMediator+NewsActions.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation HomeViewController</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)bButtonClick:(UIButton *)sender &#123;</span><br><span class=\"line\">    UIViewController *viewController = [[CTMediator sharedInstance] yt_mediator_newsViewControllerWithParams:@&#123;@&quot;newsID&quot;:@&quot;123456&quot;&#125;];</span><br><span class=\"line\">    [self.navigationController pushViewController:viewController animated:YES];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-不足\"><a href=\"#4-不足\" class=\"headerlink\" title=\"4.不足\"></a>4.不足</h3><p>这里其实唯一的问题就是，Target_Action里不得不填入一些 Hard Code，就是对创建的VC的赋值语句。不过这也是为了达到最大限度的解耦和灵活度而做的权衡。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//  1. kCTMediatorTarget_News字符串 是 Target_xxx.h 中的 xxx 部分</span><br><span class=\"line\">NSString * const kCTMediatorTarget_News = @&quot;News&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">//  2. kCTMediatorActionNativTo_NewsViewController 是 Target_xxx.h 中 定义的 Action_xxxx 函数名的 xxx 部分</span><br><span class=\"line\">NSString * const kCTMediatorActionNativTo_NewsViewController = @&quot;NativeToNewsViewController&quot;;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注：这篇写的较早。作者前段时间也亲自写了篇教程：<a href=\"http://casatwy.com/modulization_in_action.html\" target=\"_blank\" rel=\"noopener\">在现有工程中实施基于CTMediator的组件化方案</a>  比这篇详尽，各位还是移步原 po 的教程吧……</p>\n</blockquote>\n"},{"title":"Hello World","date":"2015-02-15T14:33:01.000Z","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ndate: 2015-02-15 22:33:01\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"updated":"2019-04-18T11:06:48.751Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjumvmx9t000craxedt8reai3","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n"},{"title":"Python新浪博客爬虫：sina-blog-spider","date":"2017-03-27T12:38:08.000Z","_content":"\n> 大学的时候用新浪写了4年的流水账 blog，某天突然翻到，感慨还是留了不少记忆在里边的，就想着要不迁移或者备份下。搜了一圈发现了 [bfishadow/SBB](https://github.com/bfishadow/SBB) 这个 Python 写的备份工具，试用了下还不错。刚好借着这个机会学习一下 Python 和爬虫。\n\n在学习代码的过程中，自己也敲了一遍，发现了一些问题：不支持 Python3.x，代码可读性太差。代码敲完了发现，作者原来不是程序员啊我摔！被坑了（代码实在太烂了，差点摧毁我对 Python 的认知）。\n\n所以特意花了一下午时间对代码进行了一个重写：\n\n### 新特性：\n\n- 适配 Python3.x；\n- 进行了封装、重构，提高代码可读性；\n- 添加了踩坑注释；\n- 吐槽归吐槽，原 po 思路还是非常赞的，鸣谢 @bfishadow；\n\n### 功能简介\n\n- 用于下载并归档指定新浪博客作者全部文章的 Python 脚本；\n- 抓取后整理生成本地 html 文件，以及一个 indxe 入口；\n- 支持到 Python3.x\n- 源码戳 [sina-blog-spider](https://github.com/yehot/sina-blog-spider)\n\n### Usage:\n\n```python\n# 排序开关是可选的，默认为按发表时间顺序排列（即 asc）\n$ sina_blog_crawler.py http://blog.sina.com.cn/gongmin desc\n$ sina_blog_crawler.py http://blog.sina.com.cn/u/1239657051\n```\n\n### TODO:\n* [ ] 添加可选参数：指定抓取页数支持\n* [ ] 网络库从 urllib 替换为 requests\n* [ ] 字符串匹配改用正则\n* [ ] 不够 Pythonic，优化编码规范\n\n### DEMO:\n\n> 万万没想到韩寒 17 年还有两篇博客，试爬了一下韩寒的 10 篇 blog，效果如图：\n\n![sinaa-demo](http://ob7o39x9f.bkt.clouddn.com/2017-03-27-Untitled1.gif)\n\n\n\n","source":"_posts/20170326-sina-blog-spider.md","raw":"---\ntitle: Python新浪博客爬虫：sina-blog-spider\ndate: 2017-03-27 20:38:08\ntags: spider\ncategories: Python\n---\n\n> 大学的时候用新浪写了4年的流水账 blog，某天突然翻到，感慨还是留了不少记忆在里边的，就想着要不迁移或者备份下。搜了一圈发现了 [bfishadow/SBB](https://github.com/bfishadow/SBB) 这个 Python 写的备份工具，试用了下还不错。刚好借着这个机会学习一下 Python 和爬虫。\n\n在学习代码的过程中，自己也敲了一遍，发现了一些问题：不支持 Python3.x，代码可读性太差。代码敲完了发现，作者原来不是程序员啊我摔！被坑了（代码实在太烂了，差点摧毁我对 Python 的认知）。\n\n所以特意花了一下午时间对代码进行了一个重写：\n\n### 新特性：\n\n- 适配 Python3.x；\n- 进行了封装、重构，提高代码可读性；\n- 添加了踩坑注释；\n- 吐槽归吐槽，原 po 思路还是非常赞的，鸣谢 @bfishadow；\n\n### 功能简介\n\n- 用于下载并归档指定新浪博客作者全部文章的 Python 脚本；\n- 抓取后整理生成本地 html 文件，以及一个 indxe 入口；\n- 支持到 Python3.x\n- 源码戳 [sina-blog-spider](https://github.com/yehot/sina-blog-spider)\n\n### Usage:\n\n```python\n# 排序开关是可选的，默认为按发表时间顺序排列（即 asc）\n$ sina_blog_crawler.py http://blog.sina.com.cn/gongmin desc\n$ sina_blog_crawler.py http://blog.sina.com.cn/u/1239657051\n```\n\n### TODO:\n* [ ] 添加可选参数：指定抓取页数支持\n* [ ] 网络库从 urllib 替换为 requests\n* [ ] 字符串匹配改用正则\n* [ ] 不够 Pythonic，优化编码规范\n\n### DEMO:\n\n> 万万没想到韩寒 17 年还有两篇博客，试爬了一下韩寒的 10 篇 blog，效果如图：\n\n![sinaa-demo](http://ob7o39x9f.bkt.clouddn.com/2017-03-27-Untitled1.gif)\n\n\n\n","slug":"20170326-sina-blog-spider","published":1,"updated":"2019-04-18T11:06:48.750Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjumvmx9u000draxe8mvgloel","content":"<blockquote>\n<p>大学的时候用新浪写了4年的流水账 blog，某天突然翻到，感慨还是留了不少记忆在里边的，就想着要不迁移或者备份下。搜了一圈发现了 <a href=\"https://github.com/bfishadow/SBB\" target=\"_blank\" rel=\"noopener\">bfishadow/SBB</a> 这个 Python 写的备份工具，试用了下还不错。刚好借着这个机会学习一下 Python 和爬虫。</p>\n</blockquote>\n<p>在学习代码的过程中，自己也敲了一遍，发现了一些问题：不支持 Python3.x，代码可读性太差。代码敲完了发现，作者原来不是程序员啊我摔！被坑了（代码实在太烂了，差点摧毁我对 Python 的认知）。</p>\n<p>所以特意花了一下午时间对代码进行了一个重写：</p>\n<h3 id=\"新特性：\"><a href=\"#新特性：\" class=\"headerlink\" title=\"新特性：\"></a>新特性：</h3><ul>\n<li>适配 Python3.x；</li>\n<li>进行了封装、重构，提高代码可读性；</li>\n<li>添加了踩坑注释；</li>\n<li>吐槽归吐槽，原 po 思路还是非常赞的，鸣谢 @bfishadow；</li>\n</ul>\n<h3 id=\"功能简介\"><a href=\"#功能简介\" class=\"headerlink\" title=\"功能简介\"></a>功能简介</h3><ul>\n<li>用于下载并归档指定新浪博客作者全部文章的 Python 脚本；</li>\n<li>抓取后整理生成本地 html 文件，以及一个 indxe 入口；</li>\n<li>支持到 Python3.x</li>\n<li>源码戳 <a href=\"https://github.com/yehot/sina-blog-spider\" target=\"_blank\" rel=\"noopener\">sina-blog-spider</a></li>\n</ul>\n<h3 id=\"Usage\"><a href=\"#Usage\" class=\"headerlink\" title=\"Usage:\"></a>Usage:</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 排序开关是可选的，默认为按发表时间顺序排列（即 asc）</span></span><br><span class=\"line\">$ sina_blog_crawler.py http://blog.sina.com.cn/gongmin desc</span><br><span class=\"line\">$ sina_blog_crawler.py http://blog.sina.com.cn/u/<span class=\"number\">1239657051</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"TODO\"><a href=\"#TODO\" class=\"headerlink\" title=\"TODO:\"></a>TODO:</h3><ul>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 添加可选参数：指定抓取页数支持</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 网络库从 urllib 替换为 requests</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 字符串匹配改用正则</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 不够 Pythonic，优化编码规范</li>\n</ul>\n<h3 id=\"DEMO\"><a href=\"#DEMO\" class=\"headerlink\" title=\"DEMO:\"></a>DEMO:</h3><blockquote>\n<p>万万没想到韩寒 17 年还有两篇博客，试爬了一下韩寒的 10 篇 blog，效果如图：</p>\n</blockquote>\n<p><img src=\"http://ob7o39x9f.bkt.clouddn.com/2017-03-27-Untitled1.gif\" alt=\"sinaa-demo\"></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>大学的时候用新浪写了4年的流水账 blog，某天突然翻到，感慨还是留了不少记忆在里边的，就想着要不迁移或者备份下。搜了一圈发现了 <a href=\"https://github.com/bfishadow/SBB\" target=\"_blank\" rel=\"noopener\">bfishadow/SBB</a> 这个 Python 写的备份工具，试用了下还不错。刚好借着这个机会学习一下 Python 和爬虫。</p>\n</blockquote>\n<p>在学习代码的过程中，自己也敲了一遍，发现了一些问题：不支持 Python3.x，代码可读性太差。代码敲完了发现，作者原来不是程序员啊我摔！被坑了（代码实在太烂了，差点摧毁我对 Python 的认知）。</p>\n<p>所以特意花了一下午时间对代码进行了一个重写：</p>\n<h3 id=\"新特性：\"><a href=\"#新特性：\" class=\"headerlink\" title=\"新特性：\"></a>新特性：</h3><ul>\n<li>适配 Python3.x；</li>\n<li>进行了封装、重构，提高代码可读性；</li>\n<li>添加了踩坑注释；</li>\n<li>吐槽归吐槽，原 po 思路还是非常赞的，鸣谢 @bfishadow；</li>\n</ul>\n<h3 id=\"功能简介\"><a href=\"#功能简介\" class=\"headerlink\" title=\"功能简介\"></a>功能简介</h3><ul>\n<li>用于下载并归档指定新浪博客作者全部文章的 Python 脚本；</li>\n<li>抓取后整理生成本地 html 文件，以及一个 indxe 入口；</li>\n<li>支持到 Python3.x</li>\n<li>源码戳 <a href=\"https://github.com/yehot/sina-blog-spider\" target=\"_blank\" rel=\"noopener\">sina-blog-spider</a></li>\n</ul>\n<h3 id=\"Usage\"><a href=\"#Usage\" class=\"headerlink\" title=\"Usage:\"></a>Usage:</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 排序开关是可选的，默认为按发表时间顺序排列（即 asc）</span></span><br><span class=\"line\">$ sina_blog_crawler.py http://blog.sina.com.cn/gongmin desc</span><br><span class=\"line\">$ sina_blog_crawler.py http://blog.sina.com.cn/u/<span class=\"number\">1239657051</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"TODO\"><a href=\"#TODO\" class=\"headerlink\" title=\"TODO:\"></a>TODO:</h3><ul>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 添加可选参数：指定抓取页数支持</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 网络库从 urllib 替换为 requests</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 字符串匹配改用正则</li>\n<li style=\"list-style: none\"><input type=\"checkbox\"> 不够 Pythonic，优化编码规范</li>\n</ul>\n<h3 id=\"DEMO\"><a href=\"#DEMO\" class=\"headerlink\" title=\"DEMO:\"></a>DEMO:</h3><blockquote>\n<p>万万没想到韩寒 17 年还有两篇博客，试爬了一下韩寒的 10 篇 blog，效果如图：</p>\n</blockquote>\n<p><img src=\"http://ob7o39x9f.bkt.clouddn.com/2017-03-27-Untitled1.gif\" alt=\"sinaa-demo\"></p>\n"},{"title":"iOS工程目录结构的思考","date":"2015-11-29T06:18:43.000Z","_content":"\n#一、前言\n  在 [@汉斯哈哈哈](http://www.jianshu.com/users/368a8cd349af/latest_articles) 的 [iOS 项目的目录结构能看出你的开发经验](http://www.jianshu.com/p/77a948bcbc38) 这篇博客里提到一点：\n> - 面试iOS开发，面试官竟然问他『**怎么分目录结构**』的，而且还具体问到每个子目录的文件名。\n\n> - 清晰的目录结构，可让人一眼知道对应目录的职能，这也能体现开发者的经验和架构能力。\n\n  恰巧，有一次我参加面试，也被问到过类似的问题。\n  在日常工作中我自己对此也深有感触，《代码大全》里有个观点：\n> **代码首先是给人看的**\n\n  我觉得，一个项目的目录结构也是如此。以下是我个人的一些看法。\n\n  \n#二、不合理的目录结构\n  我想应该没人觉得一个项目的 「**工程目录结构**」这个东西不重要。\n  没人讨论这个可能是因为项目不同、团队风格不一样、目录结构没有个通用的标准，不太好下个结论。\n  而且项目**工程目录结构**这个东西，除非开始一个新项目，其它时候大多都是沿用旧项目里已有的目录结构。真正从无到有的完整搭一个新项目，除了软件外包公司，我想机会不是很多。\n\n  我因为非科班出身，刚入行时不是很懂，为了先找到一份工作，同时想着快速接触更多的项目（靠数量增加经验），所以在软件外包公司待过一段时间，接触了不少新开始的项目，也接手了不少旧项目的版本升级、维护等工作。\n###这是我接触过的一些项目的结构目录：\n![](http://upload-images.jianshu.io/upload_images/332029-9184199c95735d49.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n###为什么不合理：\n  我觉得普遍**存在以下几个问题**：\n**1 、目录结构没有层次性：**\n  有的工程，一级目录展开后就是十几个二级目录的文件夹。\n![](http://upload-images.jianshu.io/upload_images/332029-a4cca08c1fe89985.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n**2 、目录结构层次过深：**\n  文件夹过多、层级过深，会增加点击的成本。\n**3、单个目录下文件数过多**\n  某级目录内文件数量过多，展开后超过一屏。出现这种情况，我觉得就是目录结构设置不合理导致的。\n**4、目录命名不能够「见名知意」：**\n  大量的 **Common**、**Tool**、**Helper**、**Other**这样的文件夹名。\n**5、没有项目目录结构的ReadMe说明；**\n  这个属于代码文档中不容忽视的一点。\n**6、目录存在使用中文命名的情况；**\n**7、结虚拟文件夹与实体文件夹没有一一对应：**\n![](http://upload-images.jianshu.io/upload_images/332029-c642553bee09d282.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n###可能导致的问题：\n\n  **1、**一个糟糕的目录会让人对工程瞬间失去兴趣。\n  **2、**如果打开一个工程，没办法通过阅读目录结构获得对整个项目结构的大致的了解，这样的目录结构就是不够合理的。这样会导致在不熟悉项目的情况下，很难明白各个模块、各个文件夹里的类的作用。\n  **3、**目录结构如果没有统一的规范，类文件的命名也很难有相应的规则来进行约束；\n  **4、**对于新加入项目的人，如果需要新增一些类文件，会不知道究竟该放在哪个目录下合适，只能先\"凭感觉\"随便找个地方一放。这样的工程维护起来，只会越来越乱。\n\n\n#三、我的个人经验\n\n**1、** 简叔在 [iOS 项目的目录结构能看出你的开发经验](http://www.jianshu.com/p/77a948bcbc38) 一文下的评论：\n> ![](http://upload-images.jianshu.io/upload_images/332029-ef0bc5110921e153.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n  看到这条评论不胜赞同。\n  我自己就很喜欢整理，不论是电脑上的盘符目录，还是印象笔记下的笔记本目录，我都习惯于编个号、定期整理。\n\n![](http://upload-images.jianshu.io/upload_images/332029-296141c755a00794.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n  这样一般我要找一个存在自己电脑上的东西，在找之前，头脑里就已经基本想到它会在那个大目录、哪个子目录下。配合搜索功能，很少会找不到文件。\n  同时，存的时候也不会随便找个地方一放，乱七八糟。基本已经形成一套自己熟悉的规则了。\n\n**2、** [高质量iOS开发系列之(一)－iOS项目工程及目录结构](http://mtydev.net/?p=1) 中提高的几个基本原则：\n> - 一个合理的目录结构应该是清晰的，让人一眼就能了解目录职责，并且是容易扩展的。\n> - 不管是第三方库还是自己的库，尽量用CocoPods来管理/区分不同层次的通用组件。\n    - General Level, 最通用的组件，可以在不同项目里复用。\n    - Project Level, 可以在该项目里复用。\n    - Section Level, 可以在某个功能模块里复用。\n> - 对于General Level的组件，以Library的形式分出来，不要放在主工程。\n> - 对于基础库，保证质量，通用性，可扩展性，易用性，可以不断迭代\n\n  此外，该文章中讲到的各模块注意事项，非常切合iOS开发的实际。建议[阅读原文](http://mtydev.net/?p=1)，我就不在这里搬运了。\n\n**3、**  [@汉斯哈哈哈](http://www.jianshu.com/users/368a8cd349af/latest_articles) 提到的两种常用目录结构的分法：\n>1.主目录按照业务分类，内目录按照模块分类\n>2.主目录按照模块分类，内目录按照业务分类\n\n  我个人偏向于第二种：按照业务模块划分。因为：\n> 1> 第一种如果项目较大，经常会出现找个控制器对应的tableviewcell找半天。如果不是自己写的，更难找。\n2> 开发某一具体功能的时候，涉及到的类基本都是该业务模块里面的类，很少会出现跨目录的情况。而第一种情况则需要经常会跨目录。\n3> 从文件耦合度来讲，各业务模块里的文件耦合度相对来说比较高。放在一个目录内，也符合软件设计中的高内聚低耦合思想。\n\n\n**4、一个简单的工程结构目录的Demo**\n- 一级目录如下：（中文备注是为了便于理解，实际项目中不要加）\n![](http://upload-images.jianshu.io/upload_images/332029-908a1195b32b770e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n- 二级目录如下：\n![](http://upload-images.jianshu.io/upload_images/332029-63f11bd45bc0c94f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n**5、公用的类、模块放在哪里：**\n  一般的做法是遇到共用模块单独建一个模块叫common，都放到这里。（这样其实也不是很好，Common也是属于定义模糊的命名）\n**6、多个Target的情况：**\n  可以单独出一个Project文件夹，按Target名分各个子目录，内放各个Target中独有的文件。\n**7、图片资源**最好都用 **Images.xcassets** 去管理。\n  **Images.xcassets** 文件里边也按业务模块分子文件夹，这样可以方便的预览图片。\n\n\n#四、Tips\n  **在定位项目中的文件**时，善用以下快捷键可以节省大量时间：\n\n**1、Xcode左下角的搜索框 （不支持模糊搜索、会展开对应目录）**\n\n![](http://upload-images.jianshu.io/upload_images/332029-c747563290d2b596.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n> 快捷键: Command + option + j\n\n![](http://upload-images.jianshu.io/upload_images/332029-7705e2a055900eb8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n**2、工程全局搜索**（支持模糊搜索、不会展开对应目录）\n> 快捷键: Command + shift + O\n![](http://upload-images.jianshu.io/upload_images/332029-56a1f25146ea0cba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n###注：\n  以上只是我个人的一些经验，总结的不是很完善。同时有很多地方借鉴了以下文章的观点。有什么能改进的地方，欢迎在评论区讨论！\n\n</br>\n\n>###参考：\n>[高质量iOS开发系列之(一)－iOS项目工程及目录结构](http://mtydev.net/?p=1)\n>[iOS项目的目录结构和开发流程](http://limboy.me/ios/2013/09/23/build-ios-application.html)\n>[iOS 项目的目录结构能看出你的开发经验](http://www.jianshu.com/p/77a948bcbc38)\n","source":"_posts/20151129-project-contents.md","raw":"---\ntitle: iOS工程目录结构的思考\ndate: 2015-11-29 14:18:43\ntags: CocoaPods\ncategories: iOS组件化\n---\n\n#一、前言\n  在 [@汉斯哈哈哈](http://www.jianshu.com/users/368a8cd349af/latest_articles) 的 [iOS 项目的目录结构能看出你的开发经验](http://www.jianshu.com/p/77a948bcbc38) 这篇博客里提到一点：\n> - 面试iOS开发，面试官竟然问他『**怎么分目录结构**』的，而且还具体问到每个子目录的文件名。\n\n> - 清晰的目录结构，可让人一眼知道对应目录的职能，这也能体现开发者的经验和架构能力。\n\n  恰巧，有一次我参加面试，也被问到过类似的问题。\n  在日常工作中我自己对此也深有感触，《代码大全》里有个观点：\n> **代码首先是给人看的**\n\n  我觉得，一个项目的目录结构也是如此。以下是我个人的一些看法。\n\n  \n#二、不合理的目录结构\n  我想应该没人觉得一个项目的 「**工程目录结构**」这个东西不重要。\n  没人讨论这个可能是因为项目不同、团队风格不一样、目录结构没有个通用的标准，不太好下个结论。\n  而且项目**工程目录结构**这个东西，除非开始一个新项目，其它时候大多都是沿用旧项目里已有的目录结构。真正从无到有的完整搭一个新项目，除了软件外包公司，我想机会不是很多。\n\n  我因为非科班出身，刚入行时不是很懂，为了先找到一份工作，同时想着快速接触更多的项目（靠数量增加经验），所以在软件外包公司待过一段时间，接触了不少新开始的项目，也接手了不少旧项目的版本升级、维护等工作。\n###这是我接触过的一些项目的结构目录：\n![](http://upload-images.jianshu.io/upload_images/332029-9184199c95735d49.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n###为什么不合理：\n  我觉得普遍**存在以下几个问题**：\n**1 、目录结构没有层次性：**\n  有的工程，一级目录展开后就是十几个二级目录的文件夹。\n![](http://upload-images.jianshu.io/upload_images/332029-a4cca08c1fe89985.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n**2 、目录结构层次过深：**\n  文件夹过多、层级过深，会增加点击的成本。\n**3、单个目录下文件数过多**\n  某级目录内文件数量过多，展开后超过一屏。出现这种情况，我觉得就是目录结构设置不合理导致的。\n**4、目录命名不能够「见名知意」：**\n  大量的 **Common**、**Tool**、**Helper**、**Other**这样的文件夹名。\n**5、没有项目目录结构的ReadMe说明；**\n  这个属于代码文档中不容忽视的一点。\n**6、目录存在使用中文命名的情况；**\n**7、结虚拟文件夹与实体文件夹没有一一对应：**\n![](http://upload-images.jianshu.io/upload_images/332029-c642553bee09d282.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n###可能导致的问题：\n\n  **1、**一个糟糕的目录会让人对工程瞬间失去兴趣。\n  **2、**如果打开一个工程，没办法通过阅读目录结构获得对整个项目结构的大致的了解，这样的目录结构就是不够合理的。这样会导致在不熟悉项目的情况下，很难明白各个模块、各个文件夹里的类的作用。\n  **3、**目录结构如果没有统一的规范，类文件的命名也很难有相应的规则来进行约束；\n  **4、**对于新加入项目的人，如果需要新增一些类文件，会不知道究竟该放在哪个目录下合适，只能先\"凭感觉\"随便找个地方一放。这样的工程维护起来，只会越来越乱。\n\n\n#三、我的个人经验\n\n**1、** 简叔在 [iOS 项目的目录结构能看出你的开发经验](http://www.jianshu.com/p/77a948bcbc38) 一文下的评论：\n> ![](http://upload-images.jianshu.io/upload_images/332029-ef0bc5110921e153.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n  看到这条评论不胜赞同。\n  我自己就很喜欢整理，不论是电脑上的盘符目录，还是印象笔记下的笔记本目录，我都习惯于编个号、定期整理。\n\n![](http://upload-images.jianshu.io/upload_images/332029-296141c755a00794.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n  这样一般我要找一个存在自己电脑上的东西，在找之前，头脑里就已经基本想到它会在那个大目录、哪个子目录下。配合搜索功能，很少会找不到文件。\n  同时，存的时候也不会随便找个地方一放，乱七八糟。基本已经形成一套自己熟悉的规则了。\n\n**2、** [高质量iOS开发系列之(一)－iOS项目工程及目录结构](http://mtydev.net/?p=1) 中提高的几个基本原则：\n> - 一个合理的目录结构应该是清晰的，让人一眼就能了解目录职责，并且是容易扩展的。\n> - 不管是第三方库还是自己的库，尽量用CocoPods来管理/区分不同层次的通用组件。\n    - General Level, 最通用的组件，可以在不同项目里复用。\n    - Project Level, 可以在该项目里复用。\n    - Section Level, 可以在某个功能模块里复用。\n> - 对于General Level的组件，以Library的形式分出来，不要放在主工程。\n> - 对于基础库，保证质量，通用性，可扩展性，易用性，可以不断迭代\n\n  此外，该文章中讲到的各模块注意事项，非常切合iOS开发的实际。建议[阅读原文](http://mtydev.net/?p=1)，我就不在这里搬运了。\n\n**3、**  [@汉斯哈哈哈](http://www.jianshu.com/users/368a8cd349af/latest_articles) 提到的两种常用目录结构的分法：\n>1.主目录按照业务分类，内目录按照模块分类\n>2.主目录按照模块分类，内目录按照业务分类\n\n  我个人偏向于第二种：按照业务模块划分。因为：\n> 1> 第一种如果项目较大，经常会出现找个控制器对应的tableviewcell找半天。如果不是自己写的，更难找。\n2> 开发某一具体功能的时候，涉及到的类基本都是该业务模块里面的类，很少会出现跨目录的情况。而第一种情况则需要经常会跨目录。\n3> 从文件耦合度来讲，各业务模块里的文件耦合度相对来说比较高。放在一个目录内，也符合软件设计中的高内聚低耦合思想。\n\n\n**4、一个简单的工程结构目录的Demo**\n- 一级目录如下：（中文备注是为了便于理解，实际项目中不要加）\n![](http://upload-images.jianshu.io/upload_images/332029-908a1195b32b770e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n- 二级目录如下：\n![](http://upload-images.jianshu.io/upload_images/332029-63f11bd45bc0c94f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n**5、公用的类、模块放在哪里：**\n  一般的做法是遇到共用模块单独建一个模块叫common，都放到这里。（这样其实也不是很好，Common也是属于定义模糊的命名）\n**6、多个Target的情况：**\n  可以单独出一个Project文件夹，按Target名分各个子目录，内放各个Target中独有的文件。\n**7、图片资源**最好都用 **Images.xcassets** 去管理。\n  **Images.xcassets** 文件里边也按业务模块分子文件夹，这样可以方便的预览图片。\n\n\n#四、Tips\n  **在定位项目中的文件**时，善用以下快捷键可以节省大量时间：\n\n**1、Xcode左下角的搜索框 （不支持模糊搜索、会展开对应目录）**\n\n![](http://upload-images.jianshu.io/upload_images/332029-c747563290d2b596.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n> 快捷键: Command + option + j\n\n![](http://upload-images.jianshu.io/upload_images/332029-7705e2a055900eb8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n**2、工程全局搜索**（支持模糊搜索、不会展开对应目录）\n> 快捷键: Command + shift + O\n![](http://upload-images.jianshu.io/upload_images/332029-56a1f25146ea0cba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n###注：\n  以上只是我个人的一些经验，总结的不是很完善。同时有很多地方借鉴了以下文章的观点。有什么能改进的地方，欢迎在评论区讨论！\n\n</br>\n\n>###参考：\n>[高质量iOS开发系列之(一)－iOS项目工程及目录结构](http://mtydev.net/?p=1)\n>[iOS项目的目录结构和开发流程](http://limboy.me/ios/2013/09/23/build-ios-application.html)\n>[iOS 项目的目录结构能看出你的开发经验](http://www.jianshu.com/p/77a948bcbc38)\n","slug":"20151129-project-contents","published":1,"updated":"2019-04-18T11:06:48.746Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjumvmxa5000traxesay80r6w","content":"<p>#一、前言<br>  在 <a href=\"http://www.jianshu.com/users/368a8cd349af/latest_articles\" target=\"_blank\" rel=\"noopener\">@汉斯哈哈哈</a> 的 <a href=\"http://www.jianshu.com/p/77a948bcbc38\" target=\"_blank\" rel=\"noopener\">iOS 项目的目录结构能看出你的开发经验</a> 这篇博客里提到一点：</p>\n<blockquote>\n<ul>\n<li>面试iOS开发，面试官竟然问他『<strong>怎么分目录结构</strong>』的，而且还具体问到每个子目录的文件名。</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>清晰的目录结构，可让人一眼知道对应目录的职能，这也能体现开发者的经验和架构能力。</li>\n</ul>\n</blockquote>\n<p>  恰巧，有一次我参加面试，也被问到过类似的问题。<br>  在日常工作中我自己对此也深有感触，《代码大全》里有个观点：</p>\n<blockquote>\n<p><strong>代码首先是给人看的</strong></p>\n</blockquote>\n<p>  我觉得，一个项目的目录结构也是如此。以下是我个人的一些看法。</p>\n<p>  </p>\n<p>#二、不合理的目录结构<br>  我想应该没人觉得一个项目的 「<strong>工程目录结构</strong>」这个东西不重要。<br>  没人讨论这个可能是因为项目不同、团队风格不一样、目录结构没有个通用的标准，不太好下个结论。<br>  而且项目<strong>工程目录结构</strong>这个东西，除非开始一个新项目，其它时候大多都是沿用旧项目里已有的目录结构。真正从无到有的完整搭一个新项目，除了软件外包公司，我想机会不是很多。</p>\n<p>  我因为非科班出身，刚入行时不是很懂，为了先找到一份工作，同时想着快速接触更多的项目（靠数量增加经验），所以在软件外包公司待过一段时间，接触了不少新开始的项目，也接手了不少旧项目的版本升级、维护等工作。</p>\n<p>###这是我接触过的一些项目的结构目录：<br><img src=\"http://upload-images.jianshu.io/upload_images/332029-9184199c95735d49.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt></p>\n<p>###为什么不合理：<br>  我觉得普遍<strong>存在以下几个问题</strong>：<br><strong>1 、目录结构没有层次性：</strong><br>  有的工程，一级目录展开后就是十几个二级目录的文件夹。<br><img src=\"http://upload-images.jianshu.io/upload_images/332029-a4cca08c1fe89985.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt><br><strong>2 、目录结构层次过深：</strong><br>  文件夹过多、层级过深，会增加点击的成本。<br><strong>3、单个目录下文件数过多</strong><br>  某级目录内文件数量过多，展开后超过一屏。出现这种情况，我觉得就是目录结构设置不合理导致的。<br><strong>4、目录命名不能够「见名知意」：</strong><br>  大量的 <strong>Common</strong>、<strong>Tool</strong>、<strong>Helper</strong>、<strong>Other</strong>这样的文件夹名。<br><strong>5、没有项目目录结构的ReadMe说明；</strong><br>  这个属于代码文档中不容忽视的一点。<br><strong>6、目录存在使用中文命名的情况；</strong><br><strong>7、结虚拟文件夹与实体文件夹没有一一对应：</strong><br><img src=\"http://upload-images.jianshu.io/upload_images/332029-c642553bee09d282.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt></p>\n<p>###可能导致的问题：</p>\n<p>  <strong>1、</strong>一个糟糕的目录会让人对工程瞬间失去兴趣。<br>  <strong>2、</strong>如果打开一个工程，没办法通过阅读目录结构获得对整个项目结构的大致的了解，这样的目录结构就是不够合理的。这样会导致在不熟悉项目的情况下，很难明白各个模块、各个文件夹里的类的作用。<br>  <strong>3、</strong>目录结构如果没有统一的规范，类文件的命名也很难有相应的规则来进行约束；<br>  <strong>4、</strong>对于新加入项目的人，如果需要新增一些类文件，会不知道究竟该放在哪个目录下合适，只能先”凭感觉”随便找个地方一放。这样的工程维护起来，只会越来越乱。</p>\n<p>#三、我的个人经验</p>\n<p><strong>1、</strong> 简叔在 <a href=\"http://www.jianshu.com/p/77a948bcbc38\" target=\"_blank\" rel=\"noopener\">iOS 项目的目录结构能看出你的开发经验</a> 一文下的评论：</p>\n<blockquote>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/332029-ef0bc5110921e153.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt></p>\n</blockquote>\n<p>  看到这条评论不胜赞同。<br>  我自己就很喜欢整理，不论是电脑上的盘符目录，还是印象笔记下的笔记本目录，我都习惯于编个号、定期整理。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/332029-296141c755a00794.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt><br>  这样一般我要找一个存在自己电脑上的东西，在找之前，头脑里就已经基本想到它会在那个大目录、哪个子目录下。配合搜索功能，很少会找不到文件。<br>  同时，存的时候也不会随便找个地方一放，乱七八糟。基本已经形成一套自己熟悉的规则了。</p>\n<p><strong>2、</strong> <a href=\"http://mtydev.net/?p=1\" target=\"_blank\" rel=\"noopener\">高质量iOS开发系列之(一)－iOS项目工程及目录结构</a> 中提高的几个基本原则：</p>\n<blockquote>\n<ul>\n<li>一个合理的目录结构应该是清晰的，让人一眼就能了解目录职责，并且是容易扩展的。</li>\n<li>不管是第三方库还是自己的库，尽量用CocoPods来管理/区分不同层次的通用组件。<ul>\n<li>General Level, 最通用的组件，可以在不同项目里复用。</li>\n<li>Project Level, 可以在该项目里复用。</li>\n<li>Section Level, 可以在某个功能模块里复用。</li>\n</ul>\n</li>\n<li>对于General Level的组件，以Library的形式分出来，不要放在主工程。</li>\n<li>对于基础库，保证质量，通用性，可扩展性，易用性，可以不断迭代</li>\n</ul>\n</blockquote>\n<p>  此外，该文章中讲到的各模块注意事项，非常切合iOS开发的实际。建议<a href=\"http://mtydev.net/?p=1\" target=\"_blank\" rel=\"noopener\">阅读原文</a>，我就不在这里搬运了。</p>\n<p><strong>3、</strong>  <a href=\"http://www.jianshu.com/users/368a8cd349af/latest_articles\" target=\"_blank\" rel=\"noopener\">@汉斯哈哈哈</a> 提到的两种常用目录结构的分法：</p>\n<blockquote>\n<p>1.主目录按照业务分类，内目录按照模块分类<br>2.主目录按照模块分类，内目录按照业务分类</p>\n</blockquote>\n<p>  我个人偏向于第二种：按照业务模块划分。因为：</p>\n<blockquote>\n<p>1&gt; 第一种如果项目较大，经常会出现找个控制器对应的tableviewcell找半天。如果不是自己写的，更难找。<br>2&gt; 开发某一具体功能的时候，涉及到的类基本都是该业务模块里面的类，很少会出现跨目录的情况。而第一种情况则需要经常会跨目录。<br>3&gt; 从文件耦合度来讲，各业务模块里的文件耦合度相对来说比较高。放在一个目录内，也符合软件设计中的高内聚低耦合思想。</p>\n</blockquote>\n<p><strong>4、一个简单的工程结构目录的Demo</strong></p>\n<ul>\n<li>一级目录如下：（中文备注是为了便于理解，实际项目中不要加）<br><img src=\"http://upload-images.jianshu.io/upload_images/332029-908a1195b32b770e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt></li>\n<li>二级目录如下：<br><img src=\"http://upload-images.jianshu.io/upload_images/332029-63f11bd45bc0c94f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt></li>\n</ul>\n<p><strong>5、公用的类、模块放在哪里：</strong><br>  一般的做法是遇到共用模块单独建一个模块叫common，都放到这里。（这样其实也不是很好，Common也是属于定义模糊的命名）<br><strong>6、多个Target的情况：</strong><br>  可以单独出一个Project文件夹，按Target名分各个子目录，内放各个Target中独有的文件。<br><strong>7、图片资源</strong>最好都用 <strong>Images.xcassets</strong> 去管理。<br>  <strong>Images.xcassets</strong> 文件里边也按业务模块分子文件夹，这样可以方便的预览图片。</p>\n<p>#四、Tips<br>  <strong>在定位项目中的文件</strong>时，善用以下快捷键可以节省大量时间：</p>\n<p><strong>1、Xcode左下角的搜索框 （不支持模糊搜索、会展开对应目录）</strong></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/332029-c747563290d2b596.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt></p>\n<blockquote>\n<p>快捷键: Command + option + j</p>\n</blockquote>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/332029-7705e2a055900eb8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt></p>\n<p><strong>2、工程全局搜索</strong>（支持模糊搜索、不会展开对应目录）</p>\n<blockquote>\n<p>快捷键: Command + shift + O<br><img src=\"http://upload-images.jianshu.io/upload_images/332029-56a1f25146ea0cba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt></p>\n</blockquote>\n<p>###注：<br>  以上只是我个人的一些经验，总结的不是很完善。同时有很多地方借鉴了以下文章的观点。有什么能改进的地方，欢迎在评论区讨论！</p>\n<p><br></p>\n<blockquote>\n<p>###参考：<br><a href=\"http://mtydev.net/?p=1\" target=\"_blank\" rel=\"noopener\">高质量iOS开发系列之(一)－iOS项目工程及目录结构</a><br><a href=\"http://limboy.me/ios/2013/09/23/build-ios-application.html\" target=\"_blank\" rel=\"noopener\">iOS项目的目录结构和开发流程</a><br><a href=\"http://www.jianshu.com/p/77a948bcbc38\" target=\"_blank\" rel=\"noopener\">iOS 项目的目录结构能看出你的开发经验</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>#一、前言<br>  在 <a href=\"http://www.jianshu.com/users/368a8cd349af/latest_articles\" target=\"_blank\" rel=\"noopener\">@汉斯哈哈哈</a> 的 <a href=\"http://www.jianshu.com/p/77a948bcbc38\" target=\"_blank\" rel=\"noopener\">iOS 项目的目录结构能看出你的开发经验</a> 这篇博客里提到一点：</p>\n<blockquote>\n<ul>\n<li>面试iOS开发，面试官竟然问他『<strong>怎么分目录结构</strong>』的，而且还具体问到每个子目录的文件名。</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>清晰的目录结构，可让人一眼知道对应目录的职能，这也能体现开发者的经验和架构能力。</li>\n</ul>\n</blockquote>\n<p>  恰巧，有一次我参加面试，也被问到过类似的问题。<br>  在日常工作中我自己对此也深有感触，《代码大全》里有个观点：</p>\n<blockquote>\n<p><strong>代码首先是给人看的</strong></p>\n</blockquote>\n<p>  我觉得，一个项目的目录结构也是如此。以下是我个人的一些看法。</p>\n<p>  </p>\n<p>#二、不合理的目录结构<br>  我想应该没人觉得一个项目的 「<strong>工程目录结构</strong>」这个东西不重要。<br>  没人讨论这个可能是因为项目不同、团队风格不一样、目录结构没有个通用的标准，不太好下个结论。<br>  而且项目<strong>工程目录结构</strong>这个东西，除非开始一个新项目，其它时候大多都是沿用旧项目里已有的目录结构。真正从无到有的完整搭一个新项目，除了软件外包公司，我想机会不是很多。</p>\n<p>  我因为非科班出身，刚入行时不是很懂，为了先找到一份工作，同时想着快速接触更多的项目（靠数量增加经验），所以在软件外包公司待过一段时间，接触了不少新开始的项目，也接手了不少旧项目的版本升级、维护等工作。</p>\n<p>###这是我接触过的一些项目的结构目录：<br><img src=\"http://upload-images.jianshu.io/upload_images/332029-9184199c95735d49.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt></p>\n<p>###为什么不合理：<br>  我觉得普遍<strong>存在以下几个问题</strong>：<br><strong>1 、目录结构没有层次性：</strong><br>  有的工程，一级目录展开后就是十几个二级目录的文件夹。<br><img src=\"http://upload-images.jianshu.io/upload_images/332029-a4cca08c1fe89985.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt><br><strong>2 、目录结构层次过深：</strong><br>  文件夹过多、层级过深，会增加点击的成本。<br><strong>3、单个目录下文件数过多</strong><br>  某级目录内文件数量过多，展开后超过一屏。出现这种情况，我觉得就是目录结构设置不合理导致的。<br><strong>4、目录命名不能够「见名知意」：</strong><br>  大量的 <strong>Common</strong>、<strong>Tool</strong>、<strong>Helper</strong>、<strong>Other</strong>这样的文件夹名。<br><strong>5、没有项目目录结构的ReadMe说明；</strong><br>  这个属于代码文档中不容忽视的一点。<br><strong>6、目录存在使用中文命名的情况；</strong><br><strong>7、结虚拟文件夹与实体文件夹没有一一对应：</strong><br><img src=\"http://upload-images.jianshu.io/upload_images/332029-c642553bee09d282.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt></p>\n<p>###可能导致的问题：</p>\n<p>  <strong>1、</strong>一个糟糕的目录会让人对工程瞬间失去兴趣。<br>  <strong>2、</strong>如果打开一个工程，没办法通过阅读目录结构获得对整个项目结构的大致的了解，这样的目录结构就是不够合理的。这样会导致在不熟悉项目的情况下，很难明白各个模块、各个文件夹里的类的作用。<br>  <strong>3、</strong>目录结构如果没有统一的规范，类文件的命名也很难有相应的规则来进行约束；<br>  <strong>4、</strong>对于新加入项目的人，如果需要新增一些类文件，会不知道究竟该放在哪个目录下合适，只能先”凭感觉”随便找个地方一放。这样的工程维护起来，只会越来越乱。</p>\n<p>#三、我的个人经验</p>\n<p><strong>1、</strong> 简叔在 <a href=\"http://www.jianshu.com/p/77a948bcbc38\" target=\"_blank\" rel=\"noopener\">iOS 项目的目录结构能看出你的开发经验</a> 一文下的评论：</p>\n<blockquote>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/332029-ef0bc5110921e153.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt></p>\n</blockquote>\n<p>  看到这条评论不胜赞同。<br>  我自己就很喜欢整理，不论是电脑上的盘符目录，还是印象笔记下的笔记本目录，我都习惯于编个号、定期整理。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/332029-296141c755a00794.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt><br>  这样一般我要找一个存在自己电脑上的东西，在找之前，头脑里就已经基本想到它会在那个大目录、哪个子目录下。配合搜索功能，很少会找不到文件。<br>  同时，存的时候也不会随便找个地方一放，乱七八糟。基本已经形成一套自己熟悉的规则了。</p>\n<p><strong>2、</strong> <a href=\"http://mtydev.net/?p=1\" target=\"_blank\" rel=\"noopener\">高质量iOS开发系列之(一)－iOS项目工程及目录结构</a> 中提高的几个基本原则：</p>\n<blockquote>\n<ul>\n<li>一个合理的目录结构应该是清晰的，让人一眼就能了解目录职责，并且是容易扩展的。</li>\n<li>不管是第三方库还是自己的库，尽量用CocoPods来管理/区分不同层次的通用组件。<ul>\n<li>General Level, 最通用的组件，可以在不同项目里复用。</li>\n<li>Project Level, 可以在该项目里复用。</li>\n<li>Section Level, 可以在某个功能模块里复用。</li>\n</ul>\n</li>\n<li>对于General Level的组件，以Library的形式分出来，不要放在主工程。</li>\n<li>对于基础库，保证质量，通用性，可扩展性，易用性，可以不断迭代</li>\n</ul>\n</blockquote>\n<p>  此外，该文章中讲到的各模块注意事项，非常切合iOS开发的实际。建议<a href=\"http://mtydev.net/?p=1\" target=\"_blank\" rel=\"noopener\">阅读原文</a>，我就不在这里搬运了。</p>\n<p><strong>3、</strong>  <a href=\"http://www.jianshu.com/users/368a8cd349af/latest_articles\" target=\"_blank\" rel=\"noopener\">@汉斯哈哈哈</a> 提到的两种常用目录结构的分法：</p>\n<blockquote>\n<p>1.主目录按照业务分类，内目录按照模块分类<br>2.主目录按照模块分类，内目录按照业务分类</p>\n</blockquote>\n<p>  我个人偏向于第二种：按照业务模块划分。因为：</p>\n<blockquote>\n<p>1&gt; 第一种如果项目较大，经常会出现找个控制器对应的tableviewcell找半天。如果不是自己写的，更难找。<br>2&gt; 开发某一具体功能的时候，涉及到的类基本都是该业务模块里面的类，很少会出现跨目录的情况。而第一种情况则需要经常会跨目录。<br>3&gt; 从文件耦合度来讲，各业务模块里的文件耦合度相对来说比较高。放在一个目录内，也符合软件设计中的高内聚低耦合思想。</p>\n</blockquote>\n<p><strong>4、一个简单的工程结构目录的Demo</strong></p>\n<ul>\n<li>一级目录如下：（中文备注是为了便于理解，实际项目中不要加）<br><img src=\"http://upload-images.jianshu.io/upload_images/332029-908a1195b32b770e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt></li>\n<li>二级目录如下：<br><img src=\"http://upload-images.jianshu.io/upload_images/332029-63f11bd45bc0c94f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt></li>\n</ul>\n<p><strong>5、公用的类、模块放在哪里：</strong><br>  一般的做法是遇到共用模块单独建一个模块叫common，都放到这里。（这样其实也不是很好，Common也是属于定义模糊的命名）<br><strong>6、多个Target的情况：</strong><br>  可以单独出一个Project文件夹，按Target名分各个子目录，内放各个Target中独有的文件。<br><strong>7、图片资源</strong>最好都用 <strong>Images.xcassets</strong> 去管理。<br>  <strong>Images.xcassets</strong> 文件里边也按业务模块分子文件夹，这样可以方便的预览图片。</p>\n<p>#四、Tips<br>  <strong>在定位项目中的文件</strong>时，善用以下快捷键可以节省大量时间：</p>\n<p><strong>1、Xcode左下角的搜索框 （不支持模糊搜索、会展开对应目录）</strong></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/332029-c747563290d2b596.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt></p>\n<blockquote>\n<p>快捷键: Command + option + j</p>\n</blockquote>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/332029-7705e2a055900eb8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt></p>\n<p><strong>2、工程全局搜索</strong>（支持模糊搜索、不会展开对应目录）</p>\n<blockquote>\n<p>快捷键: Command + shift + O<br><img src=\"http://upload-images.jianshu.io/upload_images/332029-56a1f25146ea0cba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt></p>\n</blockquote>\n<p>###注：<br>  以上只是我个人的一些经验，总结的不是很完善。同时有很多地方借鉴了以下文章的观点。有什么能改进的地方，欢迎在评论区讨论！</p>\n<p><br></p>\n<blockquote>\n<p>###参考：<br><a href=\"http://mtydev.net/?p=1\" target=\"_blank\" rel=\"noopener\">高质量iOS开发系列之(一)－iOS项目工程及目录结构</a><br><a href=\"http://limboy.me/ios/2013/09/23/build-ios-application.html\" target=\"_blank\" rel=\"noopener\">iOS项目的目录结构和开发流程</a><br><a href=\"http://www.jianshu.com/p/77a948bcbc38\" target=\"_blank\" rel=\"noopener\">iOS 项目的目录结构能看出你的开发经验</a></p>\n</blockquote>\n"},{"title":"为什么iOS项目应该用CocoaPods","date":"2015-11-28T08:02:56.000Z","_content":"\n**为什么iOS项目中应该使用CocoaPods作为第三方依赖管理工具？**\n\n![](http://upload-images.jianshu.io/upload_images/332029-76f5038a773b7863.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n>**目录：**\n     > - 从一个bug说起\n     > - 分析需求及解决方案\n     > - 确定方案\n     > - CocoaPods学习资料\n\n\n#一、从一个bug说起：\n1、公司的项目里统一使用SVG格式的图片；\n2、GitHub上只有一个star数超过一千的SVG解析库，叫SVGKit。（对，就是这个坑爹的库）\n         **坑1：** 这个库一直使用非ARC，有100多个类；</a>\n         **坑2：** 这个库还依赖另外一个库CocoaLumberjack；\n         **坑3：** 把这个库配置到项目中就会报一种错误：\n![](http://upload-images.jianshu.io/upload_images/332029-41102bc3ee4544b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n3、公司的项目是直接以源码的形式使用的该库。\n        结果就是 **Build Phase** 中成了这样：\n   （我不知道当初加这些 -fno-objc-arc 标记的人是否崩溃，我光看着就觉得淡淡的忧桑：这么多得加多久？加漏了或者多加了，都是坑。）\n![](http://upload-images.jianshu.io/upload_images/332029-e085b55b305df854.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n4、因为用的源码，项目里的SVGKit版本很久都不会更新。导致在iPhone6S以上设备时，由于旧版本的库没有适配6S，必崩。现在必须要更新到这个库的最新版本。\n\n#**二、解决方案的探索：**\n##方案一：\n>**用最新源码替换掉旧版源码文件**\n  问题：1、类文件太多，麻烦，容易出错；\n     2、还是会有大量的 -fno-objc-arc 标记，很烦；\n       结论：**否决**\n\n##方案二：\n>**SVGKit作者推荐——静态库**（该库的GitHub页面也只介绍了这一种用法）\n  问题：1、只有.h 头文件，出错没法定位和修改。\n     2、静态库里使用了category必须要加 -ObjC 标记。\n     3、静态库.a文件需要区分device版本和simulator版本，或者合并后使用。\n  结论：**否决**\n\n\n关于**问题2**这里要解释下，本来是没什么问题的，但我不幸遇到了**这个坑**：\n  1、静态库里如果使用了 **category**，需要加 **-ObjC** 标记。否则在使用的时会崩溃：\n![](http://upload-images.jianshu.io/upload_images/332029-83821f8d987a4e16.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n  2、当时花了好久没解决这个问题的原因是，我记得自己设置了呀。\n     后来才想起来为毛还是崩，这是我们的项目target，你们感受下：\n\n![](http://upload-images.jianshu.io/upload_images/332029-a4084793b6c2f4ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n    有任何一个target忘了设置，就又埋了个坑。\n  3、关于 **为什么要加 -ObjC 标记** 的问题，以前是有查过资料的，这里完全是因为target太多遗漏导致的。\n>####笔记如下：  \n**-ObjC 标记的作用:**\n     > - 用到一个第三方库，这个库的使用向导里面特别说明，在添加完该库后，需要在Xcode的Build Settings下Other Linker Flags里面加入-ObjC标志。之所以使用该标志，和Objective-C的一个重要特性：类别（category)有关。根据[这里](https://developer.apple.com/library/mac/qa/qa1490/_index.html)的解释，Unix的标准静态库实现和Objective-C的动态特性之间有一些冲突：Objective-C没有为每个函数（或者方法）定义链接符号，它只为每个类创建链接符号。\n> - 这样当在一个静态库中使用类别来扩展已有类的时候，链接器不知道如何把类原有的方法和类别中的方法整合起来，就会导致你调用类别中的方法时，出现\"selector not recognized\"，也就是找不到方法定义的错误。\n> - 为了解决这个问题，引入了-ObjC标志，它的作用就是将静态库中所有的和对象相关的文件都加载进来。\n> - 本来这样就可以解决问题了，不过在64位的Mac系统或者iOS系统下，链接器有一个bug，会导致只包含有类别的静态库无法使用-ObjC标志来加载文件。变通方法是使用-all_load 或者-force_load标志，它们的作用都是加载静态库中所有文件，不过all_load作用于所有的库，而-force_load后面必须要指定具体的文件。\n\n##方案三：\n>**使用 CocoaPods **\n问题：作者没有说明这个库**是否支持CocoaPods**\n   这也是我最开始没有考虑改用 CocoaPods 的原因）\n\n- 这里提示大家，可以使用以下命令，测试某个库是否支持CocoaPods\n```$ pod try XXX```\n\n     鉴于这里不是介绍如何使用 CocoaPods，这里只讨论下使用 CocoaPods 的好处，以及一些使用经验（我会在后文列一些 CocoaPods 的资料）。\n\n>优点：\n1、解决了方案一中，需要在项目里 **大量标记 -fno-objc-arc **的问题：\n—— CocoaPods自动生成的关联库会在关联工程中自动标记好，原始项目中只管用就行\n2、解决了方案二中，只有.h 头文件，**没有源码**、出错没法定位和修改的问题：\n—— CocoaPods也是使用静态库依赖，但是保留全部.m文件\n3、解决了方案二中，静态库使用时的一些坑，和**需要打包.a文件的麻烦操作**。\n—— CocoaPods自动完成\n4、极大的简化了**操作**：\n  1> cd进入.xcodeproj文件所在的目录\n  ```$ pod init```\n  2> 在自动生成的Podfile文件中，加入要pod的库名\n  ```$ pod install```\n  3> 搞定。\n     5、最重要的一点：以后再遇到这次的升级第三方库版本的需求时，只需一行命令即可：\n  ```$ pod update```\n结论：**就是这个了！**\n\n#确定方案\n> CocoaPods 一劳永逸的解决了第三方库版本升级的问题。\n\n#就酱~\n\n#干货部分\n>CocoaPods学习资料\n\n####CocoaPods入门：\n1、[CocoaPods安装和使用教程](http://code4app.com/article/cocoapods-install-usage)\n（入门看这一篇就够了）\n2、CocoaPods pod install/pod update**更新慢的问题**\n  最近使用CocoaPods来添加第三方类库，无论是执行pod install还是pod update都卡在了Analyzing dependencies不动\n  原因在于当执行以上两个命令的时候会升级CocoaPods的spec仓库，加一个参数可以省略这一步，然后速度就会提升不少。命令如下：\n```\npod install --verbose --no-repo-update\npod update --verbose --no-repo-update\n```\n3、mac升级到10.11，**cocoapods没了**\n  使用命令行sudo gem install cocoa pods出错，换成sudo gem install -n /usr/local/bin cocoa pods即可，详见： http://t.cn/Ry8tZAs\n4、**使用经验：**\n  1> pods install 时，可以不加版本号（默认下载对应库的**最新版本**）\n![](http://upload-images.jianshu.io/upload_images/332029-9293ed3a288b838e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n  但是，下载完依赖后，最好**加上版本号**，避免在添加了新的库，或者pod update时，由于某些第三方库频繁升级而带来的不稳定。\n![](http://upload-images.jianshu.io/upload_images/332029-22cd97e2d756cb04.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n  2> 多人合作的较大项目，Podfile文件可以设置权限，只由一个人来修改、添加依赖的库。\n  3 > SVN或者Git做版本管理时，不要上传 Pods 、workspace 目录：\n（可以设置ignore）\n![](http://upload-images.jianshu.io/upload_images/332029-4e55d2d3a6b9d29f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n###CocoaPods高阶用法：\n\n1、[即使你不使用第三方库，CocoaPods仍然是一个管理代码相关性的绝佳工具](\n     http://nshipster.cn/cocoapods/#%E4%BD%BF%E7%94%A8cocoapods)\n2、[借助GitHub托管Category,利用CocoaPods集成到项目中](\n     https://github.com/Damonvvong/DWCategory)\n3、[Cocoapods创建私有podspec](http://blog.wtlucky.com/blog/2015/02/26/create-private-podspec/)\n4、[写一个Pod发布到CocoaPods](http://blog.csdn.net/becomedragonlong/article/details/45933345#0-tsina-1-22915-397232)\n5、[CocoaPods的一些略为高级一丁点的使用](http://supermao.cn/cocoapodsde-xie-lue-wei-gao-ji-ding-dian-de-shi-yong/)\n\n```\n//TODO:1、利用多个 project 做本地依赖管理\n       2、私有仓库的使用尝试\n```\n","source":"_posts/20151128-why-cocoaPods.md","raw":"---\ntitle: 为什么iOS项目应该用CocoaPods\ndate: 2015-11-28 16:02:56\ntags: CocoaPods\ncategories: iOS组件化\n---\n\n**为什么iOS项目中应该使用CocoaPods作为第三方依赖管理工具？**\n\n![](http://upload-images.jianshu.io/upload_images/332029-76f5038a773b7863.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n>**目录：**\n     > - 从一个bug说起\n     > - 分析需求及解决方案\n     > - 确定方案\n     > - CocoaPods学习资料\n\n\n#一、从一个bug说起：\n1、公司的项目里统一使用SVG格式的图片；\n2、GitHub上只有一个star数超过一千的SVG解析库，叫SVGKit。（对，就是这个坑爹的库）\n         **坑1：** 这个库一直使用非ARC，有100多个类；</a>\n         **坑2：** 这个库还依赖另外一个库CocoaLumberjack；\n         **坑3：** 把这个库配置到项目中就会报一种错误：\n![](http://upload-images.jianshu.io/upload_images/332029-41102bc3ee4544b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n3、公司的项目是直接以源码的形式使用的该库。\n        结果就是 **Build Phase** 中成了这样：\n   （我不知道当初加这些 -fno-objc-arc 标记的人是否崩溃，我光看着就觉得淡淡的忧桑：这么多得加多久？加漏了或者多加了，都是坑。）\n![](http://upload-images.jianshu.io/upload_images/332029-e085b55b305df854.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n4、因为用的源码，项目里的SVGKit版本很久都不会更新。导致在iPhone6S以上设备时，由于旧版本的库没有适配6S，必崩。现在必须要更新到这个库的最新版本。\n\n#**二、解决方案的探索：**\n##方案一：\n>**用最新源码替换掉旧版源码文件**\n  问题：1、类文件太多，麻烦，容易出错；\n     2、还是会有大量的 -fno-objc-arc 标记，很烦；\n       结论：**否决**\n\n##方案二：\n>**SVGKit作者推荐——静态库**（该库的GitHub页面也只介绍了这一种用法）\n  问题：1、只有.h 头文件，出错没法定位和修改。\n     2、静态库里使用了category必须要加 -ObjC 标记。\n     3、静态库.a文件需要区分device版本和simulator版本，或者合并后使用。\n  结论：**否决**\n\n\n关于**问题2**这里要解释下，本来是没什么问题的，但我不幸遇到了**这个坑**：\n  1、静态库里如果使用了 **category**，需要加 **-ObjC** 标记。否则在使用的时会崩溃：\n![](http://upload-images.jianshu.io/upload_images/332029-83821f8d987a4e16.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n  2、当时花了好久没解决这个问题的原因是，我记得自己设置了呀。\n     后来才想起来为毛还是崩，这是我们的项目target，你们感受下：\n\n![](http://upload-images.jianshu.io/upload_images/332029-a4084793b6c2f4ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n    有任何一个target忘了设置，就又埋了个坑。\n  3、关于 **为什么要加 -ObjC 标记** 的问题，以前是有查过资料的，这里完全是因为target太多遗漏导致的。\n>####笔记如下：  \n**-ObjC 标记的作用:**\n     > - 用到一个第三方库，这个库的使用向导里面特别说明，在添加完该库后，需要在Xcode的Build Settings下Other Linker Flags里面加入-ObjC标志。之所以使用该标志，和Objective-C的一个重要特性：类别（category)有关。根据[这里](https://developer.apple.com/library/mac/qa/qa1490/_index.html)的解释，Unix的标准静态库实现和Objective-C的动态特性之间有一些冲突：Objective-C没有为每个函数（或者方法）定义链接符号，它只为每个类创建链接符号。\n> - 这样当在一个静态库中使用类别来扩展已有类的时候，链接器不知道如何把类原有的方法和类别中的方法整合起来，就会导致你调用类别中的方法时，出现\"selector not recognized\"，也就是找不到方法定义的错误。\n> - 为了解决这个问题，引入了-ObjC标志，它的作用就是将静态库中所有的和对象相关的文件都加载进来。\n> - 本来这样就可以解决问题了，不过在64位的Mac系统或者iOS系统下，链接器有一个bug，会导致只包含有类别的静态库无法使用-ObjC标志来加载文件。变通方法是使用-all_load 或者-force_load标志，它们的作用都是加载静态库中所有文件，不过all_load作用于所有的库，而-force_load后面必须要指定具体的文件。\n\n##方案三：\n>**使用 CocoaPods **\n问题：作者没有说明这个库**是否支持CocoaPods**\n   这也是我最开始没有考虑改用 CocoaPods 的原因）\n\n- 这里提示大家，可以使用以下命令，测试某个库是否支持CocoaPods\n```$ pod try XXX```\n\n     鉴于这里不是介绍如何使用 CocoaPods，这里只讨论下使用 CocoaPods 的好处，以及一些使用经验（我会在后文列一些 CocoaPods 的资料）。\n\n>优点：\n1、解决了方案一中，需要在项目里 **大量标记 -fno-objc-arc **的问题：\n—— CocoaPods自动生成的关联库会在关联工程中自动标记好，原始项目中只管用就行\n2、解决了方案二中，只有.h 头文件，**没有源码**、出错没法定位和修改的问题：\n—— CocoaPods也是使用静态库依赖，但是保留全部.m文件\n3、解决了方案二中，静态库使用时的一些坑，和**需要打包.a文件的麻烦操作**。\n—— CocoaPods自动完成\n4、极大的简化了**操作**：\n  1> cd进入.xcodeproj文件所在的目录\n  ```$ pod init```\n  2> 在自动生成的Podfile文件中，加入要pod的库名\n  ```$ pod install```\n  3> 搞定。\n     5、最重要的一点：以后再遇到这次的升级第三方库版本的需求时，只需一行命令即可：\n  ```$ pod update```\n结论：**就是这个了！**\n\n#确定方案\n> CocoaPods 一劳永逸的解决了第三方库版本升级的问题。\n\n#就酱~\n\n#干货部分\n>CocoaPods学习资料\n\n####CocoaPods入门：\n1、[CocoaPods安装和使用教程](http://code4app.com/article/cocoapods-install-usage)\n（入门看这一篇就够了）\n2、CocoaPods pod install/pod update**更新慢的问题**\n  最近使用CocoaPods来添加第三方类库，无论是执行pod install还是pod update都卡在了Analyzing dependencies不动\n  原因在于当执行以上两个命令的时候会升级CocoaPods的spec仓库，加一个参数可以省略这一步，然后速度就会提升不少。命令如下：\n```\npod install --verbose --no-repo-update\npod update --verbose --no-repo-update\n```\n3、mac升级到10.11，**cocoapods没了**\n  使用命令行sudo gem install cocoa pods出错，换成sudo gem install -n /usr/local/bin cocoa pods即可，详见： http://t.cn/Ry8tZAs\n4、**使用经验：**\n  1> pods install 时，可以不加版本号（默认下载对应库的**最新版本**）\n![](http://upload-images.jianshu.io/upload_images/332029-9293ed3a288b838e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n  但是，下载完依赖后，最好**加上版本号**，避免在添加了新的库，或者pod update时，由于某些第三方库频繁升级而带来的不稳定。\n![](http://upload-images.jianshu.io/upload_images/332029-22cd97e2d756cb04.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n  2> 多人合作的较大项目，Podfile文件可以设置权限，只由一个人来修改、添加依赖的库。\n  3 > SVN或者Git做版本管理时，不要上传 Pods 、workspace 目录：\n（可以设置ignore）\n![](http://upload-images.jianshu.io/upload_images/332029-4e55d2d3a6b9d29f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n###CocoaPods高阶用法：\n\n1、[即使你不使用第三方库，CocoaPods仍然是一个管理代码相关性的绝佳工具](\n     http://nshipster.cn/cocoapods/#%E4%BD%BF%E7%94%A8cocoapods)\n2、[借助GitHub托管Category,利用CocoaPods集成到项目中](\n     https://github.com/Damonvvong/DWCategory)\n3、[Cocoapods创建私有podspec](http://blog.wtlucky.com/blog/2015/02/26/create-private-podspec/)\n4、[写一个Pod发布到CocoaPods](http://blog.csdn.net/becomedragonlong/article/details/45933345#0-tsina-1-22915-397232)\n5、[CocoaPods的一些略为高级一丁点的使用](http://supermao.cn/cocoapodsde-xie-lue-wei-gao-ji-ding-dian-de-shi-yong/)\n\n```\n//TODO:1、利用多个 project 做本地依赖管理\n       2、私有仓库的使用尝试\n```\n","slug":"20151128-why-cocoaPods","published":1,"updated":"2019-04-18T11:06:48.746Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjumvmxa8000vraxewx2ovgmg","content":"<p><strong>为什么iOS项目中应该使用CocoaPods作为第三方依赖管理工具？</strong></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/332029-76f5038a773b7863.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt></p>\n<blockquote>\n<p><strong>目录：</strong></p>\n<ul>\n<li>从一个bug说起</li>\n<li>分析需求及解决方案</li>\n<li>确定方案</li>\n<li>CocoaPods学习资料</li>\n</ul>\n</blockquote>\n<p>#一、从一个bug说起：<br>1、公司的项目里统一使用SVG格式的图片；<br>2、GitHub上只有一个star数超过一千的SVG解析库，叫SVGKit。（对，就是这个坑爹的库）<br>         <strong>坑1：</strong> 这个库一直使用非ARC，有100多个类；<br>         <strong>坑2：</strong> 这个库还依赖另外一个库CocoaLumberjack；<br>         <strong>坑3：</strong> 把这个库配置到项目中就会报一种错误：<br><img src=\"http://upload-images.jianshu.io/upload_images/332029-41102bc3ee4544b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt></p>\n<p>3、公司的项目是直接以源码的形式使用的该库。<br>        结果就是 <strong>Build Phase</strong> 中成了这样：<br>   （我不知道当初加这些 -fno-objc-arc 标记的人是否崩溃，我光看着就觉得淡淡的忧桑：这么多得加多久？加漏了或者多加了，都是坑。）<br><img src=\"http://upload-images.jianshu.io/upload_images/332029-e085b55b305df854.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt></p>\n<p>4、因为用的源码，项目里的SVGKit版本很久都不会更新。导致在iPhone6S以上设备时，由于旧版本的库没有适配6S，必崩。现在必须要更新到这个库的最新版本。</p>\n<p>#<strong>二、解决方案的探索：</strong></p>\n<p>##方案一：</p>\n<blockquote>\n<p><strong>用最新源码替换掉旧版源码文件</strong><br>  问题：1、类文件太多，麻烦，容易出错；<br>     2、还是会有大量的 -fno-objc-arc 标记，很烦；<br>       结论：<strong>否决</strong></p>\n</blockquote>\n<p>##方案二：</p>\n<blockquote>\n<p><strong>SVGKit作者推荐——静态库</strong>（该库的GitHub页面也只介绍了这一种用法）<br>  问题：1、只有.h 头文件，出错没法定位和修改。<br>     2、静态库里使用了category必须要加 -ObjC 标记。<br>     3、静态库.a文件需要区分device版本和simulator版本，或者合并后使用。<br>  结论：<strong>否决</strong></p>\n</blockquote>\n<p>关于<strong>问题2</strong>这里要解释下，本来是没什么问题的，但我不幸遇到了<strong>这个坑</strong>：<br>  1、静态库里如果使用了 <strong>category</strong>，需要加 <strong>-ObjC</strong> 标记。否则在使用的时会崩溃：<br><img src=\"http://upload-images.jianshu.io/upload_images/332029-83821f8d987a4e16.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt><br>  2、当时花了好久没解决这个问题的原因是，我记得自己设置了呀。<br>     后来才想起来为毛还是崩，这是我们的项目target，你们感受下：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/332029-a4084793b6c2f4ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt></p>\n<p>    有任何一个target忘了设置，就又埋了个坑。<br>  3、关于 <strong>为什么要加 -ObjC 标记</strong> 的问题，以前是有查过资料的，这里完全是因为target太多遗漏导致的。</p>\n<blockquote>\n<p>####笔记如下：  <br><strong>-ObjC 标记的作用:</strong></p>\n<ul>\n<li>用到一个第三方库，这个库的使用向导里面特别说明，在添加完该库后，需要在Xcode的Build Settings下Other Linker Flags里面加入-ObjC标志。之所以使用该标志，和Objective-C的一个重要特性：类别（category)有关。根据<a href=\"https://developer.apple.com/library/mac/qa/qa1490/_index.html\" target=\"_blank\" rel=\"noopener\">这里</a>的解释，Unix的标准静态库实现和Objective-C的动态特性之间有一些冲突：Objective-C没有为每个函数（或者方法）定义链接符号，它只为每个类创建链接符号。</li>\n<li>这样当在一个静态库中使用类别来扩展已有类的时候，链接器不知道如何把类原有的方法和类别中的方法整合起来，就会导致你调用类别中的方法时，出现”selector not recognized”，也就是找不到方法定义的错误。</li>\n<li>为了解决这个问题，引入了-ObjC标志，它的作用就是将静态库中所有的和对象相关的文件都加载进来。</li>\n<li>本来这样就可以解决问题了，不过在64位的Mac系统或者iOS系统下，链接器有一个bug，会导致只包含有类别的静态库无法使用-ObjC标志来加载文件。变通方法是使用-all_load 或者-force_load标志，它们的作用都是加载静态库中所有文件，不过all_load作用于所有的库，而-force_load后面必须要指定具体的文件。</li>\n</ul>\n</blockquote>\n<p>##方案三：</p>\n<blockquote>\n<p><strong>使用 CocoaPods </strong><br>问题：作者没有说明这个库<strong>是否支持CocoaPods</strong><br>   这也是我最开始没有考虑改用 CocoaPods 的原因）</p>\n</blockquote>\n<ul>\n<li>这里提示大家，可以使用以下命令，测试某个库是否支持CocoaPods<figure class=\"highlight plain\"><figcaption><span>pod try XXX```</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">     鉴于这里不是介绍如何使用 CocoaPods，这里只讨论下使用 CocoaPods 的好处，以及一些使用经验（我会在后文列一些 CocoaPods 的资料）。</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;优点：</span><br><span class=\"line\">1、解决了方案一中，需要在项目里 **大量标记 -fno-objc-arc **的问题：</span><br><span class=\"line\">—— CocoaPods自动生成的关联库会在关联工程中自动标记好，原始项目中只管用就行</span><br><span class=\"line\">2、解决了方案二中，只有.h 头文件，**没有源码**、出错没法定位和修改的问题：</span><br><span class=\"line\">—— CocoaPods也是使用静态库依赖，但是保留全部.m文件</span><br><span class=\"line\">3、解决了方案二中，静态库使用时的一些坑，和**需要打包.a文件的麻烦操作**。</span><br><span class=\"line\">—— CocoaPods自动完成</span><br><span class=\"line\">4、极大的简化了**操作**：</span><br><span class=\"line\">  1&gt; cd进入.xcodeproj文件所在的目录</span><br><span class=\"line\">  ```$ pod init</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>  2&gt; 在自动生成的Podfile文件中，加入要pod的库名<br>  <figure class=\"highlight plain\"><figcaption><span>pod install```</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  3&gt; 搞定。</span><br><span class=\"line\">5、最重要的一点：以后再遇到这次的升级第三方库版本的需求时，只需一行命令即可：</span><br><span class=\"line\">  ```$ pod update</span><br></pre></td></tr></table></figure></p>\n<p>结论：<strong>就是这个了！</strong></p>\n<p>#确定方案</p>\n<blockquote>\n<p>CocoaPods 一劳永逸的解决了第三方库版本升级的问题。</p>\n</blockquote>\n<p>#就酱~</p>\n<p>#干货部分</p>\n<blockquote>\n<p>CocoaPods学习资料</p>\n</blockquote>\n<p>####CocoaPods入门：<br>1、<a href=\"http://code4app.com/article/cocoapods-install-usage\" target=\"_blank\" rel=\"noopener\">CocoaPods安装和使用教程</a><br>（入门看这一篇就够了）<br>2、CocoaPods pod install/pod update<strong>更新慢的问题</strong><br>  最近使用CocoaPods来添加第三方类库，无论是执行pod install还是pod update都卡在了Analyzing dependencies不动<br>  原因在于当执行以上两个命令的时候会升级CocoaPods的spec仓库，加一个参数可以省略这一步，然后速度就会提升不少。命令如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pod install --verbose --no-repo-update</span><br><span class=\"line\">pod update --verbose --no-repo-update</span><br></pre></td></tr></table></figure></p>\n<p>3、mac升级到10.11，<strong>cocoapods没了</strong><br>  使用命令行sudo gem install cocoa pods出错，换成sudo gem install -n /usr/local/bin cocoa pods即可，详见： <a href=\"http://t.cn/Ry8tZAs\" target=\"_blank\" rel=\"noopener\">http://t.cn/Ry8tZAs</a><br>4、<strong>使用经验：</strong><br>  1&gt; pods install 时，可以不加版本号（默认下载对应库的<strong>最新版本</strong>）<br><img src=\"http://upload-images.jianshu.io/upload_images/332029-9293ed3a288b838e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt><br>  但是，下载完依赖后，最好<strong>加上版本号</strong>，避免在添加了新的库，或者pod update时，由于某些第三方库频繁升级而带来的不稳定。<br><img src=\"http://upload-images.jianshu.io/upload_images/332029-22cd97e2d756cb04.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt><br>  2&gt; 多人合作的较大项目，Podfile文件可以设置权限，只由一个人来修改、添加依赖的库。<br>  3 &gt; SVN或者Git做版本管理时，不要上传 Pods 、workspace 目录：<br>（可以设置ignore）<br><img src=\"http://upload-images.jianshu.io/upload_images/332029-4e55d2d3a6b9d29f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt></p>\n<p>###CocoaPods高阶用法：</p>\n<p>1、<a href=\"http://nshipster.cn/cocoapods/#%E4%BD%BF%E7%94%A8cocoapods\" target=\"_blank\" rel=\"noopener\">即使你不使用第三方库，CocoaPods仍然是一个管理代码相关性的绝佳工具</a><br>2、<a href=\"https://github.com/Damonvvong/DWCategory\" target=\"_blank\" rel=\"noopener\">借助GitHub托管Category,利用CocoaPods集成到项目中</a><br>3、<a href=\"http://blog.wtlucky.com/blog/2015/02/26/create-private-podspec/\" target=\"_blank\" rel=\"noopener\">Cocoapods创建私有podspec</a><br>4、<a href=\"http://blog.csdn.net/becomedragonlong/article/details/45933345#0-tsina-1-22915-397232\" target=\"_blank\" rel=\"noopener\">写一个Pod发布到CocoaPods</a><br>5、<a href=\"http://supermao.cn/cocoapodsde-xie-lue-wei-gao-ji-ding-dian-de-shi-yong/\" target=\"_blank\" rel=\"noopener\">CocoaPods的一些略为高级一丁点的使用</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//TODO:1、利用多个 project 做本地依赖管理</span><br><span class=\"line\">       2、私有仓库的使用尝试</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>为什么iOS项目中应该使用CocoaPods作为第三方依赖管理工具？</strong></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/332029-76f5038a773b7863.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt></p>\n<blockquote>\n<p><strong>目录：</strong></p>\n<ul>\n<li>从一个bug说起</li>\n<li>分析需求及解决方案</li>\n<li>确定方案</li>\n<li>CocoaPods学习资料</li>\n</ul>\n</blockquote>\n<p>#一、从一个bug说起：<br>1、公司的项目里统一使用SVG格式的图片；<br>2、GitHub上只有一个star数超过一千的SVG解析库，叫SVGKit。（对，就是这个坑爹的库）<br>         <strong>坑1：</strong> 这个库一直使用非ARC，有100多个类；<br>         <strong>坑2：</strong> 这个库还依赖另外一个库CocoaLumberjack；<br>         <strong>坑3：</strong> 把这个库配置到项目中就会报一种错误：<br><img src=\"http://upload-images.jianshu.io/upload_images/332029-41102bc3ee4544b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt></p>\n<p>3、公司的项目是直接以源码的形式使用的该库。<br>        结果就是 <strong>Build Phase</strong> 中成了这样：<br>   （我不知道当初加这些 -fno-objc-arc 标记的人是否崩溃，我光看着就觉得淡淡的忧桑：这么多得加多久？加漏了或者多加了，都是坑。）<br><img src=\"http://upload-images.jianshu.io/upload_images/332029-e085b55b305df854.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt></p>\n<p>4、因为用的源码，项目里的SVGKit版本很久都不会更新。导致在iPhone6S以上设备时，由于旧版本的库没有适配6S，必崩。现在必须要更新到这个库的最新版本。</p>\n<p>#<strong>二、解决方案的探索：</strong></p>\n<p>##方案一：</p>\n<blockquote>\n<p><strong>用最新源码替换掉旧版源码文件</strong><br>  问题：1、类文件太多，麻烦，容易出错；<br>     2、还是会有大量的 -fno-objc-arc 标记，很烦；<br>       结论：<strong>否决</strong></p>\n</blockquote>\n<p>##方案二：</p>\n<blockquote>\n<p><strong>SVGKit作者推荐——静态库</strong>（该库的GitHub页面也只介绍了这一种用法）<br>  问题：1、只有.h 头文件，出错没法定位和修改。<br>     2、静态库里使用了category必须要加 -ObjC 标记。<br>     3、静态库.a文件需要区分device版本和simulator版本，或者合并后使用。<br>  结论：<strong>否决</strong></p>\n</blockquote>\n<p>关于<strong>问题2</strong>这里要解释下，本来是没什么问题的，但我不幸遇到了<strong>这个坑</strong>：<br>  1、静态库里如果使用了 <strong>category</strong>，需要加 <strong>-ObjC</strong> 标记。否则在使用的时会崩溃：<br><img src=\"http://upload-images.jianshu.io/upload_images/332029-83821f8d987a4e16.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt><br>  2、当时花了好久没解决这个问题的原因是，我记得自己设置了呀。<br>     后来才想起来为毛还是崩，这是我们的项目target，你们感受下：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/332029-a4084793b6c2f4ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt></p>\n<p>    有任何一个target忘了设置，就又埋了个坑。<br>  3、关于 <strong>为什么要加 -ObjC 标记</strong> 的问题，以前是有查过资料的，这里完全是因为target太多遗漏导致的。</p>\n<blockquote>\n<p>####笔记如下：  <br><strong>-ObjC 标记的作用:</strong></p>\n<ul>\n<li>用到一个第三方库，这个库的使用向导里面特别说明，在添加完该库后，需要在Xcode的Build Settings下Other Linker Flags里面加入-ObjC标志。之所以使用该标志，和Objective-C的一个重要特性：类别（category)有关。根据<a href=\"https://developer.apple.com/library/mac/qa/qa1490/_index.html\" target=\"_blank\" rel=\"noopener\">这里</a>的解释，Unix的标准静态库实现和Objective-C的动态特性之间有一些冲突：Objective-C没有为每个函数（或者方法）定义链接符号，它只为每个类创建链接符号。</li>\n<li>这样当在一个静态库中使用类别来扩展已有类的时候，链接器不知道如何把类原有的方法和类别中的方法整合起来，就会导致你调用类别中的方法时，出现”selector not recognized”，也就是找不到方法定义的错误。</li>\n<li>为了解决这个问题，引入了-ObjC标志，它的作用就是将静态库中所有的和对象相关的文件都加载进来。</li>\n<li>本来这样就可以解决问题了，不过在64位的Mac系统或者iOS系统下，链接器有一个bug，会导致只包含有类别的静态库无法使用-ObjC标志来加载文件。变通方法是使用-all_load 或者-force_load标志，它们的作用都是加载静态库中所有文件，不过all_load作用于所有的库，而-force_load后面必须要指定具体的文件。</li>\n</ul>\n</blockquote>\n<p>##方案三：</p>\n<blockquote>\n<p><strong>使用 CocoaPods </strong><br>问题：作者没有说明这个库<strong>是否支持CocoaPods</strong><br>   这也是我最开始没有考虑改用 CocoaPods 的原因）</p>\n</blockquote>\n<ul>\n<li>这里提示大家，可以使用以下命令，测试某个库是否支持CocoaPods<figure class=\"highlight plain\"><figcaption><span>pod try XXX```</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">     鉴于这里不是介绍如何使用 CocoaPods，这里只讨论下使用 CocoaPods 的好处，以及一些使用经验（我会在后文列一些 CocoaPods 的资料）。</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;优点：</span><br><span class=\"line\">1、解决了方案一中，需要在项目里 **大量标记 -fno-objc-arc **的问题：</span><br><span class=\"line\">—— CocoaPods自动生成的关联库会在关联工程中自动标记好，原始项目中只管用就行</span><br><span class=\"line\">2、解决了方案二中，只有.h 头文件，**没有源码**、出错没法定位和修改的问题：</span><br><span class=\"line\">—— CocoaPods也是使用静态库依赖，但是保留全部.m文件</span><br><span class=\"line\">3、解决了方案二中，静态库使用时的一些坑，和**需要打包.a文件的麻烦操作**。</span><br><span class=\"line\">—— CocoaPods自动完成</span><br><span class=\"line\">4、极大的简化了**操作**：</span><br><span class=\"line\">  1&gt; cd进入.xcodeproj文件所在的目录</span><br><span class=\"line\">  ```$ pod init</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>  2&gt; 在自动生成的Podfile文件中，加入要pod的库名<br>  <figure class=\"highlight plain\"><figcaption><span>pod install```</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  3&gt; 搞定。</span><br><span class=\"line\">5、最重要的一点：以后再遇到这次的升级第三方库版本的需求时，只需一行命令即可：</span><br><span class=\"line\">  ```$ pod update</span><br></pre></td></tr></table></figure></p>\n<p>结论：<strong>就是这个了！</strong></p>\n<p>#确定方案</p>\n<blockquote>\n<p>CocoaPods 一劳永逸的解决了第三方库版本升级的问题。</p>\n</blockquote>\n<p>#就酱~</p>\n<p>#干货部分</p>\n<blockquote>\n<p>CocoaPods学习资料</p>\n</blockquote>\n<p>####CocoaPods入门：<br>1、<a href=\"http://code4app.com/article/cocoapods-install-usage\" target=\"_blank\" rel=\"noopener\">CocoaPods安装和使用教程</a><br>（入门看这一篇就够了）<br>2、CocoaPods pod install/pod update<strong>更新慢的问题</strong><br>  最近使用CocoaPods来添加第三方类库，无论是执行pod install还是pod update都卡在了Analyzing dependencies不动<br>  原因在于当执行以上两个命令的时候会升级CocoaPods的spec仓库，加一个参数可以省略这一步，然后速度就会提升不少。命令如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pod install --verbose --no-repo-update</span><br><span class=\"line\">pod update --verbose --no-repo-update</span><br></pre></td></tr></table></figure></p>\n<p>3、mac升级到10.11，<strong>cocoapods没了</strong><br>  使用命令行sudo gem install cocoa pods出错，换成sudo gem install -n /usr/local/bin cocoa pods即可，详见： <a href=\"http://t.cn/Ry8tZAs\" target=\"_blank\" rel=\"noopener\">http://t.cn/Ry8tZAs</a><br>4、<strong>使用经验：</strong><br>  1&gt; pods install 时，可以不加版本号（默认下载对应库的<strong>最新版本</strong>）<br><img src=\"http://upload-images.jianshu.io/upload_images/332029-9293ed3a288b838e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt><br>  但是，下载完依赖后，最好<strong>加上版本号</strong>，避免在添加了新的库，或者pod update时，由于某些第三方库频繁升级而带来的不稳定。<br><img src=\"http://upload-images.jianshu.io/upload_images/332029-22cd97e2d756cb04.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt><br>  2&gt; 多人合作的较大项目，Podfile文件可以设置权限，只由一个人来修改、添加依赖的库。<br>  3 &gt; SVN或者Git做版本管理时，不要上传 Pods 、workspace 目录：<br>（可以设置ignore）<br><img src=\"http://upload-images.jianshu.io/upload_images/332029-4e55d2d3a6b9d29f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt></p>\n<p>###CocoaPods高阶用法：</p>\n<p>1、<a href=\"http://nshipster.cn/cocoapods/#%E4%BD%BF%E7%94%A8cocoapods\" target=\"_blank\" rel=\"noopener\">即使你不使用第三方库，CocoaPods仍然是一个管理代码相关性的绝佳工具</a><br>2、<a href=\"https://github.com/Damonvvong/DWCategory\" target=\"_blank\" rel=\"noopener\">借助GitHub托管Category,利用CocoaPods集成到项目中</a><br>3、<a href=\"http://blog.wtlucky.com/blog/2015/02/26/create-private-podspec/\" target=\"_blank\" rel=\"noopener\">Cocoapods创建私有podspec</a><br>4、<a href=\"http://blog.csdn.net/becomedragonlong/article/details/45933345#0-tsina-1-22915-397232\" target=\"_blank\" rel=\"noopener\">写一个Pod发布到CocoaPods</a><br>5、<a href=\"http://supermao.cn/cocoapodsde-xie-lue-wei-gao-ji-ding-dian-de-shi-yong/\" target=\"_blank\" rel=\"noopener\">CocoaPods的一些略为高级一丁点的使用</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//TODO:1、利用多个 project 做本地依赖管理</span><br><span class=\"line\">       2、私有仓库的使用尝试</span><br></pre></td></tr></table></figure>\n"},{"title":"iOS组件化方案调研","date":"2016-05-31T06:01:10.000Z","_content":"\n# iOS组件化方案探索\n\n## 一、什么是组件化？\n\n### 什么是组件？\n\n`\"组件\"`一般来说用于命名比较小的功能块，如：下拉刷新组件、提示框组件。而较大粒度的业务功能，我们习惯称之为`\"模块\"`，如：首页模块、我的模块、新闻模块。\n\n这次讨论的主题是组件化，这里为了方便表述，下面模块和组件代表同一个意思，都是指较大粒度的业务模块。\n\n### 什么是组件化？\n\n组件化，或者说模块化，用来分割、组织和打包软件。每个模块完成一个特定的子功能，所有的模块按某种方法组装起来，成为一个整体，完成整个系统所要求的功能。\n\n从工程代码层面来说，组件化的实施通常是通过`中间件`解决组件间头文件直接引用、依赖混乱的问题；从实际开发来说，组件之间最大的需求就是页面跳转，需要从组件A的pageA页面跳转到组件B的pageB页面，避免对组件B页面ViewController头文件的直接依赖。\n\n\n## 二、为什么要组件化？\n\n从两个方面论述：\n\n### 组件化是为了解决什么问题？\n\n一个 APP 有多个模块，模块之间会通信，互相调用，如我们的证券app，有首页、行情、资讯、我的等模块。这些模块会互相调用，例如 首页底部需要展示部分资讯、行情；行情底部需要展示个股资讯；资讯详情页需要跳转到行情，等等。\n\n一般我们是怎样调用呢，以首页调用资讯为例，会这样写：\n\n```\n#import \"HomeViewController.h\"\n#import \"NewsViewController.h\"\n\n@implementation HomeViewController\n\n+ (void)gotoNews {\n\n NewsViewController *detailVC = [[NewsViewController alloc] initWithStockCode:self.codeNum];\n [self.navigationController.pushViewController:detailVC animated:YES];\n}\n\n@end\n```\n\n看起来挺好，这样做简单明了，没有多余的东西，项目初期推荐这样快速开发，但到了项目越来越庞大，这种方式会有什么问题呢？\n\n- 问题1，每个模块都离不开其他模块，互相依赖粘在一起成为一坨：\n\n![各模块互相依赖.png](http://upload-images.jianshu.io/upload_images/332029-f03757f38936ed16.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n耦合比较严重（因为没有明确的约束，「组件」间引用的现象会比较多）\n- 问题2，多人同时开发时，容易出现冲突（尤其是Xcode Project文件）\n- 问题3，业务方的开发效率不够高（只关心自己的组件，却要编译整个项目，与其他不相干的代码糅合在一起）\n\n### 组件化的好处？\n\n**一般意义：**\n\n- 加快编译速度（不用编译主客那一大坨代码了）；\n- 各组件自由选择开发姿势（MVC / MVVM / FRP）；\n- 组件工程本身可以独立开发测试，方便 QA 有针对性地测试；\n- 规范组件之间的通信接，让各个组件对外都提供一个黑盒服务，减少沟通和维护成本，提高效率；\n\n**对于公司已有项目的现实意义：**\n\n- 业务分层、解耦，使代码变得可维护；\n- 有效的拆分、组织日益庞大的工程代码，使工程目录变得可维护；\n- 便于各业务功能拆分、抽离，实现真正的功能复用；\n- 业务隔离，跨团队开发代码控制和版本风险控制的实现；\n- 模块化对代码的封装性、合理性都有一定的要求，提升开发同学的设计能力；\n- 在维护好各级组件的情况下，随意组合满足不同客户需求；（只需要将之前的多个业务组件模块在新的主App中进行组装即可快速迭代出下一个全新App）\n\n\n### 什么情况下进行组件化比较合适？\n\n当然组件化也有它的缺点：\n\n- 学习成本高，对于开发人员对各种工具的掌握要求也比较高，对于新手来说入门较为困难。\n\n- 由于工具和流程的复杂化，导致团队之间协作的成本变高，某些情况下可能会导致开发效率下降。\n\n当项目App处于起步阶段、各个需求模块趋于成熟稳定的过程中，组件化也许并没有那么迫切，甚至考虑组件化的架构可能会影响开发效率和需求迭代。\n\n而当项目迭代到一定时期之后，便会出现一些相对独立的业务功能模块，而团队的规模也会随着项目迭代逐渐增长，这便是中小型应用考虑组件化的时机了。这时为了更好的分工协作，团队安排团队成员各自维护一个相对独立的业务组件是比较常见的做法。\n\n在这时这个时候来引入组件化方案，是比较合适的时机。长远来看，组件化带来的好处是远远大于坏处的，特别是随着项目的规模增大，这种好处会变得越来越明显\n\n\n## 三、如何组件化？\n\n> 组件化的开展需要解决以下几个层次的问题：\n\n### 组件化的架构目标？\n\n借用Limboy的图：\n\n![组件化架构.png](http://upload-images.jianshu.io/upload_images/332029-4c7b8e152db83b9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 如何划分组件？\n\n- 基础功能组件\n- 基础产品组件\n- 个性化业务组件\n\n对于一个没有实施过组件化拆分的工程来说，其中很可能充满了大量不合理的类、方法、头文件和各种错乱的依赖关系，因此首先要进行的第一步是模块拆分。\n\n模块拆分可以分成两个部分，基础模块拆分和业务模块拆分。基础模块通常是稳定的依赖代码，业务模块是涉及到业务的需要频繁改动的代码。\n\n> 基础模块拆分\n\n基础模块是任何一个App都需要用到的，如：性能统计、Networking、Patch、网络诊断、数据存储模块。对于基础模块来说，其本身应该是自洽的，即可以单独编译或者几个模块合在一起可以单独编译。所有的依赖关系都应该是业务模块指向基础模块的。\n基础模块之间尽量避免产生横向依赖。\n\n> 业务模块拆分\n\n对于业务模块来说，考虑到旧有代码可能没有相关的横向解耦策略，业务模块之间的依赖会非常复杂，难以单独进行拆分，因此我们采用的方法是首先从 group 角度进行重新整理。\n\n对业务量很大的工程来说，我个人更加推荐“业务-分层”这样的结构，而不是“分层-业务”，即类似下面的 group 结构：\n\n```\n- BusinessA\n  - Model\n  - View\n  - Controller\n  - Store\n- BusinessB\n  - Model\n  - View\n  - Controller\n  -Store\n```\n\n而非目前项目中采用的：\n\n```\n- Controllers\n  - BusinessA_Controller\n  - BusinessB_Controller\n- Views\n  - BusinessA_View\n  - BusinessB_View\n- Models\n  - BusinessA_Model\n  - BusinessB_Model\n```\n\n### 组件化的技术难点？\n\n> 组件化的实施，直观上看，只是需要将各业务组件的代码放到各自的文件夹或者 jar包里就行了。\n\n这里引出的是：\n\n#### 1、组件的拆分方式问题：\n\n可以利用CocoaPods 配合 git 做代码版本管理，独立业务模块单独成库。\n\n但这仅仅是物理上拆分了，拆分后的代码编译是肯定通不过的，因为如下：\n\n```\n\n#import \"MainViewController.h\"\n#import \"HomeViewController.h\"\n#import \"NewsViewController.h\"\n#import \"MeViewController.h\"\n#import ...\n\n@implementation MainViewController\n\n@end\n\n```\n\n`MainViewController` 会找不到依赖的其它各个模块的头文件而报错。这里引出的又是另一个问题：\n\n#### 2、组件间如何解耦？\n\n组件间解耦，是组件化必须解决的一个问题。换句话说，就是如何解除业务模块间的横向依赖。还是拿上边举得例子来说：\n\nApp的根视图`MainViewController`需要管理首页、新闻、我的等等页面时，如何做到 ``MainViewController`` 中，不用去 ``import``这一大堆 `XXViewController` ?\n\n很简单，按软件工程的思路，下意识就会加一个中间层Mediator：\n\n![中间层.png](http://upload-images.jianshu.io/upload_images/332029-bd66e6dac09f2e08.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n这样一来，各个模块直接都不需要再互相依赖，而是仅需要依赖 Mediator 层即可。\n\n可直观上看，这样做并没有什么好处，依赖关系并没有解除，Mediator 依赖了所有模块，而调用者又依赖 Mediator，最后还是一坨互相依赖，跟原来没有 Mediator 的方案相比除了更麻烦点其他没区别。\n\n我们希望最终能过实现的是单向的依赖，即：\n\n![单向依赖.png](http://upload-images.jianshu.io/upload_images/332029-4bbac402d8344090.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n对此，可以参考业内的流行方案：\n\n- 基于 URL Router、ModuleManager\n    代表：[蘑菇街 Limboy](http://limboy.me/ios/2016/03/10/mgj-components.html)\n\n- 基于 Target-Action、Runtime、Category\n    代表：[安居客 casa](http://casatwy.com/iOS-Modulization.html?hmsr=toutiao.io&utm_medium=toutiao.io&utm_source=toutiao.io)\n\n具体实现方案较为抽象，这里暂时先不详细展开论述，可以参见Demo：\n\n[Demo1 基于 Target-Action](https://github.com/yehot/CTMediator)\n\n[Demo2 基于 URL Router](https://github.com/yehot/routable-ios)\n\n\n## 四、其它\n\n### 开发流程控制\n\n> 托管平台选择\n\n自己利用开源的方案搭建私有的托管平台，可以最大限制地保证代码的安全。开源方案当中最知名也是最为广泛使用的当属 Gitlab。\n\n组件化使我们从单一的主工程，变成了主工程+多个拆分好的基础模块+统一的私有 Spec 仓库。为了避免某个人的工作对其他人开发环境造成影响，需要对整个组的开发流程进行统一的规范。\n\n不管是对于主仓库和子模块仓库，git-flow 都是首先推荐的工作流程。一个仓库的 master 分支只有所有者可以有权限更改，其他的贡献者想更改的话，需要自己创建新的分支（在 Github 上就是进行 fork），然后进行更改，之后把更改向原仓库发送 Pull Request。Pull Request 就是一个合并的请求，其中可以看到贡献者的更改，项目主人和其他维护者可以对 Pull Request 进行审核，共同探讨修改意见。当项目主人认为修改 OK 之后，就可以合并这个 Pull Request ，把这部分代码合并到主分支。\n\n这个流程是完全分布式的，也就是说可以同时有多个贡献者在不同的分支进行工作，最后统一合并到主分支上，实现并行协作。\n\n同时在审核 Pull Request 阶段，除了人工审核代码之外，Github 还加入了对于持续集成的支持，可以检测这个 Pull Request 是不是能够通过测试的，进一步保证了代码的质量。\n\n\n### 组件维护问题？\n\n待补充\n\n\n\n\n\n## 五、参考资料：\n\n### 相关技术博客：\n\n1、[iOS应用架构谈 组件化方案](http://casatwy.com/iOS-Modulization.html?hmsr=toutiao.io&utm_medium=toutiao.io&utm_source=toutiao.io)\n\n2、[蘑菇街 App 的组件化之路](http://limboy.me/ios/2016/03/10/mgj-components.html)\n\n[蘑菇街 App 的组件化之路·续](http://limboy.me/ios/2016/03/14/mgj-components-continued.html)\n\n3、[iOS 组件化方案探索](http://blog.cnbang.net/tech/3080/)\n\n4、[《iOS应用架构谈 组件化方案》和《蘑菇街 App 的组件化之路》的阅读指导](http://www.reviewcode.cn/article.html?reviewId=20)\n\n5、[浅析 iOS 应用组件化设计](https://skyline75489.github.io/post/2016-3-16_ios_module_design.html)\n\n6、[糯米移动组件架构演进之路](http://chuansong.me/n/320688951236)\n\n7、[饿了么移动APP的架构演进](https://www.sdk.cn/news/2023)\n\n8、[滴滴出行iOS客户端架构演进之路](https://mp.weixin.qq.com/s?__biz=MzA3ODg4MDk0Ng%3D%3D&idx=1&mid=402854111&sn=5876e615fabd6d921285d904e16670fb)\n\n9、[ios业务模块间互相跳转的解耦方案](http://www.aliog.com/101363.html)\n\n10、[iOS组件化思路－大神博客研读和思考](http://cdn0.jianshu.io/p/afb9b52143d4)\n\n11、[模块化与解耦](https://blog.cnbluebox.com/blog/2015/11/28/module-and-decoupling/)\n\n### 相关解决方案\n\n1、[casatwy/CTMediator](https://github.com/casatwy/CTMediator)\n\n2、[mogujie/MGJRouter](https://github.com/mogujie/MGJRouter)\n\n3、[joeldev/JLRoutes](https://github.com/joeldev/JLRoutes)\n\n4、[Huohua/HHRouter](https://github.com/Huohua/HHRouter)\n\n5、[clayallsopp/routable-ios](https://github.com/clayallsopp/routable-ios)\n\n6、[Lede-Inc/LDBusBundle_IOS](https://github.com/Lede-Inc/LDBusBundle_IOS)\n\n### 私有Cocoapods实施方案\n\n1、[使用Cocoapods创建私有podspec - GeekerProbe](http://blog.wtlucky.com/blog/2015/02/26/create-private-podspec/)\n\n2、[Cocoapods系列教程(三)——私有库管理和模块化管理](http://www.pluto-y.com/cocoapod-private-pods-and-module-manager/)\n\n3、[iOS组件化实践方案－LDBusMediator炼就](http://www.jianshu.com/p/196f66d31543)\n\n4、[基于 CocoaPods 和 Git 的 iOS 工程组件化实践](https://skyline75489.github.io/post/2016-3-19_ios_modularization_practice.html)\n\n5、[Cocoapods代码管理](https://blog.cnbluebox.com/blog/2014/03/31/cocoapodsdai-ma-guan-li/)\n\n6、[CocoaPods创建私有Pods](http://www.liuchungui.com/blog/2015/10/19/cocoapodschuang-jian-si-you-pods/)\n\n7、[如何创建私有 CocoaPods 仓库](http://www.jianshu.com/p/ddc2490bff9f)\n","source":"_posts/20160531-ios-module-investigation.md","raw":"---\ntitle: iOS组件化方案调研\ndate: 2016-05-31 14:01:10\ntags: CocoaPods\ncategories: iOS组件化\n---\n\n# iOS组件化方案探索\n\n## 一、什么是组件化？\n\n### 什么是组件？\n\n`\"组件\"`一般来说用于命名比较小的功能块，如：下拉刷新组件、提示框组件。而较大粒度的业务功能，我们习惯称之为`\"模块\"`，如：首页模块、我的模块、新闻模块。\n\n这次讨论的主题是组件化，这里为了方便表述，下面模块和组件代表同一个意思，都是指较大粒度的业务模块。\n\n### 什么是组件化？\n\n组件化，或者说模块化，用来分割、组织和打包软件。每个模块完成一个特定的子功能，所有的模块按某种方法组装起来，成为一个整体，完成整个系统所要求的功能。\n\n从工程代码层面来说，组件化的实施通常是通过`中间件`解决组件间头文件直接引用、依赖混乱的问题；从实际开发来说，组件之间最大的需求就是页面跳转，需要从组件A的pageA页面跳转到组件B的pageB页面，避免对组件B页面ViewController头文件的直接依赖。\n\n\n## 二、为什么要组件化？\n\n从两个方面论述：\n\n### 组件化是为了解决什么问题？\n\n一个 APP 有多个模块，模块之间会通信，互相调用，如我们的证券app，有首页、行情、资讯、我的等模块。这些模块会互相调用，例如 首页底部需要展示部分资讯、行情；行情底部需要展示个股资讯；资讯详情页需要跳转到行情，等等。\n\n一般我们是怎样调用呢，以首页调用资讯为例，会这样写：\n\n```\n#import \"HomeViewController.h\"\n#import \"NewsViewController.h\"\n\n@implementation HomeViewController\n\n+ (void)gotoNews {\n\n NewsViewController *detailVC = [[NewsViewController alloc] initWithStockCode:self.codeNum];\n [self.navigationController.pushViewController:detailVC animated:YES];\n}\n\n@end\n```\n\n看起来挺好，这样做简单明了，没有多余的东西，项目初期推荐这样快速开发，但到了项目越来越庞大，这种方式会有什么问题呢？\n\n- 问题1，每个模块都离不开其他模块，互相依赖粘在一起成为一坨：\n\n![各模块互相依赖.png](http://upload-images.jianshu.io/upload_images/332029-f03757f38936ed16.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n耦合比较严重（因为没有明确的约束，「组件」间引用的现象会比较多）\n- 问题2，多人同时开发时，容易出现冲突（尤其是Xcode Project文件）\n- 问题3，业务方的开发效率不够高（只关心自己的组件，却要编译整个项目，与其他不相干的代码糅合在一起）\n\n### 组件化的好处？\n\n**一般意义：**\n\n- 加快编译速度（不用编译主客那一大坨代码了）；\n- 各组件自由选择开发姿势（MVC / MVVM / FRP）；\n- 组件工程本身可以独立开发测试，方便 QA 有针对性地测试；\n- 规范组件之间的通信接，让各个组件对外都提供一个黑盒服务，减少沟通和维护成本，提高效率；\n\n**对于公司已有项目的现实意义：**\n\n- 业务分层、解耦，使代码变得可维护；\n- 有效的拆分、组织日益庞大的工程代码，使工程目录变得可维护；\n- 便于各业务功能拆分、抽离，实现真正的功能复用；\n- 业务隔离，跨团队开发代码控制和版本风险控制的实现；\n- 模块化对代码的封装性、合理性都有一定的要求，提升开发同学的设计能力；\n- 在维护好各级组件的情况下，随意组合满足不同客户需求；（只需要将之前的多个业务组件模块在新的主App中进行组装即可快速迭代出下一个全新App）\n\n\n### 什么情况下进行组件化比较合适？\n\n当然组件化也有它的缺点：\n\n- 学习成本高，对于开发人员对各种工具的掌握要求也比较高，对于新手来说入门较为困难。\n\n- 由于工具和流程的复杂化，导致团队之间协作的成本变高，某些情况下可能会导致开发效率下降。\n\n当项目App处于起步阶段、各个需求模块趋于成熟稳定的过程中，组件化也许并没有那么迫切，甚至考虑组件化的架构可能会影响开发效率和需求迭代。\n\n而当项目迭代到一定时期之后，便会出现一些相对独立的业务功能模块，而团队的规模也会随着项目迭代逐渐增长，这便是中小型应用考虑组件化的时机了。这时为了更好的分工协作，团队安排团队成员各自维护一个相对独立的业务组件是比较常见的做法。\n\n在这时这个时候来引入组件化方案，是比较合适的时机。长远来看，组件化带来的好处是远远大于坏处的，特别是随着项目的规模增大，这种好处会变得越来越明显\n\n\n## 三、如何组件化？\n\n> 组件化的开展需要解决以下几个层次的问题：\n\n### 组件化的架构目标？\n\n借用Limboy的图：\n\n![组件化架构.png](http://upload-images.jianshu.io/upload_images/332029-4c7b8e152db83b9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 如何划分组件？\n\n- 基础功能组件\n- 基础产品组件\n- 个性化业务组件\n\n对于一个没有实施过组件化拆分的工程来说，其中很可能充满了大量不合理的类、方法、头文件和各种错乱的依赖关系，因此首先要进行的第一步是模块拆分。\n\n模块拆分可以分成两个部分，基础模块拆分和业务模块拆分。基础模块通常是稳定的依赖代码，业务模块是涉及到业务的需要频繁改动的代码。\n\n> 基础模块拆分\n\n基础模块是任何一个App都需要用到的，如：性能统计、Networking、Patch、网络诊断、数据存储模块。对于基础模块来说，其本身应该是自洽的，即可以单独编译或者几个模块合在一起可以单独编译。所有的依赖关系都应该是业务模块指向基础模块的。\n基础模块之间尽量避免产生横向依赖。\n\n> 业务模块拆分\n\n对于业务模块来说，考虑到旧有代码可能没有相关的横向解耦策略，业务模块之间的依赖会非常复杂，难以单独进行拆分，因此我们采用的方法是首先从 group 角度进行重新整理。\n\n对业务量很大的工程来说，我个人更加推荐“业务-分层”这样的结构，而不是“分层-业务”，即类似下面的 group 结构：\n\n```\n- BusinessA\n  - Model\n  - View\n  - Controller\n  - Store\n- BusinessB\n  - Model\n  - View\n  - Controller\n  -Store\n```\n\n而非目前项目中采用的：\n\n```\n- Controllers\n  - BusinessA_Controller\n  - BusinessB_Controller\n- Views\n  - BusinessA_View\n  - BusinessB_View\n- Models\n  - BusinessA_Model\n  - BusinessB_Model\n```\n\n### 组件化的技术难点？\n\n> 组件化的实施，直观上看，只是需要将各业务组件的代码放到各自的文件夹或者 jar包里就行了。\n\n这里引出的是：\n\n#### 1、组件的拆分方式问题：\n\n可以利用CocoaPods 配合 git 做代码版本管理，独立业务模块单独成库。\n\n但这仅仅是物理上拆分了，拆分后的代码编译是肯定通不过的，因为如下：\n\n```\n\n#import \"MainViewController.h\"\n#import \"HomeViewController.h\"\n#import \"NewsViewController.h\"\n#import \"MeViewController.h\"\n#import ...\n\n@implementation MainViewController\n\n@end\n\n```\n\n`MainViewController` 会找不到依赖的其它各个模块的头文件而报错。这里引出的又是另一个问题：\n\n#### 2、组件间如何解耦？\n\n组件间解耦，是组件化必须解决的一个问题。换句话说，就是如何解除业务模块间的横向依赖。还是拿上边举得例子来说：\n\nApp的根视图`MainViewController`需要管理首页、新闻、我的等等页面时，如何做到 ``MainViewController`` 中，不用去 ``import``这一大堆 `XXViewController` ?\n\n很简单，按软件工程的思路，下意识就会加一个中间层Mediator：\n\n![中间层.png](http://upload-images.jianshu.io/upload_images/332029-bd66e6dac09f2e08.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n这样一来，各个模块直接都不需要再互相依赖，而是仅需要依赖 Mediator 层即可。\n\n可直观上看，这样做并没有什么好处，依赖关系并没有解除，Mediator 依赖了所有模块，而调用者又依赖 Mediator，最后还是一坨互相依赖，跟原来没有 Mediator 的方案相比除了更麻烦点其他没区别。\n\n我们希望最终能过实现的是单向的依赖，即：\n\n![单向依赖.png](http://upload-images.jianshu.io/upload_images/332029-4bbac402d8344090.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n对此，可以参考业内的流行方案：\n\n- 基于 URL Router、ModuleManager\n    代表：[蘑菇街 Limboy](http://limboy.me/ios/2016/03/10/mgj-components.html)\n\n- 基于 Target-Action、Runtime、Category\n    代表：[安居客 casa](http://casatwy.com/iOS-Modulization.html?hmsr=toutiao.io&utm_medium=toutiao.io&utm_source=toutiao.io)\n\n具体实现方案较为抽象，这里暂时先不详细展开论述，可以参见Demo：\n\n[Demo1 基于 Target-Action](https://github.com/yehot/CTMediator)\n\n[Demo2 基于 URL Router](https://github.com/yehot/routable-ios)\n\n\n## 四、其它\n\n### 开发流程控制\n\n> 托管平台选择\n\n自己利用开源的方案搭建私有的托管平台，可以最大限制地保证代码的安全。开源方案当中最知名也是最为广泛使用的当属 Gitlab。\n\n组件化使我们从单一的主工程，变成了主工程+多个拆分好的基础模块+统一的私有 Spec 仓库。为了避免某个人的工作对其他人开发环境造成影响，需要对整个组的开发流程进行统一的规范。\n\n不管是对于主仓库和子模块仓库，git-flow 都是首先推荐的工作流程。一个仓库的 master 分支只有所有者可以有权限更改，其他的贡献者想更改的话，需要自己创建新的分支（在 Github 上就是进行 fork），然后进行更改，之后把更改向原仓库发送 Pull Request。Pull Request 就是一个合并的请求，其中可以看到贡献者的更改，项目主人和其他维护者可以对 Pull Request 进行审核，共同探讨修改意见。当项目主人认为修改 OK 之后，就可以合并这个 Pull Request ，把这部分代码合并到主分支。\n\n这个流程是完全分布式的，也就是说可以同时有多个贡献者在不同的分支进行工作，最后统一合并到主分支上，实现并行协作。\n\n同时在审核 Pull Request 阶段，除了人工审核代码之外，Github 还加入了对于持续集成的支持，可以检测这个 Pull Request 是不是能够通过测试的，进一步保证了代码的质量。\n\n\n### 组件维护问题？\n\n待补充\n\n\n\n\n\n## 五、参考资料：\n\n### 相关技术博客：\n\n1、[iOS应用架构谈 组件化方案](http://casatwy.com/iOS-Modulization.html?hmsr=toutiao.io&utm_medium=toutiao.io&utm_source=toutiao.io)\n\n2、[蘑菇街 App 的组件化之路](http://limboy.me/ios/2016/03/10/mgj-components.html)\n\n[蘑菇街 App 的组件化之路·续](http://limboy.me/ios/2016/03/14/mgj-components-continued.html)\n\n3、[iOS 组件化方案探索](http://blog.cnbang.net/tech/3080/)\n\n4、[《iOS应用架构谈 组件化方案》和《蘑菇街 App 的组件化之路》的阅读指导](http://www.reviewcode.cn/article.html?reviewId=20)\n\n5、[浅析 iOS 应用组件化设计](https://skyline75489.github.io/post/2016-3-16_ios_module_design.html)\n\n6、[糯米移动组件架构演进之路](http://chuansong.me/n/320688951236)\n\n7、[饿了么移动APP的架构演进](https://www.sdk.cn/news/2023)\n\n8、[滴滴出行iOS客户端架构演进之路](https://mp.weixin.qq.com/s?__biz=MzA3ODg4MDk0Ng%3D%3D&idx=1&mid=402854111&sn=5876e615fabd6d921285d904e16670fb)\n\n9、[ios业务模块间互相跳转的解耦方案](http://www.aliog.com/101363.html)\n\n10、[iOS组件化思路－大神博客研读和思考](http://cdn0.jianshu.io/p/afb9b52143d4)\n\n11、[模块化与解耦](https://blog.cnbluebox.com/blog/2015/11/28/module-and-decoupling/)\n\n### 相关解决方案\n\n1、[casatwy/CTMediator](https://github.com/casatwy/CTMediator)\n\n2、[mogujie/MGJRouter](https://github.com/mogujie/MGJRouter)\n\n3、[joeldev/JLRoutes](https://github.com/joeldev/JLRoutes)\n\n4、[Huohua/HHRouter](https://github.com/Huohua/HHRouter)\n\n5、[clayallsopp/routable-ios](https://github.com/clayallsopp/routable-ios)\n\n6、[Lede-Inc/LDBusBundle_IOS](https://github.com/Lede-Inc/LDBusBundle_IOS)\n\n### 私有Cocoapods实施方案\n\n1、[使用Cocoapods创建私有podspec - GeekerProbe](http://blog.wtlucky.com/blog/2015/02/26/create-private-podspec/)\n\n2、[Cocoapods系列教程(三)——私有库管理和模块化管理](http://www.pluto-y.com/cocoapod-private-pods-and-module-manager/)\n\n3、[iOS组件化实践方案－LDBusMediator炼就](http://www.jianshu.com/p/196f66d31543)\n\n4、[基于 CocoaPods 和 Git 的 iOS 工程组件化实践](https://skyline75489.github.io/post/2016-3-19_ios_modularization_practice.html)\n\n5、[Cocoapods代码管理](https://blog.cnbluebox.com/blog/2014/03/31/cocoapodsdai-ma-guan-li/)\n\n6、[CocoaPods创建私有Pods](http://www.liuchungui.com/blog/2015/10/19/cocoapodschuang-jian-si-you-pods/)\n\n7、[如何创建私有 CocoaPods 仓库](http://www.jianshu.com/p/ddc2490bff9f)\n","slug":"20160531-ios-module-investigation","published":1,"updated":"2019-04-18T11:06:48.747Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjumvmxaa000xraxe2u546xf7","content":"<h1 id=\"iOS组件化方案探索\"><a href=\"#iOS组件化方案探索\" class=\"headerlink\" title=\"iOS组件化方案探索\"></a>iOS组件化方案探索</h1><h2 id=\"一、什么是组件化？\"><a href=\"#一、什么是组件化？\" class=\"headerlink\" title=\"一、什么是组件化？\"></a>一、什么是组件化？</h2><h3 id=\"什么是组件？\"><a href=\"#什么是组件？\" class=\"headerlink\" title=\"什么是组件？\"></a>什么是组件？</h3><p><code>&quot;组件&quot;</code>一般来说用于命名比较小的功能块，如：下拉刷新组件、提示框组件。而较大粒度的业务功能，我们习惯称之为<code>&quot;模块&quot;</code>，如：首页模块、我的模块、新闻模块。</p>\n<p>这次讨论的主题是组件化，这里为了方便表述，下面模块和组件代表同一个意思，都是指较大粒度的业务模块。</p>\n<h3 id=\"什么是组件化？\"><a href=\"#什么是组件化？\" class=\"headerlink\" title=\"什么是组件化？\"></a>什么是组件化？</h3><p>组件化，或者说模块化，用来分割、组织和打包软件。每个模块完成一个特定的子功能，所有的模块按某种方法组装起来，成为一个整体，完成整个系统所要求的功能。</p>\n<p>从工程代码层面来说，组件化的实施通常是通过<code>中间件</code>解决组件间头文件直接引用、依赖混乱的问题；从实际开发来说，组件之间最大的需求就是页面跳转，需要从组件A的pageA页面跳转到组件B的pageB页面，避免对组件B页面ViewController头文件的直接依赖。</p>\n<h2 id=\"二、为什么要组件化？\"><a href=\"#二、为什么要组件化？\" class=\"headerlink\" title=\"二、为什么要组件化？\"></a>二、为什么要组件化？</h2><p>从两个方面论述：</p>\n<h3 id=\"组件化是为了解决什么问题？\"><a href=\"#组件化是为了解决什么问题？\" class=\"headerlink\" title=\"组件化是为了解决什么问题？\"></a>组件化是为了解决什么问题？</h3><p>一个 APP 有多个模块，模块之间会通信，互相调用，如我们的证券app，有首页、行情、资讯、我的等模块。这些模块会互相调用，例如 首页底部需要展示部分资讯、行情；行情底部需要展示个股资讯；资讯详情页需要跳转到行情，等等。</p>\n<p>一般我们是怎样调用呢，以首页调用资讯为例，会这样写：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;HomeViewController.h&quot;</span><br><span class=\"line\">#import &quot;NewsViewController.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation HomeViewController</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)gotoNews &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"> NewsViewController *detailVC = [[NewsViewController alloc] initWithStockCode:self.codeNum];</span><br><span class=\"line\"> [self.navigationController.pushViewController:detailVC animated:YES];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<p>看起来挺好，这样做简单明了，没有多余的东西，项目初期推荐这样快速开发，但到了项目越来越庞大，这种方式会有什么问题呢？</p>\n<ul>\n<li>问题1，每个模块都离不开其他模块，互相依赖粘在一起成为一坨：</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/332029-f03757f38936ed16.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"各模块互相依赖.png\"></p>\n<p>耦合比较严重（因为没有明确的约束，「组件」间引用的现象会比较多）</p>\n<ul>\n<li>问题2，多人同时开发时，容易出现冲突（尤其是Xcode Project文件）</li>\n<li>问题3，业务方的开发效率不够高（只关心自己的组件，却要编译整个项目，与其他不相干的代码糅合在一起）</li>\n</ul>\n<h3 id=\"组件化的好处？\"><a href=\"#组件化的好处？\" class=\"headerlink\" title=\"组件化的好处？\"></a>组件化的好处？</h3><p><strong>一般意义：</strong></p>\n<ul>\n<li>加快编译速度（不用编译主客那一大坨代码了）；</li>\n<li>各组件自由选择开发姿势（MVC / MVVM / FRP）；</li>\n<li>组件工程本身可以独立开发测试，方便 QA 有针对性地测试；</li>\n<li>规范组件之间的通信接，让各个组件对外都提供一个黑盒服务，减少沟通和维护成本，提高效率；</li>\n</ul>\n<p><strong>对于公司已有项目的现实意义：</strong></p>\n<ul>\n<li>业务分层、解耦，使代码变得可维护；</li>\n<li>有效的拆分、组织日益庞大的工程代码，使工程目录变得可维护；</li>\n<li>便于各业务功能拆分、抽离，实现真正的功能复用；</li>\n<li>业务隔离，跨团队开发代码控制和版本风险控制的实现；</li>\n<li>模块化对代码的封装性、合理性都有一定的要求，提升开发同学的设计能力；</li>\n<li>在维护好各级组件的情况下，随意组合满足不同客户需求；（只需要将之前的多个业务组件模块在新的主App中进行组装即可快速迭代出下一个全新App）</li>\n</ul>\n<h3 id=\"什么情况下进行组件化比较合适？\"><a href=\"#什么情况下进行组件化比较合适？\" class=\"headerlink\" title=\"什么情况下进行组件化比较合适？\"></a>什么情况下进行组件化比较合适？</h3><p>当然组件化也有它的缺点：</p>\n<ul>\n<li><p>学习成本高，对于开发人员对各种工具的掌握要求也比较高，对于新手来说入门较为困难。</p>\n</li>\n<li><p>由于工具和流程的复杂化，导致团队之间协作的成本变高，某些情况下可能会导致开发效率下降。</p>\n</li>\n</ul>\n<p>当项目App处于起步阶段、各个需求模块趋于成熟稳定的过程中，组件化也许并没有那么迫切，甚至考虑组件化的架构可能会影响开发效率和需求迭代。</p>\n<p>而当项目迭代到一定时期之后，便会出现一些相对独立的业务功能模块，而团队的规模也会随着项目迭代逐渐增长，这便是中小型应用考虑组件化的时机了。这时为了更好的分工协作，团队安排团队成员各自维护一个相对独立的业务组件是比较常见的做法。</p>\n<p>在这时这个时候来引入组件化方案，是比较合适的时机。长远来看，组件化带来的好处是远远大于坏处的，特别是随着项目的规模增大，这种好处会变得越来越明显</p>\n<h2 id=\"三、如何组件化？\"><a href=\"#三、如何组件化？\" class=\"headerlink\" title=\"三、如何组件化？\"></a>三、如何组件化？</h2><blockquote>\n<p>组件化的开展需要解决以下几个层次的问题：</p>\n</blockquote>\n<h3 id=\"组件化的架构目标？\"><a href=\"#组件化的架构目标？\" class=\"headerlink\" title=\"组件化的架构目标？\"></a>组件化的架构目标？</h3><p>借用Limboy的图：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/332029-4c7b8e152db83b9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"组件化架构.png\"></p>\n<h3 id=\"如何划分组件？\"><a href=\"#如何划分组件？\" class=\"headerlink\" title=\"如何划分组件？\"></a>如何划分组件？</h3><ul>\n<li>基础功能组件</li>\n<li>基础产品组件</li>\n<li>个性化业务组件</li>\n</ul>\n<p>对于一个没有实施过组件化拆分的工程来说，其中很可能充满了大量不合理的类、方法、头文件和各种错乱的依赖关系，因此首先要进行的第一步是模块拆分。</p>\n<p>模块拆分可以分成两个部分，基础模块拆分和业务模块拆分。基础模块通常是稳定的依赖代码，业务模块是涉及到业务的需要频繁改动的代码。</p>\n<blockquote>\n<p>基础模块拆分</p>\n</blockquote>\n<p>基础模块是任何一个App都需要用到的，如：性能统计、Networking、Patch、网络诊断、数据存储模块。对于基础模块来说，其本身应该是自洽的，即可以单独编译或者几个模块合在一起可以单独编译。所有的依赖关系都应该是业务模块指向基础模块的。<br>基础模块之间尽量避免产生横向依赖。</p>\n<blockquote>\n<p>业务模块拆分</p>\n</blockquote>\n<p>对于业务模块来说，考虑到旧有代码可能没有相关的横向解耦策略，业务模块之间的依赖会非常复杂，难以单独进行拆分，因此我们采用的方法是首先从 group 角度进行重新整理。</p>\n<p>对业务量很大的工程来说，我个人更加推荐“业务-分层”这样的结构，而不是“分层-业务”，即类似下面的 group 结构：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- BusinessA</span><br><span class=\"line\">  - Model</span><br><span class=\"line\">  - View</span><br><span class=\"line\">  - Controller</span><br><span class=\"line\">  - Store</span><br><span class=\"line\">- BusinessB</span><br><span class=\"line\">  - Model</span><br><span class=\"line\">  - View</span><br><span class=\"line\">  - Controller</span><br><span class=\"line\">  -Store</span><br></pre></td></tr></table></figure>\n<p>而非目前项目中采用的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- Controllers</span><br><span class=\"line\">  - BusinessA_Controller</span><br><span class=\"line\">  - BusinessB_Controller</span><br><span class=\"line\">- Views</span><br><span class=\"line\">  - BusinessA_View</span><br><span class=\"line\">  - BusinessB_View</span><br><span class=\"line\">- Models</span><br><span class=\"line\">  - BusinessA_Model</span><br><span class=\"line\">  - BusinessB_Model</span><br></pre></td></tr></table></figure>\n<h3 id=\"组件化的技术难点？\"><a href=\"#组件化的技术难点？\" class=\"headerlink\" title=\"组件化的技术难点？\"></a>组件化的技术难点？</h3><blockquote>\n<p>组件化的实施，直观上看，只是需要将各业务组件的代码放到各自的文件夹或者 jar包里就行了。</p>\n</blockquote>\n<p>这里引出的是：</p>\n<h4 id=\"1、组件的拆分方式问题：\"><a href=\"#1、组件的拆分方式问题：\" class=\"headerlink\" title=\"1、组件的拆分方式问题：\"></a>1、组件的拆分方式问题：</h4><p>可以利用CocoaPods 配合 git 做代码版本管理，独立业务模块单独成库。</p>\n<p>但这仅仅是物理上拆分了，拆分后的代码编译是肯定通不过的，因为如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">#import &quot;MainViewController.h&quot;</span><br><span class=\"line\">#import &quot;HomeViewController.h&quot;</span><br><span class=\"line\">#import &quot;NewsViewController.h&quot;</span><br><span class=\"line\">#import &quot;MeViewController.h&quot;</span><br><span class=\"line\">#import ...</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation MainViewController</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<p><code>MainViewController</code> 会找不到依赖的其它各个模块的头文件而报错。这里引出的又是另一个问题：</p>\n<h4 id=\"2、组件间如何解耦？\"><a href=\"#2、组件间如何解耦？\" class=\"headerlink\" title=\"2、组件间如何解耦？\"></a>2、组件间如何解耦？</h4><p>组件间解耦，是组件化必须解决的一个问题。换句话说，就是如何解除业务模块间的横向依赖。还是拿上边举得例子来说：</p>\n<p>App的根视图<code>MainViewController</code>需要管理首页、新闻、我的等等页面时，如何做到 <code>MainViewController</code> 中，不用去 <code>import</code>这一大堆 <code>XXViewController</code> ?</p>\n<p>很简单，按软件工程的思路，下意识就会加一个中间层Mediator：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/332029-bd66e6dac09f2e08.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"中间层.png\"></p>\n<p>这样一来，各个模块直接都不需要再互相依赖，而是仅需要依赖 Mediator 层即可。</p>\n<p>可直观上看，这样做并没有什么好处，依赖关系并没有解除，Mediator 依赖了所有模块，而调用者又依赖 Mediator，最后还是一坨互相依赖，跟原来没有 Mediator 的方案相比除了更麻烦点其他没区别。</p>\n<p>我们希望最终能过实现的是单向的依赖，即：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/332029-4bbac402d8344090.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"单向依赖.png\"></p>\n<p>对此，可以参考业内的流行方案：</p>\n<ul>\n<li><p>基于 URL Router、ModuleManager<br>  代表：<a href=\"http://limboy.me/ios/2016/03/10/mgj-components.html\" target=\"_blank\" rel=\"noopener\">蘑菇街 Limboy</a></p>\n</li>\n<li><p>基于 Target-Action、Runtime、Category<br>  代表：<a href=\"http://casatwy.com/iOS-Modulization.html?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io\" target=\"_blank\" rel=\"noopener\">安居客 casa</a></p>\n</li>\n</ul>\n<p>具体实现方案较为抽象，这里暂时先不详细展开论述，可以参见Demo：</p>\n<p><a href=\"https://github.com/yehot/CTMediator\" target=\"_blank\" rel=\"noopener\">Demo1 基于 Target-Action</a></p>\n<p><a href=\"https://github.com/yehot/routable-ios\" target=\"_blank\" rel=\"noopener\">Demo2 基于 URL Router</a></p>\n<h2 id=\"四、其它\"><a href=\"#四、其它\" class=\"headerlink\" title=\"四、其它\"></a>四、其它</h2><h3 id=\"开发流程控制\"><a href=\"#开发流程控制\" class=\"headerlink\" title=\"开发流程控制\"></a>开发流程控制</h3><blockquote>\n<p>托管平台选择</p>\n</blockquote>\n<p>自己利用开源的方案搭建私有的托管平台，可以最大限制地保证代码的安全。开源方案当中最知名也是最为广泛使用的当属 Gitlab。</p>\n<p>组件化使我们从单一的主工程，变成了主工程+多个拆分好的基础模块+统一的私有 Spec 仓库。为了避免某个人的工作对其他人开发环境造成影响，需要对整个组的开发流程进行统一的规范。</p>\n<p>不管是对于主仓库和子模块仓库，git-flow 都是首先推荐的工作流程。一个仓库的 master 分支只有所有者可以有权限更改，其他的贡献者想更改的话，需要自己创建新的分支（在 Github 上就是进行 fork），然后进行更改，之后把更改向原仓库发送 Pull Request。Pull Request 就是一个合并的请求，其中可以看到贡献者的更改，项目主人和其他维护者可以对 Pull Request 进行审核，共同探讨修改意见。当项目主人认为修改 OK 之后，就可以合并这个 Pull Request ，把这部分代码合并到主分支。</p>\n<p>这个流程是完全分布式的，也就是说可以同时有多个贡献者在不同的分支进行工作，最后统一合并到主分支上，实现并行协作。</p>\n<p>同时在审核 Pull Request 阶段，除了人工审核代码之外，Github 还加入了对于持续集成的支持，可以检测这个 Pull Request 是不是能够通过测试的，进一步保证了代码的质量。</p>\n<h3 id=\"组件维护问题？\"><a href=\"#组件维护问题？\" class=\"headerlink\" title=\"组件维护问题？\"></a>组件维护问题？</h3><p>待补充</p>\n<h2 id=\"五、参考资料：\"><a href=\"#五、参考资料：\" class=\"headerlink\" title=\"五、参考资料：\"></a>五、参考资料：</h2><h3 id=\"相关技术博客：\"><a href=\"#相关技术博客：\" class=\"headerlink\" title=\"相关技术博客：\"></a>相关技术博客：</h3><p>1、<a href=\"http://casatwy.com/iOS-Modulization.html?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io\" target=\"_blank\" rel=\"noopener\">iOS应用架构谈 组件化方案</a></p>\n<p>2、<a href=\"http://limboy.me/ios/2016/03/10/mgj-components.html\" target=\"_blank\" rel=\"noopener\">蘑菇街 App 的组件化之路</a></p>\n<p><a href=\"http://limboy.me/ios/2016/03/14/mgj-components-continued.html\" target=\"_blank\" rel=\"noopener\">蘑菇街 App 的组件化之路·续</a></p>\n<p>3、<a href=\"http://blog.cnbang.net/tech/3080/\" target=\"_blank\" rel=\"noopener\">iOS 组件化方案探索</a></p>\n<p>4、<a href=\"http://www.reviewcode.cn/article.html?reviewId=20\" target=\"_blank\" rel=\"noopener\">《iOS应用架构谈 组件化方案》和《蘑菇街 App 的组件化之路》的阅读指导</a></p>\n<p>5、<a href=\"https://skyline75489.github.io/post/2016-3-16_ios_module_design.html\" target=\"_blank\" rel=\"noopener\">浅析 iOS 应用组件化设计</a></p>\n<p>6、<a href=\"http://chuansong.me/n/320688951236\" target=\"_blank\" rel=\"noopener\">糯米移动组件架构演进之路</a></p>\n<p>7、<a href=\"https://www.sdk.cn/news/2023\" target=\"_blank\" rel=\"noopener\">饿了么移动APP的架构演进</a></p>\n<p>8、<a href=\"https://mp.weixin.qq.com/s?__biz=MzA3ODg4MDk0Ng%3D%3D&amp;idx=1&amp;mid=402854111&amp;sn=5876e615fabd6d921285d904e16670fb\" target=\"_blank\" rel=\"noopener\">滴滴出行iOS客户端架构演进之路</a></p>\n<p>9、<a href=\"http://www.aliog.com/101363.html\" target=\"_blank\" rel=\"noopener\">ios业务模块间互相跳转的解耦方案</a></p>\n<p>10、<a href=\"http://cdn0.jianshu.io/p/afb9b52143d4\" target=\"_blank\" rel=\"noopener\">iOS组件化思路－大神博客研读和思考</a></p>\n<p>11、<a href=\"https://blog.cnbluebox.com/blog/2015/11/28/module-and-decoupling/\" target=\"_blank\" rel=\"noopener\">模块化与解耦</a></p>\n<h3 id=\"相关解决方案\"><a href=\"#相关解决方案\" class=\"headerlink\" title=\"相关解决方案\"></a>相关解决方案</h3><p>1、<a href=\"https://github.com/casatwy/CTMediator\" target=\"_blank\" rel=\"noopener\">casatwy/CTMediator</a></p>\n<p>2、<a href=\"https://github.com/mogujie/MGJRouter\" target=\"_blank\" rel=\"noopener\">mogujie/MGJRouter</a></p>\n<p>3、<a href=\"https://github.com/joeldev/JLRoutes\" target=\"_blank\" rel=\"noopener\">joeldev/JLRoutes</a></p>\n<p>4、<a href=\"https://github.com/Huohua/HHRouter\" target=\"_blank\" rel=\"noopener\">Huohua/HHRouter</a></p>\n<p>5、<a href=\"https://github.com/clayallsopp/routable-ios\" target=\"_blank\" rel=\"noopener\">clayallsopp/routable-ios</a></p>\n<p>6、<a href=\"https://github.com/Lede-Inc/LDBusBundle_IOS\" target=\"_blank\" rel=\"noopener\">Lede-Inc/LDBusBundle_IOS</a></p>\n<h3 id=\"私有Cocoapods实施方案\"><a href=\"#私有Cocoapods实施方案\" class=\"headerlink\" title=\"私有Cocoapods实施方案\"></a>私有Cocoapods实施方案</h3><p>1、<a href=\"http://blog.wtlucky.com/blog/2015/02/26/create-private-podspec/\" target=\"_blank\" rel=\"noopener\">使用Cocoapods创建私有podspec - GeekerProbe</a></p>\n<p>2、<a href=\"http://www.pluto-y.com/cocoapod-private-pods-and-module-manager/\" target=\"_blank\" rel=\"noopener\">Cocoapods系列教程(三)——私有库管理和模块化管理</a></p>\n<p>3、<a href=\"http://www.jianshu.com/p/196f66d31543\" target=\"_blank\" rel=\"noopener\">iOS组件化实践方案－LDBusMediator炼就</a></p>\n<p>4、<a href=\"https://skyline75489.github.io/post/2016-3-19_ios_modularization_practice.html\" target=\"_blank\" rel=\"noopener\">基于 CocoaPods 和 Git 的 iOS 工程组件化实践</a></p>\n<p>5、<a href=\"https://blog.cnbluebox.com/blog/2014/03/31/cocoapodsdai-ma-guan-li/\" target=\"_blank\" rel=\"noopener\">Cocoapods代码管理</a></p>\n<p>6、<a href=\"http://www.liuchungui.com/blog/2015/10/19/cocoapodschuang-jian-si-you-pods/\" target=\"_blank\" rel=\"noopener\">CocoaPods创建私有Pods</a></p>\n<p>7、<a href=\"http://www.jianshu.com/p/ddc2490bff9f\" target=\"_blank\" rel=\"noopener\">如何创建私有 CocoaPods 仓库</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"iOS组件化方案探索\"><a href=\"#iOS组件化方案探索\" class=\"headerlink\" title=\"iOS组件化方案探索\"></a>iOS组件化方案探索</h1><h2 id=\"一、什么是组件化？\"><a href=\"#一、什么是组件化？\" class=\"headerlink\" title=\"一、什么是组件化？\"></a>一、什么是组件化？</h2><h3 id=\"什么是组件？\"><a href=\"#什么是组件？\" class=\"headerlink\" title=\"什么是组件？\"></a>什么是组件？</h3><p><code>&quot;组件&quot;</code>一般来说用于命名比较小的功能块，如：下拉刷新组件、提示框组件。而较大粒度的业务功能，我们习惯称之为<code>&quot;模块&quot;</code>，如：首页模块、我的模块、新闻模块。</p>\n<p>这次讨论的主题是组件化，这里为了方便表述，下面模块和组件代表同一个意思，都是指较大粒度的业务模块。</p>\n<h3 id=\"什么是组件化？\"><a href=\"#什么是组件化？\" class=\"headerlink\" title=\"什么是组件化？\"></a>什么是组件化？</h3><p>组件化，或者说模块化，用来分割、组织和打包软件。每个模块完成一个特定的子功能，所有的模块按某种方法组装起来，成为一个整体，完成整个系统所要求的功能。</p>\n<p>从工程代码层面来说，组件化的实施通常是通过<code>中间件</code>解决组件间头文件直接引用、依赖混乱的问题；从实际开发来说，组件之间最大的需求就是页面跳转，需要从组件A的pageA页面跳转到组件B的pageB页面，避免对组件B页面ViewController头文件的直接依赖。</p>\n<h2 id=\"二、为什么要组件化？\"><a href=\"#二、为什么要组件化？\" class=\"headerlink\" title=\"二、为什么要组件化？\"></a>二、为什么要组件化？</h2><p>从两个方面论述：</p>\n<h3 id=\"组件化是为了解决什么问题？\"><a href=\"#组件化是为了解决什么问题？\" class=\"headerlink\" title=\"组件化是为了解决什么问题？\"></a>组件化是为了解决什么问题？</h3><p>一个 APP 有多个模块，模块之间会通信，互相调用，如我们的证券app，有首页、行情、资讯、我的等模块。这些模块会互相调用，例如 首页底部需要展示部分资讯、行情；行情底部需要展示个股资讯；资讯详情页需要跳转到行情，等等。</p>\n<p>一般我们是怎样调用呢，以首页调用资讯为例，会这样写：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;HomeViewController.h&quot;</span><br><span class=\"line\">#import &quot;NewsViewController.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation HomeViewController</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)gotoNews &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"> NewsViewController *detailVC = [[NewsViewController alloc] initWithStockCode:self.codeNum];</span><br><span class=\"line\"> [self.navigationController.pushViewController:detailVC animated:YES];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<p>看起来挺好，这样做简单明了，没有多余的东西，项目初期推荐这样快速开发，但到了项目越来越庞大，这种方式会有什么问题呢？</p>\n<ul>\n<li>问题1，每个模块都离不开其他模块，互相依赖粘在一起成为一坨：</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/332029-f03757f38936ed16.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"各模块互相依赖.png\"></p>\n<p>耦合比较严重（因为没有明确的约束，「组件」间引用的现象会比较多）</p>\n<ul>\n<li>问题2，多人同时开发时，容易出现冲突（尤其是Xcode Project文件）</li>\n<li>问题3，业务方的开发效率不够高（只关心自己的组件，却要编译整个项目，与其他不相干的代码糅合在一起）</li>\n</ul>\n<h3 id=\"组件化的好处？\"><a href=\"#组件化的好处？\" class=\"headerlink\" title=\"组件化的好处？\"></a>组件化的好处？</h3><p><strong>一般意义：</strong></p>\n<ul>\n<li>加快编译速度（不用编译主客那一大坨代码了）；</li>\n<li>各组件自由选择开发姿势（MVC / MVVM / FRP）；</li>\n<li>组件工程本身可以独立开发测试，方便 QA 有针对性地测试；</li>\n<li>规范组件之间的通信接，让各个组件对外都提供一个黑盒服务，减少沟通和维护成本，提高效率；</li>\n</ul>\n<p><strong>对于公司已有项目的现实意义：</strong></p>\n<ul>\n<li>业务分层、解耦，使代码变得可维护；</li>\n<li>有效的拆分、组织日益庞大的工程代码，使工程目录变得可维护；</li>\n<li>便于各业务功能拆分、抽离，实现真正的功能复用；</li>\n<li>业务隔离，跨团队开发代码控制和版本风险控制的实现；</li>\n<li>模块化对代码的封装性、合理性都有一定的要求，提升开发同学的设计能力；</li>\n<li>在维护好各级组件的情况下，随意组合满足不同客户需求；（只需要将之前的多个业务组件模块在新的主App中进行组装即可快速迭代出下一个全新App）</li>\n</ul>\n<h3 id=\"什么情况下进行组件化比较合适？\"><a href=\"#什么情况下进行组件化比较合适？\" class=\"headerlink\" title=\"什么情况下进行组件化比较合适？\"></a>什么情况下进行组件化比较合适？</h3><p>当然组件化也有它的缺点：</p>\n<ul>\n<li><p>学习成本高，对于开发人员对各种工具的掌握要求也比较高，对于新手来说入门较为困难。</p>\n</li>\n<li><p>由于工具和流程的复杂化，导致团队之间协作的成本变高，某些情况下可能会导致开发效率下降。</p>\n</li>\n</ul>\n<p>当项目App处于起步阶段、各个需求模块趋于成熟稳定的过程中，组件化也许并没有那么迫切，甚至考虑组件化的架构可能会影响开发效率和需求迭代。</p>\n<p>而当项目迭代到一定时期之后，便会出现一些相对独立的业务功能模块，而团队的规模也会随着项目迭代逐渐增长，这便是中小型应用考虑组件化的时机了。这时为了更好的分工协作，团队安排团队成员各自维护一个相对独立的业务组件是比较常见的做法。</p>\n<p>在这时这个时候来引入组件化方案，是比较合适的时机。长远来看，组件化带来的好处是远远大于坏处的，特别是随着项目的规模增大，这种好处会变得越来越明显</p>\n<h2 id=\"三、如何组件化？\"><a href=\"#三、如何组件化？\" class=\"headerlink\" title=\"三、如何组件化？\"></a>三、如何组件化？</h2><blockquote>\n<p>组件化的开展需要解决以下几个层次的问题：</p>\n</blockquote>\n<h3 id=\"组件化的架构目标？\"><a href=\"#组件化的架构目标？\" class=\"headerlink\" title=\"组件化的架构目标？\"></a>组件化的架构目标？</h3><p>借用Limboy的图：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/332029-4c7b8e152db83b9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"组件化架构.png\"></p>\n<h3 id=\"如何划分组件？\"><a href=\"#如何划分组件？\" class=\"headerlink\" title=\"如何划分组件？\"></a>如何划分组件？</h3><ul>\n<li>基础功能组件</li>\n<li>基础产品组件</li>\n<li>个性化业务组件</li>\n</ul>\n<p>对于一个没有实施过组件化拆分的工程来说，其中很可能充满了大量不合理的类、方法、头文件和各种错乱的依赖关系，因此首先要进行的第一步是模块拆分。</p>\n<p>模块拆分可以分成两个部分，基础模块拆分和业务模块拆分。基础模块通常是稳定的依赖代码，业务模块是涉及到业务的需要频繁改动的代码。</p>\n<blockquote>\n<p>基础模块拆分</p>\n</blockquote>\n<p>基础模块是任何一个App都需要用到的，如：性能统计、Networking、Patch、网络诊断、数据存储模块。对于基础模块来说，其本身应该是自洽的，即可以单独编译或者几个模块合在一起可以单独编译。所有的依赖关系都应该是业务模块指向基础模块的。<br>基础模块之间尽量避免产生横向依赖。</p>\n<blockquote>\n<p>业务模块拆分</p>\n</blockquote>\n<p>对于业务模块来说，考虑到旧有代码可能没有相关的横向解耦策略，业务模块之间的依赖会非常复杂，难以单独进行拆分，因此我们采用的方法是首先从 group 角度进行重新整理。</p>\n<p>对业务量很大的工程来说，我个人更加推荐“业务-分层”这样的结构，而不是“分层-业务”，即类似下面的 group 结构：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- BusinessA</span><br><span class=\"line\">  - Model</span><br><span class=\"line\">  - View</span><br><span class=\"line\">  - Controller</span><br><span class=\"line\">  - Store</span><br><span class=\"line\">- BusinessB</span><br><span class=\"line\">  - Model</span><br><span class=\"line\">  - View</span><br><span class=\"line\">  - Controller</span><br><span class=\"line\">  -Store</span><br></pre></td></tr></table></figure>\n<p>而非目前项目中采用的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- Controllers</span><br><span class=\"line\">  - BusinessA_Controller</span><br><span class=\"line\">  - BusinessB_Controller</span><br><span class=\"line\">- Views</span><br><span class=\"line\">  - BusinessA_View</span><br><span class=\"line\">  - BusinessB_View</span><br><span class=\"line\">- Models</span><br><span class=\"line\">  - BusinessA_Model</span><br><span class=\"line\">  - BusinessB_Model</span><br></pre></td></tr></table></figure>\n<h3 id=\"组件化的技术难点？\"><a href=\"#组件化的技术难点？\" class=\"headerlink\" title=\"组件化的技术难点？\"></a>组件化的技术难点？</h3><blockquote>\n<p>组件化的实施，直观上看，只是需要将各业务组件的代码放到各自的文件夹或者 jar包里就行了。</p>\n</blockquote>\n<p>这里引出的是：</p>\n<h4 id=\"1、组件的拆分方式问题：\"><a href=\"#1、组件的拆分方式问题：\" class=\"headerlink\" title=\"1、组件的拆分方式问题：\"></a>1、组件的拆分方式问题：</h4><p>可以利用CocoaPods 配合 git 做代码版本管理，独立业务模块单独成库。</p>\n<p>但这仅仅是物理上拆分了，拆分后的代码编译是肯定通不过的，因为如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">#import &quot;MainViewController.h&quot;</span><br><span class=\"line\">#import &quot;HomeViewController.h&quot;</span><br><span class=\"line\">#import &quot;NewsViewController.h&quot;</span><br><span class=\"line\">#import &quot;MeViewController.h&quot;</span><br><span class=\"line\">#import ...</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation MainViewController</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<p><code>MainViewController</code> 会找不到依赖的其它各个模块的头文件而报错。这里引出的又是另一个问题：</p>\n<h4 id=\"2、组件间如何解耦？\"><a href=\"#2、组件间如何解耦？\" class=\"headerlink\" title=\"2、组件间如何解耦？\"></a>2、组件间如何解耦？</h4><p>组件间解耦，是组件化必须解决的一个问题。换句话说，就是如何解除业务模块间的横向依赖。还是拿上边举得例子来说：</p>\n<p>App的根视图<code>MainViewController</code>需要管理首页、新闻、我的等等页面时，如何做到 <code>MainViewController</code> 中，不用去 <code>import</code>这一大堆 <code>XXViewController</code> ?</p>\n<p>很简单，按软件工程的思路，下意识就会加一个中间层Mediator：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/332029-bd66e6dac09f2e08.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"中间层.png\"></p>\n<p>这样一来，各个模块直接都不需要再互相依赖，而是仅需要依赖 Mediator 层即可。</p>\n<p>可直观上看，这样做并没有什么好处，依赖关系并没有解除，Mediator 依赖了所有模块，而调用者又依赖 Mediator，最后还是一坨互相依赖，跟原来没有 Mediator 的方案相比除了更麻烦点其他没区别。</p>\n<p>我们希望最终能过实现的是单向的依赖，即：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/332029-4bbac402d8344090.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"单向依赖.png\"></p>\n<p>对此，可以参考业内的流行方案：</p>\n<ul>\n<li><p>基于 URL Router、ModuleManager<br>  代表：<a href=\"http://limboy.me/ios/2016/03/10/mgj-components.html\" target=\"_blank\" rel=\"noopener\">蘑菇街 Limboy</a></p>\n</li>\n<li><p>基于 Target-Action、Runtime、Category<br>  代表：<a href=\"http://casatwy.com/iOS-Modulization.html?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io\" target=\"_blank\" rel=\"noopener\">安居客 casa</a></p>\n</li>\n</ul>\n<p>具体实现方案较为抽象，这里暂时先不详细展开论述，可以参见Demo：</p>\n<p><a href=\"https://github.com/yehot/CTMediator\" target=\"_blank\" rel=\"noopener\">Demo1 基于 Target-Action</a></p>\n<p><a href=\"https://github.com/yehot/routable-ios\" target=\"_blank\" rel=\"noopener\">Demo2 基于 URL Router</a></p>\n<h2 id=\"四、其它\"><a href=\"#四、其它\" class=\"headerlink\" title=\"四、其它\"></a>四、其它</h2><h3 id=\"开发流程控制\"><a href=\"#开发流程控制\" class=\"headerlink\" title=\"开发流程控制\"></a>开发流程控制</h3><blockquote>\n<p>托管平台选择</p>\n</blockquote>\n<p>自己利用开源的方案搭建私有的托管平台，可以最大限制地保证代码的安全。开源方案当中最知名也是最为广泛使用的当属 Gitlab。</p>\n<p>组件化使我们从单一的主工程，变成了主工程+多个拆分好的基础模块+统一的私有 Spec 仓库。为了避免某个人的工作对其他人开发环境造成影响，需要对整个组的开发流程进行统一的规范。</p>\n<p>不管是对于主仓库和子模块仓库，git-flow 都是首先推荐的工作流程。一个仓库的 master 分支只有所有者可以有权限更改，其他的贡献者想更改的话，需要自己创建新的分支（在 Github 上就是进行 fork），然后进行更改，之后把更改向原仓库发送 Pull Request。Pull Request 就是一个合并的请求，其中可以看到贡献者的更改，项目主人和其他维护者可以对 Pull Request 进行审核，共同探讨修改意见。当项目主人认为修改 OK 之后，就可以合并这个 Pull Request ，把这部分代码合并到主分支。</p>\n<p>这个流程是完全分布式的，也就是说可以同时有多个贡献者在不同的分支进行工作，最后统一合并到主分支上，实现并行协作。</p>\n<p>同时在审核 Pull Request 阶段，除了人工审核代码之外，Github 还加入了对于持续集成的支持，可以检测这个 Pull Request 是不是能够通过测试的，进一步保证了代码的质量。</p>\n<h3 id=\"组件维护问题？\"><a href=\"#组件维护问题？\" class=\"headerlink\" title=\"组件维护问题？\"></a>组件维护问题？</h3><p>待补充</p>\n<h2 id=\"五、参考资料：\"><a href=\"#五、参考资料：\" class=\"headerlink\" title=\"五、参考资料：\"></a>五、参考资料：</h2><h3 id=\"相关技术博客：\"><a href=\"#相关技术博客：\" class=\"headerlink\" title=\"相关技术博客：\"></a>相关技术博客：</h3><p>1、<a href=\"http://casatwy.com/iOS-Modulization.html?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io\" target=\"_blank\" rel=\"noopener\">iOS应用架构谈 组件化方案</a></p>\n<p>2、<a href=\"http://limboy.me/ios/2016/03/10/mgj-components.html\" target=\"_blank\" rel=\"noopener\">蘑菇街 App 的组件化之路</a></p>\n<p><a href=\"http://limboy.me/ios/2016/03/14/mgj-components-continued.html\" target=\"_blank\" rel=\"noopener\">蘑菇街 App 的组件化之路·续</a></p>\n<p>3、<a href=\"http://blog.cnbang.net/tech/3080/\" target=\"_blank\" rel=\"noopener\">iOS 组件化方案探索</a></p>\n<p>4、<a href=\"http://www.reviewcode.cn/article.html?reviewId=20\" target=\"_blank\" rel=\"noopener\">《iOS应用架构谈 组件化方案》和《蘑菇街 App 的组件化之路》的阅读指导</a></p>\n<p>5、<a href=\"https://skyline75489.github.io/post/2016-3-16_ios_module_design.html\" target=\"_blank\" rel=\"noopener\">浅析 iOS 应用组件化设计</a></p>\n<p>6、<a href=\"http://chuansong.me/n/320688951236\" target=\"_blank\" rel=\"noopener\">糯米移动组件架构演进之路</a></p>\n<p>7、<a href=\"https://www.sdk.cn/news/2023\" target=\"_blank\" rel=\"noopener\">饿了么移动APP的架构演进</a></p>\n<p>8、<a href=\"https://mp.weixin.qq.com/s?__biz=MzA3ODg4MDk0Ng%3D%3D&amp;idx=1&amp;mid=402854111&amp;sn=5876e615fabd6d921285d904e16670fb\" target=\"_blank\" rel=\"noopener\">滴滴出行iOS客户端架构演进之路</a></p>\n<p>9、<a href=\"http://www.aliog.com/101363.html\" target=\"_blank\" rel=\"noopener\">ios业务模块间互相跳转的解耦方案</a></p>\n<p>10、<a href=\"http://cdn0.jianshu.io/p/afb9b52143d4\" target=\"_blank\" rel=\"noopener\">iOS组件化思路－大神博客研读和思考</a></p>\n<p>11、<a href=\"https://blog.cnbluebox.com/blog/2015/11/28/module-and-decoupling/\" target=\"_blank\" rel=\"noopener\">模块化与解耦</a></p>\n<h3 id=\"相关解决方案\"><a href=\"#相关解决方案\" class=\"headerlink\" title=\"相关解决方案\"></a>相关解决方案</h3><p>1、<a href=\"https://github.com/casatwy/CTMediator\" target=\"_blank\" rel=\"noopener\">casatwy/CTMediator</a></p>\n<p>2、<a href=\"https://github.com/mogujie/MGJRouter\" target=\"_blank\" rel=\"noopener\">mogujie/MGJRouter</a></p>\n<p>3、<a href=\"https://github.com/joeldev/JLRoutes\" target=\"_blank\" rel=\"noopener\">joeldev/JLRoutes</a></p>\n<p>4、<a href=\"https://github.com/Huohua/HHRouter\" target=\"_blank\" rel=\"noopener\">Huohua/HHRouter</a></p>\n<p>5、<a href=\"https://github.com/clayallsopp/routable-ios\" target=\"_blank\" rel=\"noopener\">clayallsopp/routable-ios</a></p>\n<p>6、<a href=\"https://github.com/Lede-Inc/LDBusBundle_IOS\" target=\"_blank\" rel=\"noopener\">Lede-Inc/LDBusBundle_IOS</a></p>\n<h3 id=\"私有Cocoapods实施方案\"><a href=\"#私有Cocoapods实施方案\" class=\"headerlink\" title=\"私有Cocoapods实施方案\"></a>私有Cocoapods实施方案</h3><p>1、<a href=\"http://blog.wtlucky.com/blog/2015/02/26/create-private-podspec/\" target=\"_blank\" rel=\"noopener\">使用Cocoapods创建私有podspec - GeekerProbe</a></p>\n<p>2、<a href=\"http://www.pluto-y.com/cocoapod-private-pods-and-module-manager/\" target=\"_blank\" rel=\"noopener\">Cocoapods系列教程(三)——私有库管理和模块化管理</a></p>\n<p>3、<a href=\"http://www.jianshu.com/p/196f66d31543\" target=\"_blank\" rel=\"noopener\">iOS组件化实践方案－LDBusMediator炼就</a></p>\n<p>4、<a href=\"https://skyline75489.github.io/post/2016-3-19_ios_modularization_practice.html\" target=\"_blank\" rel=\"noopener\">基于 CocoaPods 和 Git 的 iOS 工程组件化实践</a></p>\n<p>5、<a href=\"https://blog.cnbluebox.com/blog/2014/03/31/cocoapodsdai-ma-guan-li/\" target=\"_blank\" rel=\"noopener\">Cocoapods代码管理</a></p>\n<p>6、<a href=\"http://www.liuchungui.com/blog/2015/10/19/cocoapodschuang-jian-si-you-pods/\" target=\"_blank\" rel=\"noopener\">CocoaPods创建私有Pods</a></p>\n<p>7、<a href=\"http://www.jianshu.com/p/ddc2490bff9f\" target=\"_blank\" rel=\"noopener\">如何创建私有 CocoaPods 仓库</a></p>\n"},{"title":"runtime入门系列之——方法替换","date":"2016-07-02T10:58:37.000Z","_content":"\n作为一个有2年以上 iOS 开发经验的程序猿，如果说自己不知道 runtime 简直不好意思跟别人打招呼了。\n\n但是大部分初级 iOS 程序猿在实际项目开发中，很少有机会需要主动用到 runtime 相关的东西。最近面试的不少同学，当我问\"请说说你对 iOS 中 runtime 的理解\"就懵逼了。\n\n其实作为小面试官，我也是很尴尬的。你简历上期望薪资都写 15k+ 了，那总不能指望面试一个小时，我都只跟你聊如何写界面吧？\n\n---\n\n我觉得当我问面试者：\n> \"什么是 runtime ?\"\n\n这个问题时，如果能在以下三个方面做个简单的阐述，我觉得就基本合格了。\n\n### 一、runtime 是什么？\n\n- 首先 OC 是 C 语言的超集，因为 runtime 这个库使得C语言有了面向对象的能力：\nOC 对象可以用C语言中的结构体表示，而方法可以用C函数来实现，这些结构体和函数被 runtime 函数封装后，我们就可以在程序运行时创建，检查，修改类、对象和它们的方法了。\n\n- OC 是一门动态语言，它将很多静态语言在编译和链接时期做的事放到了运行时来处理。\n这种特性意味着Objective-C不仅需要一个编译器，还需要一个运行时系统来执行编译的代码。这个运行时系统即Objc Runtime。Objc Runtime基本上是用C和汇编写的。\n[参考 南峰子： Objective-C Runtime 运行时之一：类与对象](http://southpeak.github.io/blog/2014/10/25/objective-c-runtime-yun-xing-shi-zhi-lei-yu-dui-xiang/)\n\n### 二、runtime 有什么用？\n- 我们写的代码在程序运行过程中都会被转化成 runtime 的C代码执行\nOC的类、对象、方法在运行时，最终都转换成 C语言的 结构体、函数来执行。\n     可以在程序运行时创建，检查，修改类、对象和它们的方法。\n\n- 常用于：\n      - 获取类的方法列表/参数列表；\n      - 方法调用；\n      - 方法拦截、动态添加方法；\n      - 方法替换： method swizzling\n      - 关联对象，动态添加属性；\n\n### 三、runtime 怎么用？\n\n> 或者，说说你具体在项目中哪些地方用到过 runtime ？\n\n- runtime 的 API 提供了大量的函数来操作类和对象，如：\n    - 动态替换方法的实现、方法拦截：`class_replaceMethod`\n    - 获取对象的属性列表：`class_copyIvarList`\n    - 获取对象的方法列表： `class_copyMethodList`\n    - 动态添加属性: `class_addProperty`\n    - 动态添加方法： `class_addMethod`\n    - 获取方法名： `method_getName`\n    - 获取方法的实现： `class_getMethodImplementation`\n\n- 具体应用：\n    - 给 category 添加属性： \n        `给 UIAlertView 加 block 回调`\n    - 给系统的方法做替换，插入代码： \n        `替换 viewDidLoad 方法的实现，NSLog 出每一个出现页面的类名`\n\n---\n\n## 「方法替换」demo:\n\n声明一个`People`类\n```\n@interface People : NSObject\n- (void)run;\n@end\n\n@implementation People\n- (void)run {\n    NSLog(@\"People run\");\n}\n@end\n```\n\n实现替换的方法\n\n```\n@implementation ViewController\n\n// demo 是在当前类直接定义了一个方法，也可以用代码动态生成一个方法\n- (void)runFast {\n    NSLog(@\"People run fast\");\n}\n\n/\n *  替换 People 类中 run 方法的实现\n */\n- (void)replacePeopleRunMethod {\n    \n    Class peopleClass = NSClassFromString(@\"People\");\n    SEL peopleRunSel = @selector(run);\n    Method methodRun = class_getInstanceMethod(peopleClass, peopleRunSel);\n    // 获取 run 方法的参数 （包括了 parameter and return types）\n    char *typeDescription = (char *)method_getTypeEncoding(methodRun);\n    \n    // 获取 runFast 方法的实现\n    IMP runFastImp = class_getMethodImplementation([self class], @selector(runFast));\n    \n    // 给 People 新增 runFast 方法，并指向的当前类中 runFast 的实现\n    class_addMethod(peopleClass, @selector(runFast), runFastImp, typeDescription);\n    \n    // 替换 run 方法为 runFast 方法\n    class_replaceMethod(peopleClass, peopleRunSel, runFastImp, typeDescription);\n}\n@end\n```\n\n调用\n\n```\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    People *p1 = [[People alloc] init];\n    [p1 run];\n    \n    [self replacePeopleRunMethod];\n    [p1 run];\n}\n```\n\n输出如下：\n```\n2016-07-02 18:11:26.707 RuntimeDemo[26972:1726702] People run\n2016-07-02 18:11:26.712 RuntimeDemo[26972:1726702] People run fast\n```\n> 注意，这里的方法替换是永久性的，只要程序不退出，以后无论在任何地方调用`[p1 run]`都只会调用`runFast`的实现。\n\n> 而且，method swizzling 方法并不适合写在这里，通常写在 `+ (void)load `方法中，并且用 `dispatch_once` 来进行调度。至于为什么，可以参考[Objective-C +load vs +initialize](http://blog.leichunfeng.com/blog/2015/05/02/objective-c-plus-load-vs-plus-initialize/)。\n\n相关注释：\n\n```\n    // Method : 包含了一个方法的  方法名 + 实现 + 参数个数及类型 + 返回值个数及类型 等信息\n    // class_getInstanceMethod : 通过类名 + 方法名 获取一个 Method\n    // class_getMethodImplementation: 类名 + 方法名\n    // class_addMethod: 类名 + 方法名 + 方法实现 + 参数信息\n    // class_replaceMethod : 类型 + 替换的方法名 + 替换后的实现 + 参数信息\n```\n\n以上 demo 只是简单的在当前类`ViewController`中，定义了一个`runFast`方法，并用其替换了`People` 类中`run`方法的实现。\n\n这里需要先用 `class_addMethod`，而不是直接用`class_replaceMethod`，是为了做一层保护，因为如果 `People` 类没有实现 `run` 方法 ，但其父类实现了，那 class_getInstanceMethod 会返回父类的方法。\n     这样 method_exchangeImplementations 替换的是父类的那个方法，这当然不是你想要的。\n     所以我们先尝试添加 `runFast`方法，如果已经存在，就用 `method_exchangeImplementations` 把原方法的实现跟新的方法实现给交换掉。否则用`class_replaceMethod`来替换。\n\n---\n\n### 「方法替换」常规写法\n\n上文 demo 中的写法，只是实现了方法替换的效果，但真正在项目中用的时候会存在一些问题，如调用时机、调用次数、替换失败等问题，所以，一般实战中写法如下：\n\n```\n#import \"UIViewController+Logging.h\"\n#import <objc/runtime.h>\n\n@implementation UIViewController (Logging)\n\n+ (void)load {\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        Class targetClass = [self class];\n        SEL originalSelector = @selector(viewDidAppear:);\n        SEL swizzledSelector = @selector(swizzled_viewDidAppear:);\n        swizzleMethod(targetClass, originalSelector, swizzledSelector);\n    });\n}\n\nvoid swizzleMethod(Class class, SEL originalSelector, SEL swizzledSelector) {\n    Method originalMethod = class_getInstanceMethod(class, originalSelector);\n    Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);\n    \n    IMP swizzledImp = method_getImplementation(swizzledMethod);\n    char *swizzledTypes = (char *)method_getTypeEncoding(swizzledMethod);\n    \n    IMP originalImp = method_getImplementation(originalMethod);\n    \n    char *originalTypes = (char *)method_getTypeEncoding(originalMethod);\n    BOOL success = class_addMethod(class, originalSelector, swizzledImp, swizzledTypes);\n    if (success) {\n        class_replaceMethod(class, swizzledSelector, originalImp, originalTypes);\n    }else {\n        // 添加失败，表明已经有这个方法，直接交换\n        method_exchangeImplementations(originalMethod, swizzledMethod);\n    }\n}\n\n- (void)swizzled_viewDidAppear:(BOOL)animation {\n    [self swizzled_viewDidAppear:animation];\n    NSLog(@\"%@ viewDidAppear\", NSStringFromClass([self class]));\n}\n\n@end\n```\n---\n\n### 扩展 —— 用 Aspects 实现方法替换\n\n上边 demo 中写了一大堆 runtime 的 api 在代码里，即不好阅读，也不便于维护。\n> 这里有现成的方案：一个基于 swizzling method 的开源框架 [Aspects](https://github.com/steipete/Aspects) 。\n\n用 `Aspects` 来实现上文 demo 如下：\n\n```\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    People *p1 = [[People alloc] init];\n    [p1 run];   \n      \n    [People aspect_hookSelector:@selector(run) withOptions:AspectPositionInstead usingBlock:^(id<AspectInfo> aspectInfo) {\n        NSLog(@\"People aspect run fast\");\n    } error:nil];\n\n    [p1 run];\n```\n\n输出：\n\n```\n2016-07-02 18:16:38.039 RuntimeDemo[26994:1730239] People run\n2016-07-02 18:16:38.043 RuntimeDemo[26994:1730239] People aspect run fast\n```\n\n需要注意的是 `Aspects` 的 `aspect_hookSelector:` 方法中，`AspectOptions`参数决定了方法替换的时机：\n\n```\ntypedef NS_OPTIONS(NSUInteger, AspectOptions) {\n    AspectPositionAfter   = 0,            /// 原方法调用后 (default)\n    AspectPositionInstead = 1,            /// 完全替换原方法\n    AspectPositionBefore  = 2,            /// 原方法调用前\n    AspectOptionAutomaticRemoval = 1 << 3 /// 在执行一次替换的方法后，就移除替换效果\n    };\n```\n\n`Aspects`帮我们封装了 `method swizzling`的过程，剩下的只管用就行了。\n\n[本文 demo 代码 戳这里](https://github.com/yehot/RuntimeDemo)\n\n> 水平有限，有错误的地方，欢迎指正！\n","source":"_posts/20160702-rutime-method-swiizzling.md","raw":"---\ntitle: runtime入门系列之——方法替换\ndate: 2016-07-02 18:58:37\ntags: runtime swizzling\n---\n\n作为一个有2年以上 iOS 开发经验的程序猿，如果说自己不知道 runtime 简直不好意思跟别人打招呼了。\n\n但是大部分初级 iOS 程序猿在实际项目开发中，很少有机会需要主动用到 runtime 相关的东西。最近面试的不少同学，当我问\"请说说你对 iOS 中 runtime 的理解\"就懵逼了。\n\n其实作为小面试官，我也是很尴尬的。你简历上期望薪资都写 15k+ 了，那总不能指望面试一个小时，我都只跟你聊如何写界面吧？\n\n---\n\n我觉得当我问面试者：\n> \"什么是 runtime ?\"\n\n这个问题时，如果能在以下三个方面做个简单的阐述，我觉得就基本合格了。\n\n### 一、runtime 是什么？\n\n- 首先 OC 是 C 语言的超集，因为 runtime 这个库使得C语言有了面向对象的能力：\nOC 对象可以用C语言中的结构体表示，而方法可以用C函数来实现，这些结构体和函数被 runtime 函数封装后，我们就可以在程序运行时创建，检查，修改类、对象和它们的方法了。\n\n- OC 是一门动态语言，它将很多静态语言在编译和链接时期做的事放到了运行时来处理。\n这种特性意味着Objective-C不仅需要一个编译器，还需要一个运行时系统来执行编译的代码。这个运行时系统即Objc Runtime。Objc Runtime基本上是用C和汇编写的。\n[参考 南峰子： Objective-C Runtime 运行时之一：类与对象](http://southpeak.github.io/blog/2014/10/25/objective-c-runtime-yun-xing-shi-zhi-lei-yu-dui-xiang/)\n\n### 二、runtime 有什么用？\n- 我们写的代码在程序运行过程中都会被转化成 runtime 的C代码执行\nOC的类、对象、方法在运行时，最终都转换成 C语言的 结构体、函数来执行。\n     可以在程序运行时创建，检查，修改类、对象和它们的方法。\n\n- 常用于：\n      - 获取类的方法列表/参数列表；\n      - 方法调用；\n      - 方法拦截、动态添加方法；\n      - 方法替换： method swizzling\n      - 关联对象，动态添加属性；\n\n### 三、runtime 怎么用？\n\n> 或者，说说你具体在项目中哪些地方用到过 runtime ？\n\n- runtime 的 API 提供了大量的函数来操作类和对象，如：\n    - 动态替换方法的实现、方法拦截：`class_replaceMethod`\n    - 获取对象的属性列表：`class_copyIvarList`\n    - 获取对象的方法列表： `class_copyMethodList`\n    - 动态添加属性: `class_addProperty`\n    - 动态添加方法： `class_addMethod`\n    - 获取方法名： `method_getName`\n    - 获取方法的实现： `class_getMethodImplementation`\n\n- 具体应用：\n    - 给 category 添加属性： \n        `给 UIAlertView 加 block 回调`\n    - 给系统的方法做替换，插入代码： \n        `替换 viewDidLoad 方法的实现，NSLog 出每一个出现页面的类名`\n\n---\n\n## 「方法替换」demo:\n\n声明一个`People`类\n```\n@interface People : NSObject\n- (void)run;\n@end\n\n@implementation People\n- (void)run {\n    NSLog(@\"People run\");\n}\n@end\n```\n\n实现替换的方法\n\n```\n@implementation ViewController\n\n// demo 是在当前类直接定义了一个方法，也可以用代码动态生成一个方法\n- (void)runFast {\n    NSLog(@\"People run fast\");\n}\n\n/\n *  替换 People 类中 run 方法的实现\n */\n- (void)replacePeopleRunMethod {\n    \n    Class peopleClass = NSClassFromString(@\"People\");\n    SEL peopleRunSel = @selector(run);\n    Method methodRun = class_getInstanceMethod(peopleClass, peopleRunSel);\n    // 获取 run 方法的参数 （包括了 parameter and return types）\n    char *typeDescription = (char *)method_getTypeEncoding(methodRun);\n    \n    // 获取 runFast 方法的实现\n    IMP runFastImp = class_getMethodImplementation([self class], @selector(runFast));\n    \n    // 给 People 新增 runFast 方法，并指向的当前类中 runFast 的实现\n    class_addMethod(peopleClass, @selector(runFast), runFastImp, typeDescription);\n    \n    // 替换 run 方法为 runFast 方法\n    class_replaceMethod(peopleClass, peopleRunSel, runFastImp, typeDescription);\n}\n@end\n```\n\n调用\n\n```\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    People *p1 = [[People alloc] init];\n    [p1 run];\n    \n    [self replacePeopleRunMethod];\n    [p1 run];\n}\n```\n\n输出如下：\n```\n2016-07-02 18:11:26.707 RuntimeDemo[26972:1726702] People run\n2016-07-02 18:11:26.712 RuntimeDemo[26972:1726702] People run fast\n```\n> 注意，这里的方法替换是永久性的，只要程序不退出，以后无论在任何地方调用`[p1 run]`都只会调用`runFast`的实现。\n\n> 而且，method swizzling 方法并不适合写在这里，通常写在 `+ (void)load `方法中，并且用 `dispatch_once` 来进行调度。至于为什么，可以参考[Objective-C +load vs +initialize](http://blog.leichunfeng.com/blog/2015/05/02/objective-c-plus-load-vs-plus-initialize/)。\n\n相关注释：\n\n```\n    // Method : 包含了一个方法的  方法名 + 实现 + 参数个数及类型 + 返回值个数及类型 等信息\n    // class_getInstanceMethod : 通过类名 + 方法名 获取一个 Method\n    // class_getMethodImplementation: 类名 + 方法名\n    // class_addMethod: 类名 + 方法名 + 方法实现 + 参数信息\n    // class_replaceMethod : 类型 + 替换的方法名 + 替换后的实现 + 参数信息\n```\n\n以上 demo 只是简单的在当前类`ViewController`中，定义了一个`runFast`方法，并用其替换了`People` 类中`run`方法的实现。\n\n这里需要先用 `class_addMethod`，而不是直接用`class_replaceMethod`，是为了做一层保护，因为如果 `People` 类没有实现 `run` 方法 ，但其父类实现了，那 class_getInstanceMethod 会返回父类的方法。\n     这样 method_exchangeImplementations 替换的是父类的那个方法，这当然不是你想要的。\n     所以我们先尝试添加 `runFast`方法，如果已经存在，就用 `method_exchangeImplementations` 把原方法的实现跟新的方法实现给交换掉。否则用`class_replaceMethod`来替换。\n\n---\n\n### 「方法替换」常规写法\n\n上文 demo 中的写法，只是实现了方法替换的效果，但真正在项目中用的时候会存在一些问题，如调用时机、调用次数、替换失败等问题，所以，一般实战中写法如下：\n\n```\n#import \"UIViewController+Logging.h\"\n#import <objc/runtime.h>\n\n@implementation UIViewController (Logging)\n\n+ (void)load {\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        Class targetClass = [self class];\n        SEL originalSelector = @selector(viewDidAppear:);\n        SEL swizzledSelector = @selector(swizzled_viewDidAppear:);\n        swizzleMethod(targetClass, originalSelector, swizzledSelector);\n    });\n}\n\nvoid swizzleMethod(Class class, SEL originalSelector, SEL swizzledSelector) {\n    Method originalMethod = class_getInstanceMethod(class, originalSelector);\n    Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);\n    \n    IMP swizzledImp = method_getImplementation(swizzledMethod);\n    char *swizzledTypes = (char *)method_getTypeEncoding(swizzledMethod);\n    \n    IMP originalImp = method_getImplementation(originalMethod);\n    \n    char *originalTypes = (char *)method_getTypeEncoding(originalMethod);\n    BOOL success = class_addMethod(class, originalSelector, swizzledImp, swizzledTypes);\n    if (success) {\n        class_replaceMethod(class, swizzledSelector, originalImp, originalTypes);\n    }else {\n        // 添加失败，表明已经有这个方法，直接交换\n        method_exchangeImplementations(originalMethod, swizzledMethod);\n    }\n}\n\n- (void)swizzled_viewDidAppear:(BOOL)animation {\n    [self swizzled_viewDidAppear:animation];\n    NSLog(@\"%@ viewDidAppear\", NSStringFromClass([self class]));\n}\n\n@end\n```\n---\n\n### 扩展 —— 用 Aspects 实现方法替换\n\n上边 demo 中写了一大堆 runtime 的 api 在代码里，即不好阅读，也不便于维护。\n> 这里有现成的方案：一个基于 swizzling method 的开源框架 [Aspects](https://github.com/steipete/Aspects) 。\n\n用 `Aspects` 来实现上文 demo 如下：\n\n```\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    People *p1 = [[People alloc] init];\n    [p1 run];   \n      \n    [People aspect_hookSelector:@selector(run) withOptions:AspectPositionInstead usingBlock:^(id<AspectInfo> aspectInfo) {\n        NSLog(@\"People aspect run fast\");\n    } error:nil];\n\n    [p1 run];\n```\n\n输出：\n\n```\n2016-07-02 18:16:38.039 RuntimeDemo[26994:1730239] People run\n2016-07-02 18:16:38.043 RuntimeDemo[26994:1730239] People aspect run fast\n```\n\n需要注意的是 `Aspects` 的 `aspect_hookSelector:` 方法中，`AspectOptions`参数决定了方法替换的时机：\n\n```\ntypedef NS_OPTIONS(NSUInteger, AspectOptions) {\n    AspectPositionAfter   = 0,            /// 原方法调用后 (default)\n    AspectPositionInstead = 1,            /// 完全替换原方法\n    AspectPositionBefore  = 2,            /// 原方法调用前\n    AspectOptionAutomaticRemoval = 1 << 3 /// 在执行一次替换的方法后，就移除替换效果\n    };\n```\n\n`Aspects`帮我们封装了 `method swizzling`的过程，剩下的只管用就行了。\n\n[本文 demo 代码 戳这里](https://github.com/yehot/RuntimeDemo)\n\n> 水平有限，有错误的地方，欢迎指正！\n","slug":"20160702-rutime-method-swiizzling","published":1,"updated":"2019-04-18T11:06:48.747Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjumvmxab000zraxeqn4gl83z","content":"<p>作为一个有2年以上 iOS 开发经验的程序猿，如果说自己不知道 runtime 简直不好意思跟别人打招呼了。</p>\n<p>但是大部分初级 iOS 程序猿在实际项目开发中，很少有机会需要主动用到 runtime 相关的东西。最近面试的不少同学，当我问”请说说你对 iOS 中 runtime 的理解”就懵逼了。</p>\n<p>其实作为小面试官，我也是很尴尬的。你简历上期望薪资都写 15k+ 了，那总不能指望面试一个小时，我都只跟你聊如何写界面吧？</p>\n<hr>\n<p>我觉得当我问面试者：</p>\n<blockquote>\n<p>“什么是 runtime ?”</p>\n</blockquote>\n<p>这个问题时，如果能在以下三个方面做个简单的阐述，我觉得就基本合格了。</p>\n<h3 id=\"一、runtime-是什么？\"><a href=\"#一、runtime-是什么？\" class=\"headerlink\" title=\"一、runtime 是什么？\"></a>一、runtime 是什么？</h3><ul>\n<li><p>首先 OC 是 C 语言的超集，因为 runtime 这个库使得C语言有了面向对象的能力：<br>OC 对象可以用C语言中的结构体表示，而方法可以用C函数来实现，这些结构体和函数被 runtime 函数封装后，我们就可以在程序运行时创建，检查，修改类、对象和它们的方法了。</p>\n</li>\n<li><p>OC 是一门动态语言，它将很多静态语言在编译和链接时期做的事放到了运行时来处理。<br>这种特性意味着Objective-C不仅需要一个编译器，还需要一个运行时系统来执行编译的代码。这个运行时系统即Objc Runtime。Objc Runtime基本上是用C和汇编写的。<br><a href=\"http://southpeak.github.io/blog/2014/10/25/objective-c-runtime-yun-xing-shi-zhi-lei-yu-dui-xiang/\" target=\"_blank\" rel=\"noopener\">参考 南峰子： Objective-C Runtime 运行时之一：类与对象</a></p>\n</li>\n</ul>\n<h3 id=\"二、runtime-有什么用？\"><a href=\"#二、runtime-有什么用？\" class=\"headerlink\" title=\"二、runtime 有什么用？\"></a>二、runtime 有什么用？</h3><ul>\n<li><p>我们写的代码在程序运行过程中都会被转化成 runtime 的C代码执行<br>OC的类、对象、方法在运行时，最终都转换成 C语言的 结构体、函数来执行。<br>   可以在程序运行时创建，检查，修改类、对象和它们的方法。</p>\n</li>\n<li><p>常用于：</p>\n<pre><code>- 获取类的方法列表/参数列表；\n- 方法调用；\n- 方法拦截、动态添加方法；\n- 方法替换： method swizzling\n- 关联对象，动态添加属性；\n</code></pre></li>\n</ul>\n<h3 id=\"三、runtime-怎么用？\"><a href=\"#三、runtime-怎么用？\" class=\"headerlink\" title=\"三、runtime 怎么用？\"></a>三、runtime 怎么用？</h3><blockquote>\n<p>或者，说说你具体在项目中哪些地方用到过 runtime ？</p>\n</blockquote>\n<ul>\n<li><p>runtime 的 API 提供了大量的函数来操作类和对象，如：</p>\n<ul>\n<li>动态替换方法的实现、方法拦截：<code>class_replaceMethod</code></li>\n<li>获取对象的属性列表：<code>class_copyIvarList</code></li>\n<li>获取对象的方法列表： <code>class_copyMethodList</code></li>\n<li>动态添加属性: <code>class_addProperty</code></li>\n<li>动态添加方法： <code>class_addMethod</code></li>\n<li>获取方法名： <code>method_getName</code></li>\n<li>获取方法的实现： <code>class_getMethodImplementation</code></li>\n</ul>\n</li>\n<li><p>具体应用：</p>\n<ul>\n<li>给 category 添加属性：<br>  <code>给 UIAlertView 加 block 回调</code></li>\n<li>给系统的方法做替换，插入代码：<br>  <code>替换 viewDidLoad 方法的实现，NSLog 出每一个出现页面的类名</code></li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"「方法替换」demo\"><a href=\"#「方法替换」demo\" class=\"headerlink\" title=\"「方法替换」demo:\"></a>「方法替换」demo:</h2><p>声明一个<code>People</code>类<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface People : NSObject</span><br><span class=\"line\">- (void)run;</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation People</span><br><span class=\"line\">- (void)run &#123;</span><br><span class=\"line\">    NSLog(@&quot;People run&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure></p>\n<p>实现替换的方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@implementation ViewController</span><br><span class=\"line\"></span><br><span class=\"line\">// demo 是在当前类直接定义了一个方法，也可以用代码动态生成一个方法</span><br><span class=\"line\">- (void)runFast &#123;</span><br><span class=\"line\">    NSLog(@&quot;People run fast&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/</span><br><span class=\"line\"> *  替换 People 类中 run 方法的实现</span><br><span class=\"line\"> */</span><br><span class=\"line\">- (void)replacePeopleRunMethod &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    Class peopleClass = NSClassFromString(@&quot;People&quot;);</span><br><span class=\"line\">    SEL peopleRunSel = @selector(run);</span><br><span class=\"line\">    Method methodRun = class_getInstanceMethod(peopleClass, peopleRunSel);</span><br><span class=\"line\">    // 获取 run 方法的参数 （包括了 parameter and return types）</span><br><span class=\"line\">    char *typeDescription = (char *)method_getTypeEncoding(methodRun);</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 获取 runFast 方法的实现</span><br><span class=\"line\">    IMP runFastImp = class_getMethodImplementation([self class], @selector(runFast));</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 给 People 新增 runFast 方法，并指向的当前类中 runFast 的实现</span><br><span class=\"line\">    class_addMethod(peopleClass, @selector(runFast), runFastImp, typeDescription);</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 替换 run 方法为 runFast 方法</span><br><span class=\"line\">    class_replaceMethod(peopleClass, peopleRunSel, runFastImp, typeDescription);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<p>调用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\"></span><br><span class=\"line\">    People *p1 = [[People alloc] init];</span><br><span class=\"line\">    [p1 run];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [self replacePeopleRunMethod];</span><br><span class=\"line\">    [p1 run];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-07-02 18:11:26.707 RuntimeDemo[26972:1726702] People run</span><br><span class=\"line\">2016-07-02 18:11:26.712 RuntimeDemo[26972:1726702] People run fast</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>注意，这里的方法替换是永久性的，只要程序不退出，以后无论在任何地方调用<code>[p1 run]</code>都只会调用<code>runFast</code>的实现。</p>\n</blockquote>\n<blockquote>\n<p>而且，method swizzling 方法并不适合写在这里，通常写在 <code>+ (void)load</code>方法中，并且用 <code>dispatch_once</code> 来进行调度。至于为什么，可以参考<a href=\"http://blog.leichunfeng.com/blog/2015/05/02/objective-c-plus-load-vs-plus-initialize/\" target=\"_blank\" rel=\"noopener\">Objective-C +load vs +initialize</a>。</p>\n</blockquote>\n<p>相关注释：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    // Method : 包含了一个方法的  方法名 + 实现 + 参数个数及类型 + 返回值个数及类型 等信息</span><br><span class=\"line\">    // class_getInstanceMethod : 通过类名 + 方法名 获取一个 Method</span><br><span class=\"line\">// class_getMethodImplementation: 类名 + 方法名</span><br><span class=\"line\">    // class_addMethod: 类名 + 方法名 + 方法实现 + 参数信息</span><br><span class=\"line\">    // class_replaceMethod : 类型 + 替换的方法名 + 替换后的实现 + 参数信息</span><br></pre></td></tr></table></figure>\n<p>以上 demo 只是简单的在当前类<code>ViewController</code>中，定义了一个<code>runFast</code>方法，并用其替换了<code>People</code> 类中<code>run</code>方法的实现。</p>\n<p>这里需要先用 <code>class_addMethod</code>，而不是直接用<code>class_replaceMethod</code>，是为了做一层保护，因为如果 <code>People</code> 类没有实现 <code>run</code> 方法 ，但其父类实现了，那 class_getInstanceMethod 会返回父类的方法。<br>     这样 method_exchangeImplementations 替换的是父类的那个方法，这当然不是你想要的。<br>     所以我们先尝试添加 <code>runFast</code>方法，如果已经存在，就用 <code>method_exchangeImplementations</code> 把原方法的实现跟新的方法实现给交换掉。否则用<code>class_replaceMethod</code>来替换。</p>\n<hr>\n<h3 id=\"「方法替换」常规写法\"><a href=\"#「方法替换」常规写法\" class=\"headerlink\" title=\"「方法替换」常规写法\"></a>「方法替换」常规写法</h3><p>上文 demo 中的写法，只是实现了方法替换的效果，但真正在项目中用的时候会存在一些问题，如调用时机、调用次数、替换失败等问题，所以，一般实战中写法如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;UIViewController+Logging.h&quot;</span><br><span class=\"line\">#import &lt;objc/runtime.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation UIViewController (Logging)</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)load &#123;</span><br><span class=\"line\">    static dispatch_once_t onceToken;</span><br><span class=\"line\">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class=\"line\">        Class targetClass = [self class];</span><br><span class=\"line\">        SEL originalSelector = @selector(viewDidAppear:);</span><br><span class=\"line\">        SEL swizzledSelector = @selector(swizzled_viewDidAppear:);</span><br><span class=\"line\">        swizzleMethod(targetClass, originalSelector, swizzledSelector);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void swizzleMethod(Class class, SEL originalSelector, SEL swizzledSelector) &#123;</span><br><span class=\"line\">    Method originalMethod = class_getInstanceMethod(class, originalSelector);</span><br><span class=\"line\">    Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);</span><br><span class=\"line\">    </span><br><span class=\"line\">    IMP swizzledImp = method_getImplementation(swizzledMethod);</span><br><span class=\"line\">    char *swizzledTypes = (char *)method_getTypeEncoding(swizzledMethod);</span><br><span class=\"line\">    </span><br><span class=\"line\">    IMP originalImp = method_getImplementation(originalMethod);</span><br><span class=\"line\">    </span><br><span class=\"line\">    char *originalTypes = (char *)method_getTypeEncoding(originalMethod);</span><br><span class=\"line\">    BOOL success = class_addMethod(class, originalSelector, swizzledImp, swizzledTypes);</span><br><span class=\"line\">    if (success) &#123;</span><br><span class=\"line\">        class_replaceMethod(class, swizzledSelector, originalImp, originalTypes);</span><br><span class=\"line\">    &#125;else &#123;</span><br><span class=\"line\">        // 添加失败，表明已经有这个方法，直接交换</span><br><span class=\"line\">        method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)swizzled_viewDidAppear:(BOOL)animation &#123;</span><br><span class=\"line\">    [self swizzled_viewDidAppear:animation];</span><br><span class=\"line\">    NSLog(@&quot;%@ viewDidAppear&quot;, NSStringFromClass([self class]));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"扩展-——-用-Aspects-实现方法替换\"><a href=\"#扩展-——-用-Aspects-实现方法替换\" class=\"headerlink\" title=\"扩展 —— 用 Aspects 实现方法替换\"></a>扩展 —— 用 Aspects 实现方法替换</h3><p>上边 demo 中写了一大堆 runtime 的 api 在代码里，即不好阅读，也不便于维护。</p>\n<blockquote>\n<p>这里有现成的方案：一个基于 swizzling method 的开源框架 <a href=\"https://github.com/steipete/Aspects\" target=\"_blank\" rel=\"noopener\">Aspects</a> 。</p>\n</blockquote>\n<p>用 <code>Aspects</code> 来实现上文 demo 如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    People *p1 = [[People alloc] init];</span><br><span class=\"line\">    [p1 run];   </span><br><span class=\"line\">      </span><br><span class=\"line\">    [People aspect_hookSelector:@selector(run) withOptions:AspectPositionInstead usingBlock:^(id&lt;AspectInfo&gt; aspectInfo) &#123;</span><br><span class=\"line\">        NSLog(@&quot;People aspect run fast&quot;);</span><br><span class=\"line\">    &#125; error:nil];</span><br><span class=\"line\"></span><br><span class=\"line\">    [p1 run];</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-07-02 18:16:38.039 RuntimeDemo[26994:1730239] People run</span><br><span class=\"line\">2016-07-02 18:16:38.043 RuntimeDemo[26994:1730239] People aspect run fast</span><br></pre></td></tr></table></figure>\n<p>需要注意的是 <code>Aspects</code> 的 <code>aspect_hookSelector:</code> 方法中，<code>AspectOptions</code>参数决定了方法替换的时机：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef NS_OPTIONS(NSUInteger, AspectOptions) &#123;</span><br><span class=\"line\">    AspectPositionAfter   = 0,            /// 原方法调用后 (default)</span><br><span class=\"line\">    AspectPositionInstead = 1,            /// 完全替换原方法</span><br><span class=\"line\">    AspectPositionBefore  = 2,            /// 原方法调用前</span><br><span class=\"line\">    AspectOptionAutomaticRemoval = 1 &lt;&lt; 3 /// 在执行一次替换的方法后，就移除替换效果</span><br><span class=\"line\">    &#125;;</span><br></pre></td></tr></table></figure>\n<p><code>Aspects</code>帮我们封装了 <code>method swizzling</code>的过程，剩下的只管用就行了。</p>\n<p><a href=\"https://github.com/yehot/RuntimeDemo\" target=\"_blank\" rel=\"noopener\">本文 demo 代码 戳这里</a></p>\n<blockquote>\n<p>水平有限，有错误的地方，欢迎指正！</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>作为一个有2年以上 iOS 开发经验的程序猿，如果说自己不知道 runtime 简直不好意思跟别人打招呼了。</p>\n<p>但是大部分初级 iOS 程序猿在实际项目开发中，很少有机会需要主动用到 runtime 相关的东西。最近面试的不少同学，当我问”请说说你对 iOS 中 runtime 的理解”就懵逼了。</p>\n<p>其实作为小面试官，我也是很尴尬的。你简历上期望薪资都写 15k+ 了，那总不能指望面试一个小时，我都只跟你聊如何写界面吧？</p>\n<hr>\n<p>我觉得当我问面试者：</p>\n<blockquote>\n<p>“什么是 runtime ?”</p>\n</blockquote>\n<p>这个问题时，如果能在以下三个方面做个简单的阐述，我觉得就基本合格了。</p>\n<h3 id=\"一、runtime-是什么？\"><a href=\"#一、runtime-是什么？\" class=\"headerlink\" title=\"一、runtime 是什么？\"></a>一、runtime 是什么？</h3><ul>\n<li><p>首先 OC 是 C 语言的超集，因为 runtime 这个库使得C语言有了面向对象的能力：<br>OC 对象可以用C语言中的结构体表示，而方法可以用C函数来实现，这些结构体和函数被 runtime 函数封装后，我们就可以在程序运行时创建，检查，修改类、对象和它们的方法了。</p>\n</li>\n<li><p>OC 是一门动态语言，它将很多静态语言在编译和链接时期做的事放到了运行时来处理。<br>这种特性意味着Objective-C不仅需要一个编译器，还需要一个运行时系统来执行编译的代码。这个运行时系统即Objc Runtime。Objc Runtime基本上是用C和汇编写的。<br><a href=\"http://southpeak.github.io/blog/2014/10/25/objective-c-runtime-yun-xing-shi-zhi-lei-yu-dui-xiang/\" target=\"_blank\" rel=\"noopener\">参考 南峰子： Objective-C Runtime 运行时之一：类与对象</a></p>\n</li>\n</ul>\n<h3 id=\"二、runtime-有什么用？\"><a href=\"#二、runtime-有什么用？\" class=\"headerlink\" title=\"二、runtime 有什么用？\"></a>二、runtime 有什么用？</h3><ul>\n<li><p>我们写的代码在程序运行过程中都会被转化成 runtime 的C代码执行<br>OC的类、对象、方法在运行时，最终都转换成 C语言的 结构体、函数来执行。<br>   可以在程序运行时创建，检查，修改类、对象和它们的方法。</p>\n</li>\n<li><p>常用于：</p>\n<pre><code>- 获取类的方法列表/参数列表；\n- 方法调用；\n- 方法拦截、动态添加方法；\n- 方法替换： method swizzling\n- 关联对象，动态添加属性；\n</code></pre></li>\n</ul>\n<h3 id=\"三、runtime-怎么用？\"><a href=\"#三、runtime-怎么用？\" class=\"headerlink\" title=\"三、runtime 怎么用？\"></a>三、runtime 怎么用？</h3><blockquote>\n<p>或者，说说你具体在项目中哪些地方用到过 runtime ？</p>\n</blockquote>\n<ul>\n<li><p>runtime 的 API 提供了大量的函数来操作类和对象，如：</p>\n<ul>\n<li>动态替换方法的实现、方法拦截：<code>class_replaceMethod</code></li>\n<li>获取对象的属性列表：<code>class_copyIvarList</code></li>\n<li>获取对象的方法列表： <code>class_copyMethodList</code></li>\n<li>动态添加属性: <code>class_addProperty</code></li>\n<li>动态添加方法： <code>class_addMethod</code></li>\n<li>获取方法名： <code>method_getName</code></li>\n<li>获取方法的实现： <code>class_getMethodImplementation</code></li>\n</ul>\n</li>\n<li><p>具体应用：</p>\n<ul>\n<li>给 category 添加属性：<br>  <code>给 UIAlertView 加 block 回调</code></li>\n<li>给系统的方法做替换，插入代码：<br>  <code>替换 viewDidLoad 方法的实现，NSLog 出每一个出现页面的类名</code></li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"「方法替换」demo\"><a href=\"#「方法替换」demo\" class=\"headerlink\" title=\"「方法替换」demo:\"></a>「方法替换」demo:</h2><p>声明一个<code>People</code>类<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface People : NSObject</span><br><span class=\"line\">- (void)run;</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation People</span><br><span class=\"line\">- (void)run &#123;</span><br><span class=\"line\">    NSLog(@&quot;People run&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure></p>\n<p>实现替换的方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@implementation ViewController</span><br><span class=\"line\"></span><br><span class=\"line\">// demo 是在当前类直接定义了一个方法，也可以用代码动态生成一个方法</span><br><span class=\"line\">- (void)runFast &#123;</span><br><span class=\"line\">    NSLog(@&quot;People run fast&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/</span><br><span class=\"line\"> *  替换 People 类中 run 方法的实现</span><br><span class=\"line\"> */</span><br><span class=\"line\">- (void)replacePeopleRunMethod &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    Class peopleClass = NSClassFromString(@&quot;People&quot;);</span><br><span class=\"line\">    SEL peopleRunSel = @selector(run);</span><br><span class=\"line\">    Method methodRun = class_getInstanceMethod(peopleClass, peopleRunSel);</span><br><span class=\"line\">    // 获取 run 方法的参数 （包括了 parameter and return types）</span><br><span class=\"line\">    char *typeDescription = (char *)method_getTypeEncoding(methodRun);</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 获取 runFast 方法的实现</span><br><span class=\"line\">    IMP runFastImp = class_getMethodImplementation([self class], @selector(runFast));</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 给 People 新增 runFast 方法，并指向的当前类中 runFast 的实现</span><br><span class=\"line\">    class_addMethod(peopleClass, @selector(runFast), runFastImp, typeDescription);</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 替换 run 方法为 runFast 方法</span><br><span class=\"line\">    class_replaceMethod(peopleClass, peopleRunSel, runFastImp, typeDescription);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<p>调用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\"></span><br><span class=\"line\">    People *p1 = [[People alloc] init];</span><br><span class=\"line\">    [p1 run];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [self replacePeopleRunMethod];</span><br><span class=\"line\">    [p1 run];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-07-02 18:11:26.707 RuntimeDemo[26972:1726702] People run</span><br><span class=\"line\">2016-07-02 18:11:26.712 RuntimeDemo[26972:1726702] People run fast</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>注意，这里的方法替换是永久性的，只要程序不退出，以后无论在任何地方调用<code>[p1 run]</code>都只会调用<code>runFast</code>的实现。</p>\n</blockquote>\n<blockquote>\n<p>而且，method swizzling 方法并不适合写在这里，通常写在 <code>+ (void)load</code>方法中，并且用 <code>dispatch_once</code> 来进行调度。至于为什么，可以参考<a href=\"http://blog.leichunfeng.com/blog/2015/05/02/objective-c-plus-load-vs-plus-initialize/\" target=\"_blank\" rel=\"noopener\">Objective-C +load vs +initialize</a>。</p>\n</blockquote>\n<p>相关注释：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    // Method : 包含了一个方法的  方法名 + 实现 + 参数个数及类型 + 返回值个数及类型 等信息</span><br><span class=\"line\">    // class_getInstanceMethod : 通过类名 + 方法名 获取一个 Method</span><br><span class=\"line\">// class_getMethodImplementation: 类名 + 方法名</span><br><span class=\"line\">    // class_addMethod: 类名 + 方法名 + 方法实现 + 参数信息</span><br><span class=\"line\">    // class_replaceMethod : 类型 + 替换的方法名 + 替换后的实现 + 参数信息</span><br></pre></td></tr></table></figure>\n<p>以上 demo 只是简单的在当前类<code>ViewController</code>中，定义了一个<code>runFast</code>方法，并用其替换了<code>People</code> 类中<code>run</code>方法的实现。</p>\n<p>这里需要先用 <code>class_addMethod</code>，而不是直接用<code>class_replaceMethod</code>，是为了做一层保护，因为如果 <code>People</code> 类没有实现 <code>run</code> 方法 ，但其父类实现了，那 class_getInstanceMethod 会返回父类的方法。<br>     这样 method_exchangeImplementations 替换的是父类的那个方法，这当然不是你想要的。<br>     所以我们先尝试添加 <code>runFast</code>方法，如果已经存在，就用 <code>method_exchangeImplementations</code> 把原方法的实现跟新的方法实现给交换掉。否则用<code>class_replaceMethod</code>来替换。</p>\n<hr>\n<h3 id=\"「方法替换」常规写法\"><a href=\"#「方法替换」常规写法\" class=\"headerlink\" title=\"「方法替换」常规写法\"></a>「方法替换」常规写法</h3><p>上文 demo 中的写法，只是实现了方法替换的效果，但真正在项目中用的时候会存在一些问题，如调用时机、调用次数、替换失败等问题，所以，一般实战中写法如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &quot;UIViewController+Logging.h&quot;</span><br><span class=\"line\">#import &lt;objc/runtime.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation UIViewController (Logging)</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)load &#123;</span><br><span class=\"line\">    static dispatch_once_t onceToken;</span><br><span class=\"line\">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class=\"line\">        Class targetClass = [self class];</span><br><span class=\"line\">        SEL originalSelector = @selector(viewDidAppear:);</span><br><span class=\"line\">        SEL swizzledSelector = @selector(swizzled_viewDidAppear:);</span><br><span class=\"line\">        swizzleMethod(targetClass, originalSelector, swizzledSelector);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void swizzleMethod(Class class, SEL originalSelector, SEL swizzledSelector) &#123;</span><br><span class=\"line\">    Method originalMethod = class_getInstanceMethod(class, originalSelector);</span><br><span class=\"line\">    Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);</span><br><span class=\"line\">    </span><br><span class=\"line\">    IMP swizzledImp = method_getImplementation(swizzledMethod);</span><br><span class=\"line\">    char *swizzledTypes = (char *)method_getTypeEncoding(swizzledMethod);</span><br><span class=\"line\">    </span><br><span class=\"line\">    IMP originalImp = method_getImplementation(originalMethod);</span><br><span class=\"line\">    </span><br><span class=\"line\">    char *originalTypes = (char *)method_getTypeEncoding(originalMethod);</span><br><span class=\"line\">    BOOL success = class_addMethod(class, originalSelector, swizzledImp, swizzledTypes);</span><br><span class=\"line\">    if (success) &#123;</span><br><span class=\"line\">        class_replaceMethod(class, swizzledSelector, originalImp, originalTypes);</span><br><span class=\"line\">    &#125;else &#123;</span><br><span class=\"line\">        // 添加失败，表明已经有这个方法，直接交换</span><br><span class=\"line\">        method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)swizzled_viewDidAppear:(BOOL)animation &#123;</span><br><span class=\"line\">    [self swizzled_viewDidAppear:animation];</span><br><span class=\"line\">    NSLog(@&quot;%@ viewDidAppear&quot;, NSStringFromClass([self class]));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"扩展-——-用-Aspects-实现方法替换\"><a href=\"#扩展-——-用-Aspects-实现方法替换\" class=\"headerlink\" title=\"扩展 —— 用 Aspects 实现方法替换\"></a>扩展 —— 用 Aspects 实现方法替换</h3><p>上边 demo 中写了一大堆 runtime 的 api 在代码里，即不好阅读，也不便于维护。</p>\n<blockquote>\n<p>这里有现成的方案：一个基于 swizzling method 的开源框架 <a href=\"https://github.com/steipete/Aspects\" target=\"_blank\" rel=\"noopener\">Aspects</a> 。</p>\n</blockquote>\n<p>用 <code>Aspects</code> 来实现上文 demo 如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    People *p1 = [[People alloc] init];</span><br><span class=\"line\">    [p1 run];   </span><br><span class=\"line\">      </span><br><span class=\"line\">    [People aspect_hookSelector:@selector(run) withOptions:AspectPositionInstead usingBlock:^(id&lt;AspectInfo&gt; aspectInfo) &#123;</span><br><span class=\"line\">        NSLog(@&quot;People aspect run fast&quot;);</span><br><span class=\"line\">    &#125; error:nil];</span><br><span class=\"line\"></span><br><span class=\"line\">    [p1 run];</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2016-07-02 18:16:38.039 RuntimeDemo[26994:1730239] People run</span><br><span class=\"line\">2016-07-02 18:16:38.043 RuntimeDemo[26994:1730239] People aspect run fast</span><br></pre></td></tr></table></figure>\n<p>需要注意的是 <code>Aspects</code> 的 <code>aspect_hookSelector:</code> 方法中，<code>AspectOptions</code>参数决定了方法替换的时机：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef NS_OPTIONS(NSUInteger, AspectOptions) &#123;</span><br><span class=\"line\">    AspectPositionAfter   = 0,            /// 原方法调用后 (default)</span><br><span class=\"line\">    AspectPositionInstead = 1,            /// 完全替换原方法</span><br><span class=\"line\">    AspectPositionBefore  = 2,            /// 原方法调用前</span><br><span class=\"line\">    AspectOptionAutomaticRemoval = 1 &lt;&lt; 3 /// 在执行一次替换的方法后，就移除替换效果</span><br><span class=\"line\">    &#125;;</span><br></pre></td></tr></table></figure>\n<p><code>Aspects</code>帮我们封装了 <code>method swizzling</code>的过程，剩下的只管用就行了。</p>\n<p><a href=\"https://github.com/yehot/RuntimeDemo\" target=\"_blank\" rel=\"noopener\">本文 demo 代码 戳这里</a></p>\n<blockquote>\n<p>水平有限，有错误的地方，欢迎指正！</p>\n</blockquote>\n"},{"title":"新浪云搭建简单的 Node.js Web 应用","date":"2016-12-17T16:43:45.000Z","_content":"\n> 阅读本文前，需要对 node.js 、npm、常用 Git 操作、express 有基本的掌握\n\n## 一、准备工作：\n\n###  注册号新浪云账号\n\n进入 http://www.sinacloud.com/sae.html\n\n![](http://ob7o39x9f.bkt.clouddn.com/14819076463405.jpg)\n\n使用微博账号即可直接登录\n\n### 创建云应用空间\n\n> 所谓云应用空间其实就相当于一个 web 站点 + 一个有完整服务器环境的代码仓库\n\n云应用空间的创建可以参考新浪的文档：[如何创建一个云空间应用](http://www.sinacloud.com/home/index/faq_detail/doc_id/83.html)\n\n当然这里需要选择开发语言为 Node.js。\n\n\n登陆，然后进入控制台 -> 云应用SAE -> 代码管理\n\n![](http://ob7o39x9f.bkt.clouddn.com/14819077010650.jpg)\n\n![](http://ob7o39x9f.bkt.clouddn.com/14819077499116.jpg)\n\n以上步骤完成后，我们就有了一个 web 应用站点，这个站点是用来放我们的 html 页面的。准备工作做好了，接下来该配置 Node.js 服务器环境，部署 web 页面上去。\n\n## 二、Node.js 服务器配置\n\n新浪云比较方便的是，即使你对 Node.js 服务器开发没有深入接触过也没关系，新浪云的 Node.js 环境基本是傻瓜式的，即开即用。所以服务器配置，过。\n\n### node.js 简单教程\n\n安利个 [30分钟 Node.js 入门](http://www.nodebeginner.org/index-zh-cn.html) 的教程，完全没有接触过 Node.js 的同学可以快速入门一下。\n\n## 三、编写 Node.js 服务代码并部署\n\n1、先在本地创建一个代码目录，从新浪的 Git 仓库里 clone 出空项目。拉代码的过程很简单，具体可以参考 [新浪的代码部署手册](http://www.sinacloud.com/doc/sae/tutorial/code-deploy.html) 文档\n\n![](http://ob7o39x9f.bkt.clouddn.com/14819889441764.jpg)\n\n2、在本地代码路径下创建一个 server.js 文件，这里我们先使用入门教程里最简单的 Node.js 代码：\n\n```js\n// server.js\nvar http = require('http');\n\nhttp.createServer(function (request, response) {\n\n    // 发送 HTTP 头部\n    // HTTP 状态值: 200 : OK\n    // 内容类型: text/plain\n    response.writeHead(200, {'Content-Type': 'text/plain'});\n\n    // 发送响应数据 \"Hello World\"\n    response.end('Hello World\\n');\n}).listen(8888);\n\n// 终端打印如下信息\nconsole.log('Server running at http://127.0.0.1:8888/');\n\n```\n\n3、由于新浪的 Node.js 构建环境需要从 package.json 文件中读取配置信息，我们需要创建一个package.json 文件。\n\n这里我们直接使用 `npm init` 命令生成一个。 NPM 是 Node Package Manager 的缩写，也就是 Node 包管理器，类似于 iOS 开发中的 CocoaPods，而 `npm init` 就相当于`pod init`了.\n\n在 server.js 文件所在目录上，执行 `npm init`,按照命令行里的提示一步一步直接敲回车即可。\n\n![](http://ob7o39x9f.bkt.clouddn.com/14819079662795.jpg)\n\n\n4、部署\n\n这里的所谓部署 == 提交代码到新浪云 Git 服务器……\n\n所以，使用 Git 命令打 commit log，push 代码，等待云端编译即可：\n\n```c\n// 提交代码\n➜  yehot git:(master) ✗ git add .\n➜  yehot git:(master) ✗ git commit -m \"添加package.json\"\n[master a6b0d8f] 添加package.json\n 1 file changed, 20 insertions(+)\n create mode 100644 package.json\n\n// push 代码后，自动开始构建\n➜  yehot git:(master) ✗ git push sae master\nCounting objects: 3, done.\nDelta compression using up to 4 threads.\nCompressing objects: 100% (3/3), done.\nWriting objects: 100% (3/3), 377 bytes | 0 bytes/s, done.\nTotal 3 (delta 2), reused 0 (delta 0)\nremote: 导出 Git 代码中...\nremote: 构建程序中...\n-----> Node.js app detected\n\n-----> Creating runtime environment\n\n       NPM_CONFIG_LOGLEVEL=error\n       NPM_CONFIG_PRODUCTION=true\n       NODE_ENV=production\n       NODE_MODULES_CACHE=true\n\n-----> Installing binaries\n       engines.node (package.json):  unspecified\n       engines.npm (package.json):   unspecified (use default)\n\n       Resolving node version (latest stable) via semver.io...\n       Downloading and installing node 7.2.1...\n       Using default npm version: 3.10.10\n\n-----> Restoring cache\n       Loading 2 from cacheDirectories (default):\n       - node_modules\n       - bower_components (not cached - skipping)\n       - nodegyp_lib (not cached - skipping)\n\n-----> Building dependencies\n       Pruning any extraneous modules\n       Installing node modules (package.json)\n       yehot@1.0.0 /tmp/build\n       `-- formidable@1.0.17\n\n\n-----> Caching build\n       Clearing previous node cache\n       Saving 2 cacheDirectories (default):\n       - node_modules\n       - bower_components (nothing to cache)\n       - nodegyp_lib (nothing to cache)\n\n-----> Build succeeded!\n       `-- formidable@1.0.17\n\n-----> Discovering process types\n       Default types for  -> web\n-----> Compiled slug size is 16M\nremote: Generating docker image...\nremote: Pushing image registry.docker.sae.sina.com.cn/yehot:c72c679 .....\nremote: 部署程序中 .....\nTo https://git.sinacloud.com/yehot\n   a6b0d8f..c72c679  master -> master\n\n```\n\n到这里构建成功，就算部署成功了。这时我们的 Hello world 页面就可以在你的新浪云 Web 站点看到了：\n\n![](http://ob7o39x9f.bkt.clouddn.com/14819134008404.jpg)\n\n站点地址可以从这里查看到：\n\n![](http://ob7o39x9f.bkt.clouddn.com/14819900207625.jpg)\n\n\n## 四、部署 html 页面\n\n1、懒得自己写个页面了，直接用一个网站模板：[40 个 Bootstrap 网站模板](https://www.oschina.net/news/59924/free-bootstrap-templates) ,随便选一个，把代码压缩包 down 下来\n\n2、解压，将代码网站模板全部文件拷贝到我们的刚创建的本地 Node 仓库目录里。\n\n3、这次我们就不是简单的响应个 hello world 的，需要将 html 文本作为页面 send 出去。这里直接使用 node.js 流行框架 `Express` 帮我们完成这件事。\n\n首先在代码目录路径下执行命令：\n\n```\nnpm install express --save\n```\n\n这样会在 package.json 中，生成一条依赖信息：\n\n![](http://ob7o39x9f.bkt.clouddn.com/14819895856109.jpg)\n\n同时，会将 express 的源码从 npm 仓库中拉下来到本地自动生成的 node_modules 目录中。此时目录结构如下：\n\n![](http://ob7o39x9f.bkt.clouddn.com/14819914963002.jpg)\n\n4、改造 server.js 代码\n\n工具准备好了，开始使用：\n\n```js\n// server.js\n\nvar express = require('express')\nvar app = express()\n\n// 静态 html 页面，需要将当前目录下的所有文件都设置为 static\napp.use(express.static(__dirname + '/'));\n\napp.get('/', function (req, res) {\n    console.log('start server');\n    // sendFile 函数，在有 request 访问时，将当前目录下的 index.html 文件作为 response 返回\n    res.sendFile(__dirname + '/index.html');\n    console.log('start success');\n})\n\n// 监听 8000 端口\napp.listen(process.env.PORT || 8000)\n```\n\n5、Ok，再次 commit log、push ，等待编译\n\n编译完成后，刷新我们的站点，就能看到一个漂亮的 html 页面了：\n\n![](http://ob7o39x9f.bkt.clouddn.com/14819919635022.jpg)\n\nbootstrap 是 Twitter 开源的强大的响应式布局框架，已经帮我们做好了移动端浏览器的适配工作，可以在手机浏览器上访问下试试，效果还是挺不错的。\n\n## 五、作为服务器接口使用\n\n目前我们的 Node 服务，已经成功部署了一个简单的 web 应用。\n\n我们可以在 iOS 端通过 get 请求访问下我们的站点 `http://xxx.applinzi.com` 试试，以 AFNetworkign 为例：\n\n```ObjC\nAFHTTPSessionManager *sessionManager = [AFHTTPSessionManager manager];\n\nsessionManager.responseSerializer = [AFHTTPResponseSerializer serializer];\n\nsessionManager.responseSerializer.acceptableContentTypes = [NSSet setWithObject:@\"text/html\"];\n\n\nsessionManager.responseSerializer.acceptableContentTypes = [NSSet setWithObject:@\"text/html\"];\n\n[sessionManager GET:@\"http://yehot.applinzi.com/index.html\" parameters:nil progress:nil\n\nsuccess:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {\n\nNSLog(@\"%@\",responseObject);\n\n} failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {\n\nNSLog(@\"%@\",error);\n\n}];\n\n```\n\n## 六、其它\n\n###  新浪云控制台使用\n\n1、查看操作记录\n![](http://ob7o39x9f.bkt.clouddn.com/14819090622798.jpg)\n\n2、注册会送 200 云豆 == 2元\n\n没有额外流量消耗的话，每天默认扣 10 个豆\n\n![](http://ob7o39x9f.bkt.clouddn.com/14819091585001.jpg)\n\n如果欠费后显示\n\n![](http://ob7o39x9f.bkt.clouddn.com/14819093138228.jpg)\n\n3、查看日志、重启\n\n![](http://ob7o39x9f.bkt.clouddn.com/14819095502076.jpg)\n\n\n### 最后，新浪是有 node 应用的部署指南的\n\n上边这些坑，整整折腾了我5个小时后，我才发现这个：\n\n[新浪 node 应用部署指南](https://www.sinacloud.com/doc/sae/docker/nodejs-getting-started.html)\n\n不说了，都是泪。当然使用 Python、PHP 也可以查看对应的文档\nhttps://www.sinacloud.com/index/support.html\n\n\n## 参考：\n\n[在新浪云上用php+mysql搭建简单后台系列](http://www.jianshu.com/p/325288166a59)\n\n\n","source":"_posts/20161218-sina-sae-node-js-web-tutorial.md","raw":"---\ntitle: 新浪云搭建简单的 Node.js Web 应用\ndate: 2016-12-18 00:43:45\ntags: node.js\ncategories: Node.js\n---\n\n> 阅读本文前，需要对 node.js 、npm、常用 Git 操作、express 有基本的掌握\n\n## 一、准备工作：\n\n###  注册号新浪云账号\n\n进入 http://www.sinacloud.com/sae.html\n\n![](http://ob7o39x9f.bkt.clouddn.com/14819076463405.jpg)\n\n使用微博账号即可直接登录\n\n### 创建云应用空间\n\n> 所谓云应用空间其实就相当于一个 web 站点 + 一个有完整服务器环境的代码仓库\n\n云应用空间的创建可以参考新浪的文档：[如何创建一个云空间应用](http://www.sinacloud.com/home/index/faq_detail/doc_id/83.html)\n\n当然这里需要选择开发语言为 Node.js。\n\n\n登陆，然后进入控制台 -> 云应用SAE -> 代码管理\n\n![](http://ob7o39x9f.bkt.clouddn.com/14819077010650.jpg)\n\n![](http://ob7o39x9f.bkt.clouddn.com/14819077499116.jpg)\n\n以上步骤完成后，我们就有了一个 web 应用站点，这个站点是用来放我们的 html 页面的。准备工作做好了，接下来该配置 Node.js 服务器环境，部署 web 页面上去。\n\n## 二、Node.js 服务器配置\n\n新浪云比较方便的是，即使你对 Node.js 服务器开发没有深入接触过也没关系，新浪云的 Node.js 环境基本是傻瓜式的，即开即用。所以服务器配置，过。\n\n### node.js 简单教程\n\n安利个 [30分钟 Node.js 入门](http://www.nodebeginner.org/index-zh-cn.html) 的教程，完全没有接触过 Node.js 的同学可以快速入门一下。\n\n## 三、编写 Node.js 服务代码并部署\n\n1、先在本地创建一个代码目录，从新浪的 Git 仓库里 clone 出空项目。拉代码的过程很简单，具体可以参考 [新浪的代码部署手册](http://www.sinacloud.com/doc/sae/tutorial/code-deploy.html) 文档\n\n![](http://ob7o39x9f.bkt.clouddn.com/14819889441764.jpg)\n\n2、在本地代码路径下创建一个 server.js 文件，这里我们先使用入门教程里最简单的 Node.js 代码：\n\n```js\n// server.js\nvar http = require('http');\n\nhttp.createServer(function (request, response) {\n\n    // 发送 HTTP 头部\n    // HTTP 状态值: 200 : OK\n    // 内容类型: text/plain\n    response.writeHead(200, {'Content-Type': 'text/plain'});\n\n    // 发送响应数据 \"Hello World\"\n    response.end('Hello World\\n');\n}).listen(8888);\n\n// 终端打印如下信息\nconsole.log('Server running at http://127.0.0.1:8888/');\n\n```\n\n3、由于新浪的 Node.js 构建环境需要从 package.json 文件中读取配置信息，我们需要创建一个package.json 文件。\n\n这里我们直接使用 `npm init` 命令生成一个。 NPM 是 Node Package Manager 的缩写，也就是 Node 包管理器，类似于 iOS 开发中的 CocoaPods，而 `npm init` 就相当于`pod init`了.\n\n在 server.js 文件所在目录上，执行 `npm init`,按照命令行里的提示一步一步直接敲回车即可。\n\n![](http://ob7o39x9f.bkt.clouddn.com/14819079662795.jpg)\n\n\n4、部署\n\n这里的所谓部署 == 提交代码到新浪云 Git 服务器……\n\n所以，使用 Git 命令打 commit log，push 代码，等待云端编译即可：\n\n```c\n// 提交代码\n➜  yehot git:(master) ✗ git add .\n➜  yehot git:(master) ✗ git commit -m \"添加package.json\"\n[master a6b0d8f] 添加package.json\n 1 file changed, 20 insertions(+)\n create mode 100644 package.json\n\n// push 代码后，自动开始构建\n➜  yehot git:(master) ✗ git push sae master\nCounting objects: 3, done.\nDelta compression using up to 4 threads.\nCompressing objects: 100% (3/3), done.\nWriting objects: 100% (3/3), 377 bytes | 0 bytes/s, done.\nTotal 3 (delta 2), reused 0 (delta 0)\nremote: 导出 Git 代码中...\nremote: 构建程序中...\n-----> Node.js app detected\n\n-----> Creating runtime environment\n\n       NPM_CONFIG_LOGLEVEL=error\n       NPM_CONFIG_PRODUCTION=true\n       NODE_ENV=production\n       NODE_MODULES_CACHE=true\n\n-----> Installing binaries\n       engines.node (package.json):  unspecified\n       engines.npm (package.json):   unspecified (use default)\n\n       Resolving node version (latest stable) via semver.io...\n       Downloading and installing node 7.2.1...\n       Using default npm version: 3.10.10\n\n-----> Restoring cache\n       Loading 2 from cacheDirectories (default):\n       - node_modules\n       - bower_components (not cached - skipping)\n       - nodegyp_lib (not cached - skipping)\n\n-----> Building dependencies\n       Pruning any extraneous modules\n       Installing node modules (package.json)\n       yehot@1.0.0 /tmp/build\n       `-- formidable@1.0.17\n\n\n-----> Caching build\n       Clearing previous node cache\n       Saving 2 cacheDirectories (default):\n       - node_modules\n       - bower_components (nothing to cache)\n       - nodegyp_lib (nothing to cache)\n\n-----> Build succeeded!\n       `-- formidable@1.0.17\n\n-----> Discovering process types\n       Default types for  -> web\n-----> Compiled slug size is 16M\nremote: Generating docker image...\nremote: Pushing image registry.docker.sae.sina.com.cn/yehot:c72c679 .....\nremote: 部署程序中 .....\nTo https://git.sinacloud.com/yehot\n   a6b0d8f..c72c679  master -> master\n\n```\n\n到这里构建成功，就算部署成功了。这时我们的 Hello world 页面就可以在你的新浪云 Web 站点看到了：\n\n![](http://ob7o39x9f.bkt.clouddn.com/14819134008404.jpg)\n\n站点地址可以从这里查看到：\n\n![](http://ob7o39x9f.bkt.clouddn.com/14819900207625.jpg)\n\n\n## 四、部署 html 页面\n\n1、懒得自己写个页面了，直接用一个网站模板：[40 个 Bootstrap 网站模板](https://www.oschina.net/news/59924/free-bootstrap-templates) ,随便选一个，把代码压缩包 down 下来\n\n2、解压，将代码网站模板全部文件拷贝到我们的刚创建的本地 Node 仓库目录里。\n\n3、这次我们就不是简单的响应个 hello world 的，需要将 html 文本作为页面 send 出去。这里直接使用 node.js 流行框架 `Express` 帮我们完成这件事。\n\n首先在代码目录路径下执行命令：\n\n```\nnpm install express --save\n```\n\n这样会在 package.json 中，生成一条依赖信息：\n\n![](http://ob7o39x9f.bkt.clouddn.com/14819895856109.jpg)\n\n同时，会将 express 的源码从 npm 仓库中拉下来到本地自动生成的 node_modules 目录中。此时目录结构如下：\n\n![](http://ob7o39x9f.bkt.clouddn.com/14819914963002.jpg)\n\n4、改造 server.js 代码\n\n工具准备好了，开始使用：\n\n```js\n// server.js\n\nvar express = require('express')\nvar app = express()\n\n// 静态 html 页面，需要将当前目录下的所有文件都设置为 static\napp.use(express.static(__dirname + '/'));\n\napp.get('/', function (req, res) {\n    console.log('start server');\n    // sendFile 函数，在有 request 访问时，将当前目录下的 index.html 文件作为 response 返回\n    res.sendFile(__dirname + '/index.html');\n    console.log('start success');\n})\n\n// 监听 8000 端口\napp.listen(process.env.PORT || 8000)\n```\n\n5、Ok，再次 commit log、push ，等待编译\n\n编译完成后，刷新我们的站点，就能看到一个漂亮的 html 页面了：\n\n![](http://ob7o39x9f.bkt.clouddn.com/14819919635022.jpg)\n\nbootstrap 是 Twitter 开源的强大的响应式布局框架，已经帮我们做好了移动端浏览器的适配工作，可以在手机浏览器上访问下试试，效果还是挺不错的。\n\n## 五、作为服务器接口使用\n\n目前我们的 Node 服务，已经成功部署了一个简单的 web 应用。\n\n我们可以在 iOS 端通过 get 请求访问下我们的站点 `http://xxx.applinzi.com` 试试，以 AFNetworkign 为例：\n\n```ObjC\nAFHTTPSessionManager *sessionManager = [AFHTTPSessionManager manager];\n\nsessionManager.responseSerializer = [AFHTTPResponseSerializer serializer];\n\nsessionManager.responseSerializer.acceptableContentTypes = [NSSet setWithObject:@\"text/html\"];\n\n\nsessionManager.responseSerializer.acceptableContentTypes = [NSSet setWithObject:@\"text/html\"];\n\n[sessionManager GET:@\"http://yehot.applinzi.com/index.html\" parameters:nil progress:nil\n\nsuccess:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {\n\nNSLog(@\"%@\",responseObject);\n\n} failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {\n\nNSLog(@\"%@\",error);\n\n}];\n\n```\n\n## 六、其它\n\n###  新浪云控制台使用\n\n1、查看操作记录\n![](http://ob7o39x9f.bkt.clouddn.com/14819090622798.jpg)\n\n2、注册会送 200 云豆 == 2元\n\n没有额外流量消耗的话，每天默认扣 10 个豆\n\n![](http://ob7o39x9f.bkt.clouddn.com/14819091585001.jpg)\n\n如果欠费后显示\n\n![](http://ob7o39x9f.bkt.clouddn.com/14819093138228.jpg)\n\n3、查看日志、重启\n\n![](http://ob7o39x9f.bkt.clouddn.com/14819095502076.jpg)\n\n\n### 最后，新浪是有 node 应用的部署指南的\n\n上边这些坑，整整折腾了我5个小时后，我才发现这个：\n\n[新浪 node 应用部署指南](https://www.sinacloud.com/doc/sae/docker/nodejs-getting-started.html)\n\n不说了，都是泪。当然使用 Python、PHP 也可以查看对应的文档\nhttps://www.sinacloud.com/index/support.html\n\n\n## 参考：\n\n[在新浪云上用php+mysql搭建简单后台系列](http://www.jianshu.com/p/325288166a59)\n\n\n","slug":"20161218-sina-sae-node-js-web-tutorial","published":1,"updated":"2019-04-18T11:06:48.750Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjumvmxac0012raxeuys0n56i","content":"<blockquote>\n<p>阅读本文前，需要对 node.js 、npm、常用 Git 操作、express 有基本的掌握</p>\n</blockquote>\n<h2 id=\"一、准备工作：\"><a href=\"#一、准备工作：\" class=\"headerlink\" title=\"一、准备工作：\"></a>一、准备工作：</h2><h3 id=\"注册号新浪云账号\"><a href=\"#注册号新浪云账号\" class=\"headerlink\" title=\"注册号新浪云账号\"></a>注册号新浪云账号</h3><p>进入 <a href=\"http://www.sinacloud.com/sae.html\" target=\"_blank\" rel=\"noopener\">http://www.sinacloud.com/sae.html</a></p>\n<p><img src=\"http://ob7o39x9f.bkt.clouddn.com/14819076463405.jpg\" alt></p>\n<p>使用微博账号即可直接登录</p>\n<h3 id=\"创建云应用空间\"><a href=\"#创建云应用空间\" class=\"headerlink\" title=\"创建云应用空间\"></a>创建云应用空间</h3><blockquote>\n<p>所谓云应用空间其实就相当于一个 web 站点 + 一个有完整服务器环境的代码仓库</p>\n</blockquote>\n<p>云应用空间的创建可以参考新浪的文档：<a href=\"http://www.sinacloud.com/home/index/faq_detail/doc_id/83.html\" target=\"_blank\" rel=\"noopener\">如何创建一个云空间应用</a></p>\n<p>当然这里需要选择开发语言为 Node.js。</p>\n<p>登陆，然后进入控制台 -&gt; 云应用SAE -&gt; 代码管理</p>\n<p><img src=\"http://ob7o39x9f.bkt.clouddn.com/14819077010650.jpg\" alt></p>\n<p><img src=\"http://ob7o39x9f.bkt.clouddn.com/14819077499116.jpg\" alt></p>\n<p>以上步骤完成后，我们就有了一个 web 应用站点，这个站点是用来放我们的 html 页面的。准备工作做好了，接下来该配置 Node.js 服务器环境，部署 web 页面上去。</p>\n<h2 id=\"二、Node-js-服务器配置\"><a href=\"#二、Node-js-服务器配置\" class=\"headerlink\" title=\"二、Node.js 服务器配置\"></a>二、Node.js 服务器配置</h2><p>新浪云比较方便的是，即使你对 Node.js 服务器开发没有深入接触过也没关系，新浪云的 Node.js 环境基本是傻瓜式的，即开即用。所以服务器配置，过。</p>\n<h3 id=\"node-js-简单教程\"><a href=\"#node-js-简单教程\" class=\"headerlink\" title=\"node.js 简单教程\"></a>node.js 简单教程</h3><p>安利个 <a href=\"http://www.nodebeginner.org/index-zh-cn.html\" target=\"_blank\" rel=\"noopener\">30分钟 Node.js 入门</a> 的教程，完全没有接触过 Node.js 的同学可以快速入门一下。</p>\n<h2 id=\"三、编写-Node-js-服务代码并部署\"><a href=\"#三、编写-Node-js-服务代码并部署\" class=\"headerlink\" title=\"三、编写 Node.js 服务代码并部署\"></a>三、编写 Node.js 服务代码并部署</h2><p>1、先在本地创建一个代码目录，从新浪的 Git 仓库里 clone 出空项目。拉代码的过程很简单，具体可以参考 <a href=\"http://www.sinacloud.com/doc/sae/tutorial/code-deploy.html\" target=\"_blank\" rel=\"noopener\">新浪的代码部署手册</a> 文档</p>\n<p><img src=\"http://ob7o39x9f.bkt.clouddn.com/14819889441764.jpg\" alt></p>\n<p>2、在本地代码路径下创建一个 server.js 文件，这里我们先使用入门教程里最简单的 Node.js 代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// server.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">http.createServer(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">request, response</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 发送 HTTP 头部</span></span><br><span class=\"line\">    <span class=\"comment\">// HTTP 状态值: 200 : OK</span></span><br><span class=\"line\">    <span class=\"comment\">// 内容类型: text/plain</span></span><br><span class=\"line\">    response.writeHead(<span class=\"number\">200</span>, &#123;<span class=\"string\">'Content-Type'</span>: <span class=\"string\">'text/plain'</span>&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 发送响应数据 \"Hello World\"</span></span><br><span class=\"line\">    response.end(<span class=\"string\">'Hello World\\n'</span>);</span><br><span class=\"line\">&#125;).listen(<span class=\"number\">8888</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 终端打印如下信息</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'Server running at http://127.0.0.1:8888/'</span>);</span><br></pre></td></tr></table></figure>\n<p>3、由于新浪的 Node.js 构建环境需要从 package.json 文件中读取配置信息，我们需要创建一个package.json 文件。</p>\n<p>这里我们直接使用 <code>npm init</code> 命令生成一个。 NPM 是 Node Package Manager 的缩写，也就是 Node 包管理器，类似于 iOS 开发中的 CocoaPods，而 <code>npm init</code> 就相当于<code>pod init</code>了.</p>\n<p>在 server.js 文件所在目录上，执行 <code>npm init</code>,按照命令行里的提示一步一步直接敲回车即可。</p>\n<p><img src=\"http://ob7o39x9f.bkt.clouddn.com/14819079662795.jpg\" alt></p>\n<p>4、部署</p>\n<p>这里的所谓部署 == 提交代码到新浪云 Git 服务器……</p>\n<p>所以，使用 Git 命令打 commit log，push 代码，等待云端编译即可：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 提交代码</span></span><br><span class=\"line\">➜  yehot git:(master) ✗ git add .</span><br><span class=\"line\">➜  yehot git:(master) ✗ git commit -m <span class=\"string\">\"添加package.json\"</span></span><br><span class=\"line\">[master a6b0d8f] 添加package.json</span><br><span class=\"line\"> <span class=\"number\">1</span> file changed, <span class=\"number\">20</span> insertions(+)</span><br><span class=\"line\"> create mode <span class=\"number\">100644</span> package.json</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// push 代码后，自动开始构建</span></span><br><span class=\"line\">➜  yehot git:(master) ✗ git push sae master</span><br><span class=\"line\">Counting objects: <span class=\"number\">3</span>, done.</span><br><span class=\"line\">Delta compression <span class=\"keyword\">using</span> up to <span class=\"number\">4</span> threads.</span><br><span class=\"line\">Compressing objects: <span class=\"number\">100</span>% (<span class=\"number\">3</span>/<span class=\"number\">3</span>), done.</span><br><span class=\"line\">Writing objects: <span class=\"number\">100</span>% (<span class=\"number\">3</span>/<span class=\"number\">3</span>), <span class=\"number\">377</span> bytes | <span class=\"number\">0</span> bytes/s, done.</span><br><span class=\"line\">Total <span class=\"number\">3</span> (delta <span class=\"number\">2</span>), reused <span class=\"number\">0</span> (delta <span class=\"number\">0</span>)</span><br><span class=\"line\">remote: 导出 Git 代码中...</span><br><span class=\"line\">remote: 构建程序中...</span><br><span class=\"line\">-----&gt; Node.js app detected</span><br><span class=\"line\"></span><br><span class=\"line\">-----&gt; Creating runtime environment</span><br><span class=\"line\"></span><br><span class=\"line\">       NPM_CONFIG_LOGLEVEL=error</span><br><span class=\"line\">       NPM_CONFIG_PRODUCTION=<span class=\"literal\">true</span></span><br><span class=\"line\">       NODE_ENV=production</span><br><span class=\"line\">       NODE_MODULES_CACHE=<span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\">-----&gt; Installing binaries</span><br><span class=\"line\">       engines.node (package.json):  unspecified</span><br><span class=\"line\">       engines.npm (package.json):   unspecified (use <span class=\"keyword\">default</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">       Resolving node version (latest stable) via semver.io...</span><br><span class=\"line\">       Downloading <span class=\"keyword\">and</span> installing node <span class=\"number\">7.2</span><span class=\"number\">.1</span>...</span><br><span class=\"line\">       Using <span class=\"keyword\">default</span> npm version: <span class=\"number\">3.10</span><span class=\"number\">.10</span></span><br><span class=\"line\"></span><br><span class=\"line\">-----&gt; Restoring cache</span><br><span class=\"line\">       Loading <span class=\"number\">2</span> from cacheDirectories (<span class=\"keyword\">default</span>):</span><br><span class=\"line\">       - node_modules</span><br><span class=\"line\">       - bower_components (<span class=\"keyword\">not</span> cached - skipping)</span><br><span class=\"line\">       - nodegyp_lib (<span class=\"keyword\">not</span> cached - skipping)</span><br><span class=\"line\"></span><br><span class=\"line\">-----&gt; Building dependencies</span><br><span class=\"line\">       Pruning any extraneous modules</span><br><span class=\"line\">       Installing node modules (package.json)</span><br><span class=\"line\">       yehot@<span class=\"number\">1.0</span><span class=\"number\">.0</span> /tmp/build</span><br><span class=\"line\">       `-- formidable@<span class=\"number\">1.0</span><span class=\"number\">.17</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">-----&gt; Caching build</span><br><span class=\"line\">       Clearing previous node cache</span><br><span class=\"line\">       Saving <span class=\"number\">2</span> cacheDirectories (<span class=\"keyword\">default</span>):</span><br><span class=\"line\">       - node_modules</span><br><span class=\"line\">       - bower_components (nothing to cache)</span><br><span class=\"line\">       - nodegyp_lib (nothing to cache)</span><br><span class=\"line\"></span><br><span class=\"line\">-----&gt; Build succeeded!</span><br><span class=\"line\">       `-- formidable@<span class=\"number\">1.0</span><span class=\"number\">.17</span></span><br><span class=\"line\"></span><br><span class=\"line\">-----&gt; Discovering process types</span><br><span class=\"line\">       Default types <span class=\"keyword\">for</span>  -&gt; web</span><br><span class=\"line\">-----&gt; Compiled slug size is <span class=\"number\">16</span>M</span><br><span class=\"line\">remote: Generating docker image...</span><br><span class=\"line\">remote: Pushing image registry.docker.sae.sina.com.cn/yehot:c72c679 .....</span><br><span class=\"line\">remote: 部署程序中 .....</span><br><span class=\"line\">To https:<span class=\"comment\">//git.sinacloud.com/yehot</span></span><br><span class=\"line\">   a6b0d8f..c72c679  master -&gt; master</span><br></pre></td></tr></table></figure>\n<p>到这里构建成功，就算部署成功了。这时我们的 Hello world 页面就可以在你的新浪云 Web 站点看到了：</p>\n<p><img src=\"http://ob7o39x9f.bkt.clouddn.com/14819134008404.jpg\" alt></p>\n<p>站点地址可以从这里查看到：</p>\n<p><img src=\"http://ob7o39x9f.bkt.clouddn.com/14819900207625.jpg\" alt></p>\n<h2 id=\"四、部署-html-页面\"><a href=\"#四、部署-html-页面\" class=\"headerlink\" title=\"四、部署 html 页面\"></a>四、部署 html 页面</h2><p>1、懒得自己写个页面了，直接用一个网站模板：<a href=\"https://www.oschina.net/news/59924/free-bootstrap-templates\" target=\"_blank\" rel=\"noopener\">40 个 Bootstrap 网站模板</a> ,随便选一个，把代码压缩包 down 下来</p>\n<p>2、解压，将代码网站模板全部文件拷贝到我们的刚创建的本地 Node 仓库目录里。</p>\n<p>3、这次我们就不是简单的响应个 hello world 的，需要将 html 文本作为页面 send 出去。这里直接使用 node.js 流行框架 <code>Express</code> 帮我们完成这件事。</p>\n<p>首先在代码目录路径下执行命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install express --save</span><br></pre></td></tr></table></figure>\n<p>这样会在 package.json 中，生成一条依赖信息：</p>\n<p><img src=\"http://ob7o39x9f.bkt.clouddn.com/14819895856109.jpg\" alt></p>\n<p>同时，会将 express 的源码从 npm 仓库中拉下来到本地自动生成的 node_modules 目录中。此时目录结构如下：</p>\n<p><img src=\"http://ob7o39x9f.bkt.clouddn.com/14819914963002.jpg\" alt></p>\n<p>4、改造 server.js 代码</p>\n<p>工具准备好了，开始使用：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// server.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> app = express()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 静态 html 页面，需要将当前目录下的所有文件都设置为 static</span></span><br><span class=\"line\">app.use(express.static(__dirname + <span class=\"string\">'/'</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">app.get(<span class=\"string\">'/'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'start server'</span>);</span><br><span class=\"line\">    <span class=\"comment\">// sendFile 函数，在有 request 访问时，将当前目录下的 index.html 文件作为 response 返回</span></span><br><span class=\"line\">    res.sendFile(__dirname + <span class=\"string\">'/index.html'</span>);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'start success'</span>);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 监听 8000 端口</span></span><br><span class=\"line\">app.listen(process.env.PORT || <span class=\"number\">8000</span>)</span><br></pre></td></tr></table></figure>\n<p>5、Ok，再次 commit log、push ，等待编译</p>\n<p>编译完成后，刷新我们的站点，就能看到一个漂亮的 html 页面了：</p>\n<p><img src=\"http://ob7o39x9f.bkt.clouddn.com/14819919635022.jpg\" alt></p>\n<p>bootstrap 是 Twitter 开源的强大的响应式布局框架，已经帮我们做好了移动端浏览器的适配工作，可以在手机浏览器上访问下试试，效果还是挺不错的。</p>\n<h2 id=\"五、作为服务器接口使用\"><a href=\"#五、作为服务器接口使用\" class=\"headerlink\" title=\"五、作为服务器接口使用\"></a>五、作为服务器接口使用</h2><p>目前我们的 Node 服务，已经成功部署了一个简单的 web 应用。</p>\n<p>我们可以在 iOS 端通过 get 请求访问下我们的站点 <code>http://xxx.applinzi.com</code> 试试，以 AFNetworkign 为例：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AFHTTPSessionManager *sessionManager = [AFHTTPSessionManager manager];</span><br><span class=\"line\"></span><br><span class=\"line\">sessionManager.responseSerializer = [AFHTTPResponseSerializer serializer];</span><br><span class=\"line\"></span><br><span class=\"line\">sessionManager.responseSerializer.acceptableContentTypes = [<span class=\"built_in\">NSSet</span> setWithObject:<span class=\"string\">@\"text/html\"</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">sessionManager.responseSerializer.acceptableContentTypes = [<span class=\"built_in\">NSSet</span> setWithObject:<span class=\"string\">@\"text/html\"</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">[sessionManager GET:<span class=\"string\">@\"http://yehot.applinzi.com/index.html\"</span> parameters:<span class=\"literal\">nil</span> progress:<span class=\"literal\">nil</span></span><br><span class=\"line\"></span><br><span class=\"line\">success:^(<span class=\"built_in\">NSURLSessionDataTask</span> * _Nonnull task, <span class=\"keyword\">id</span>  _Nullable responseObject) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>,responseObject);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; failure:^(<span class=\"built_in\">NSURLSessionDataTask</span> * _Nullable task, <span class=\"built_in\">NSError</span> * _Nonnull error) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>,error);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n<h2 id=\"六、其它\"><a href=\"#六、其它\" class=\"headerlink\" title=\"六、其它\"></a>六、其它</h2><h3 id=\"新浪云控制台使用\"><a href=\"#新浪云控制台使用\" class=\"headerlink\" title=\"新浪云控制台使用\"></a>新浪云控制台使用</h3><p>1、查看操作记录<br><img src=\"http://ob7o39x9f.bkt.clouddn.com/14819090622798.jpg\" alt></p>\n<p>2、注册会送 200 云豆 == 2元</p>\n<p>没有额外流量消耗的话，每天默认扣 10 个豆</p>\n<p><img src=\"http://ob7o39x9f.bkt.clouddn.com/14819091585001.jpg\" alt></p>\n<p>如果欠费后显示</p>\n<p><img src=\"http://ob7o39x9f.bkt.clouddn.com/14819093138228.jpg\" alt></p>\n<p>3、查看日志、重启</p>\n<p><img src=\"http://ob7o39x9f.bkt.clouddn.com/14819095502076.jpg\" alt></p>\n<h3 id=\"最后，新浪是有-node-应用的部署指南的\"><a href=\"#最后，新浪是有-node-应用的部署指南的\" class=\"headerlink\" title=\"最后，新浪是有 node 应用的部署指南的\"></a>最后，新浪是有 node 应用的部署指南的</h3><p>上边这些坑，整整折腾了我5个小时后，我才发现这个：</p>\n<p><a href=\"https://www.sinacloud.com/doc/sae/docker/nodejs-getting-started.html\" target=\"_blank\" rel=\"noopener\">新浪 node 应用部署指南</a></p>\n<p>不说了，都是泪。当然使用 Python、PHP 也可以查看对应的文档<br><a href=\"https://www.sinacloud.com/index/support.html\" target=\"_blank\" rel=\"noopener\">https://www.sinacloud.com/index/support.html</a></p>\n<h2 id=\"参考：\"><a href=\"#参考：\" class=\"headerlink\" title=\"参考：\"></a>参考：</h2><p><a href=\"http://www.jianshu.com/p/325288166a59\" target=\"_blank\" rel=\"noopener\">在新浪云上用php+mysql搭建简单后台系列</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>阅读本文前，需要对 node.js 、npm、常用 Git 操作、express 有基本的掌握</p>\n</blockquote>\n<h2 id=\"一、准备工作：\"><a href=\"#一、准备工作：\" class=\"headerlink\" title=\"一、准备工作：\"></a>一、准备工作：</h2><h3 id=\"注册号新浪云账号\"><a href=\"#注册号新浪云账号\" class=\"headerlink\" title=\"注册号新浪云账号\"></a>注册号新浪云账号</h3><p>进入 <a href=\"http://www.sinacloud.com/sae.html\" target=\"_blank\" rel=\"noopener\">http://www.sinacloud.com/sae.html</a></p>\n<p><img src=\"http://ob7o39x9f.bkt.clouddn.com/14819076463405.jpg\" alt></p>\n<p>使用微博账号即可直接登录</p>\n<h3 id=\"创建云应用空间\"><a href=\"#创建云应用空间\" class=\"headerlink\" title=\"创建云应用空间\"></a>创建云应用空间</h3><blockquote>\n<p>所谓云应用空间其实就相当于一个 web 站点 + 一个有完整服务器环境的代码仓库</p>\n</blockquote>\n<p>云应用空间的创建可以参考新浪的文档：<a href=\"http://www.sinacloud.com/home/index/faq_detail/doc_id/83.html\" target=\"_blank\" rel=\"noopener\">如何创建一个云空间应用</a></p>\n<p>当然这里需要选择开发语言为 Node.js。</p>\n<p>登陆，然后进入控制台 -&gt; 云应用SAE -&gt; 代码管理</p>\n<p><img src=\"http://ob7o39x9f.bkt.clouddn.com/14819077010650.jpg\" alt></p>\n<p><img src=\"http://ob7o39x9f.bkt.clouddn.com/14819077499116.jpg\" alt></p>\n<p>以上步骤完成后，我们就有了一个 web 应用站点，这个站点是用来放我们的 html 页面的。准备工作做好了，接下来该配置 Node.js 服务器环境，部署 web 页面上去。</p>\n<h2 id=\"二、Node-js-服务器配置\"><a href=\"#二、Node-js-服务器配置\" class=\"headerlink\" title=\"二、Node.js 服务器配置\"></a>二、Node.js 服务器配置</h2><p>新浪云比较方便的是，即使你对 Node.js 服务器开发没有深入接触过也没关系，新浪云的 Node.js 环境基本是傻瓜式的，即开即用。所以服务器配置，过。</p>\n<h3 id=\"node-js-简单教程\"><a href=\"#node-js-简单教程\" class=\"headerlink\" title=\"node.js 简单教程\"></a>node.js 简单教程</h3><p>安利个 <a href=\"http://www.nodebeginner.org/index-zh-cn.html\" target=\"_blank\" rel=\"noopener\">30分钟 Node.js 入门</a> 的教程，完全没有接触过 Node.js 的同学可以快速入门一下。</p>\n<h2 id=\"三、编写-Node-js-服务代码并部署\"><a href=\"#三、编写-Node-js-服务代码并部署\" class=\"headerlink\" title=\"三、编写 Node.js 服务代码并部署\"></a>三、编写 Node.js 服务代码并部署</h2><p>1、先在本地创建一个代码目录，从新浪的 Git 仓库里 clone 出空项目。拉代码的过程很简单，具体可以参考 <a href=\"http://www.sinacloud.com/doc/sae/tutorial/code-deploy.html\" target=\"_blank\" rel=\"noopener\">新浪的代码部署手册</a> 文档</p>\n<p><img src=\"http://ob7o39x9f.bkt.clouddn.com/14819889441764.jpg\" alt></p>\n<p>2、在本地代码路径下创建一个 server.js 文件，这里我们先使用入门教程里最简单的 Node.js 代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// server.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">http.createServer(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">request, response</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 发送 HTTP 头部</span></span><br><span class=\"line\">    <span class=\"comment\">// HTTP 状态值: 200 : OK</span></span><br><span class=\"line\">    <span class=\"comment\">// 内容类型: text/plain</span></span><br><span class=\"line\">    response.writeHead(<span class=\"number\">200</span>, &#123;<span class=\"string\">'Content-Type'</span>: <span class=\"string\">'text/plain'</span>&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 发送响应数据 \"Hello World\"</span></span><br><span class=\"line\">    response.end(<span class=\"string\">'Hello World\\n'</span>);</span><br><span class=\"line\">&#125;).listen(<span class=\"number\">8888</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 终端打印如下信息</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'Server running at http://127.0.0.1:8888/'</span>);</span><br></pre></td></tr></table></figure>\n<p>3、由于新浪的 Node.js 构建环境需要从 package.json 文件中读取配置信息，我们需要创建一个package.json 文件。</p>\n<p>这里我们直接使用 <code>npm init</code> 命令生成一个。 NPM 是 Node Package Manager 的缩写，也就是 Node 包管理器，类似于 iOS 开发中的 CocoaPods，而 <code>npm init</code> 就相当于<code>pod init</code>了.</p>\n<p>在 server.js 文件所在目录上，执行 <code>npm init</code>,按照命令行里的提示一步一步直接敲回车即可。</p>\n<p><img src=\"http://ob7o39x9f.bkt.clouddn.com/14819079662795.jpg\" alt></p>\n<p>4、部署</p>\n<p>这里的所谓部署 == 提交代码到新浪云 Git 服务器……</p>\n<p>所以，使用 Git 命令打 commit log，push 代码，等待云端编译即可：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 提交代码</span></span><br><span class=\"line\">➜  yehot git:(master) ✗ git add .</span><br><span class=\"line\">➜  yehot git:(master) ✗ git commit -m <span class=\"string\">\"添加package.json\"</span></span><br><span class=\"line\">[master a6b0d8f] 添加package.json</span><br><span class=\"line\"> <span class=\"number\">1</span> file changed, <span class=\"number\">20</span> insertions(+)</span><br><span class=\"line\"> create mode <span class=\"number\">100644</span> package.json</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// push 代码后，自动开始构建</span></span><br><span class=\"line\">➜  yehot git:(master) ✗ git push sae master</span><br><span class=\"line\">Counting objects: <span class=\"number\">3</span>, done.</span><br><span class=\"line\">Delta compression <span class=\"keyword\">using</span> up to <span class=\"number\">4</span> threads.</span><br><span class=\"line\">Compressing objects: <span class=\"number\">100</span>% (<span class=\"number\">3</span>/<span class=\"number\">3</span>), done.</span><br><span class=\"line\">Writing objects: <span class=\"number\">100</span>% (<span class=\"number\">3</span>/<span class=\"number\">3</span>), <span class=\"number\">377</span> bytes | <span class=\"number\">0</span> bytes/s, done.</span><br><span class=\"line\">Total <span class=\"number\">3</span> (delta <span class=\"number\">2</span>), reused <span class=\"number\">0</span> (delta <span class=\"number\">0</span>)</span><br><span class=\"line\">remote: 导出 Git 代码中...</span><br><span class=\"line\">remote: 构建程序中...</span><br><span class=\"line\">-----&gt; Node.js app detected</span><br><span class=\"line\"></span><br><span class=\"line\">-----&gt; Creating runtime environment</span><br><span class=\"line\"></span><br><span class=\"line\">       NPM_CONFIG_LOGLEVEL=error</span><br><span class=\"line\">       NPM_CONFIG_PRODUCTION=<span class=\"literal\">true</span></span><br><span class=\"line\">       NODE_ENV=production</span><br><span class=\"line\">       NODE_MODULES_CACHE=<span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\">-----&gt; Installing binaries</span><br><span class=\"line\">       engines.node (package.json):  unspecified</span><br><span class=\"line\">       engines.npm (package.json):   unspecified (use <span class=\"keyword\">default</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">       Resolving node version (latest stable) via semver.io...</span><br><span class=\"line\">       Downloading <span class=\"keyword\">and</span> installing node <span class=\"number\">7.2</span><span class=\"number\">.1</span>...</span><br><span class=\"line\">       Using <span class=\"keyword\">default</span> npm version: <span class=\"number\">3.10</span><span class=\"number\">.10</span></span><br><span class=\"line\"></span><br><span class=\"line\">-----&gt; Restoring cache</span><br><span class=\"line\">       Loading <span class=\"number\">2</span> from cacheDirectories (<span class=\"keyword\">default</span>):</span><br><span class=\"line\">       - node_modules</span><br><span class=\"line\">       - bower_components (<span class=\"keyword\">not</span> cached - skipping)</span><br><span class=\"line\">       - nodegyp_lib (<span class=\"keyword\">not</span> cached - skipping)</span><br><span class=\"line\"></span><br><span class=\"line\">-----&gt; Building dependencies</span><br><span class=\"line\">       Pruning any extraneous modules</span><br><span class=\"line\">       Installing node modules (package.json)</span><br><span class=\"line\">       yehot@<span class=\"number\">1.0</span><span class=\"number\">.0</span> /tmp/build</span><br><span class=\"line\">       `-- formidable@<span class=\"number\">1.0</span><span class=\"number\">.17</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">-----&gt; Caching build</span><br><span class=\"line\">       Clearing previous node cache</span><br><span class=\"line\">       Saving <span class=\"number\">2</span> cacheDirectories (<span class=\"keyword\">default</span>):</span><br><span class=\"line\">       - node_modules</span><br><span class=\"line\">       - bower_components (nothing to cache)</span><br><span class=\"line\">       - nodegyp_lib (nothing to cache)</span><br><span class=\"line\"></span><br><span class=\"line\">-----&gt; Build succeeded!</span><br><span class=\"line\">       `-- formidable@<span class=\"number\">1.0</span><span class=\"number\">.17</span></span><br><span class=\"line\"></span><br><span class=\"line\">-----&gt; Discovering process types</span><br><span class=\"line\">       Default types <span class=\"keyword\">for</span>  -&gt; web</span><br><span class=\"line\">-----&gt; Compiled slug size is <span class=\"number\">16</span>M</span><br><span class=\"line\">remote: Generating docker image...</span><br><span class=\"line\">remote: Pushing image registry.docker.sae.sina.com.cn/yehot:c72c679 .....</span><br><span class=\"line\">remote: 部署程序中 .....</span><br><span class=\"line\">To https:<span class=\"comment\">//git.sinacloud.com/yehot</span></span><br><span class=\"line\">   a6b0d8f..c72c679  master -&gt; master</span><br></pre></td></tr></table></figure>\n<p>到这里构建成功，就算部署成功了。这时我们的 Hello world 页面就可以在你的新浪云 Web 站点看到了：</p>\n<p><img src=\"http://ob7o39x9f.bkt.clouddn.com/14819134008404.jpg\" alt></p>\n<p>站点地址可以从这里查看到：</p>\n<p><img src=\"http://ob7o39x9f.bkt.clouddn.com/14819900207625.jpg\" alt></p>\n<h2 id=\"四、部署-html-页面\"><a href=\"#四、部署-html-页面\" class=\"headerlink\" title=\"四、部署 html 页面\"></a>四、部署 html 页面</h2><p>1、懒得自己写个页面了，直接用一个网站模板：<a href=\"https://www.oschina.net/news/59924/free-bootstrap-templates\" target=\"_blank\" rel=\"noopener\">40 个 Bootstrap 网站模板</a> ,随便选一个，把代码压缩包 down 下来</p>\n<p>2、解压，将代码网站模板全部文件拷贝到我们的刚创建的本地 Node 仓库目录里。</p>\n<p>3、这次我们就不是简单的响应个 hello world 的，需要将 html 文本作为页面 send 出去。这里直接使用 node.js 流行框架 <code>Express</code> 帮我们完成这件事。</p>\n<p>首先在代码目录路径下执行命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install express --save</span><br></pre></td></tr></table></figure>\n<p>这样会在 package.json 中，生成一条依赖信息：</p>\n<p><img src=\"http://ob7o39x9f.bkt.clouddn.com/14819895856109.jpg\" alt></p>\n<p>同时，会将 express 的源码从 npm 仓库中拉下来到本地自动生成的 node_modules 目录中。此时目录结构如下：</p>\n<p><img src=\"http://ob7o39x9f.bkt.clouddn.com/14819914963002.jpg\" alt></p>\n<p>4、改造 server.js 代码</p>\n<p>工具准备好了，开始使用：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// server.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> app = express()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 静态 html 页面，需要将当前目录下的所有文件都设置为 static</span></span><br><span class=\"line\">app.use(express.static(__dirname + <span class=\"string\">'/'</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">app.get(<span class=\"string\">'/'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'start server'</span>);</span><br><span class=\"line\">    <span class=\"comment\">// sendFile 函数，在有 request 访问时，将当前目录下的 index.html 文件作为 response 返回</span></span><br><span class=\"line\">    res.sendFile(__dirname + <span class=\"string\">'/index.html'</span>);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'start success'</span>);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 监听 8000 端口</span></span><br><span class=\"line\">app.listen(process.env.PORT || <span class=\"number\">8000</span>)</span><br></pre></td></tr></table></figure>\n<p>5、Ok，再次 commit log、push ，等待编译</p>\n<p>编译完成后，刷新我们的站点，就能看到一个漂亮的 html 页面了：</p>\n<p><img src=\"http://ob7o39x9f.bkt.clouddn.com/14819919635022.jpg\" alt></p>\n<p>bootstrap 是 Twitter 开源的强大的响应式布局框架，已经帮我们做好了移动端浏览器的适配工作，可以在手机浏览器上访问下试试，效果还是挺不错的。</p>\n<h2 id=\"五、作为服务器接口使用\"><a href=\"#五、作为服务器接口使用\" class=\"headerlink\" title=\"五、作为服务器接口使用\"></a>五、作为服务器接口使用</h2><p>目前我们的 Node 服务，已经成功部署了一个简单的 web 应用。</p>\n<p>我们可以在 iOS 端通过 get 请求访问下我们的站点 <code>http://xxx.applinzi.com</code> 试试，以 AFNetworkign 为例：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AFHTTPSessionManager *sessionManager = [AFHTTPSessionManager manager];</span><br><span class=\"line\"></span><br><span class=\"line\">sessionManager.responseSerializer = [AFHTTPResponseSerializer serializer];</span><br><span class=\"line\"></span><br><span class=\"line\">sessionManager.responseSerializer.acceptableContentTypes = [<span class=\"built_in\">NSSet</span> setWithObject:<span class=\"string\">@\"text/html\"</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">sessionManager.responseSerializer.acceptableContentTypes = [<span class=\"built_in\">NSSet</span> setWithObject:<span class=\"string\">@\"text/html\"</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">[sessionManager GET:<span class=\"string\">@\"http://yehot.applinzi.com/index.html\"</span> parameters:<span class=\"literal\">nil</span> progress:<span class=\"literal\">nil</span></span><br><span class=\"line\"></span><br><span class=\"line\">success:^(<span class=\"built_in\">NSURLSessionDataTask</span> * _Nonnull task, <span class=\"keyword\">id</span>  _Nullable responseObject) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>,responseObject);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; failure:^(<span class=\"built_in\">NSURLSessionDataTask</span> * _Nullable task, <span class=\"built_in\">NSError</span> * _Nonnull error) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"%@\"</span>,error);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n<h2 id=\"六、其它\"><a href=\"#六、其它\" class=\"headerlink\" title=\"六、其它\"></a>六、其它</h2><h3 id=\"新浪云控制台使用\"><a href=\"#新浪云控制台使用\" class=\"headerlink\" title=\"新浪云控制台使用\"></a>新浪云控制台使用</h3><p>1、查看操作记录<br><img src=\"http://ob7o39x9f.bkt.clouddn.com/14819090622798.jpg\" alt></p>\n<p>2、注册会送 200 云豆 == 2元</p>\n<p>没有额外流量消耗的话，每天默认扣 10 个豆</p>\n<p><img src=\"http://ob7o39x9f.bkt.clouddn.com/14819091585001.jpg\" alt></p>\n<p>如果欠费后显示</p>\n<p><img src=\"http://ob7o39x9f.bkt.clouddn.com/14819093138228.jpg\" alt></p>\n<p>3、查看日志、重启</p>\n<p><img src=\"http://ob7o39x9f.bkt.clouddn.com/14819095502076.jpg\" alt></p>\n<h3 id=\"最后，新浪是有-node-应用的部署指南的\"><a href=\"#最后，新浪是有-node-应用的部署指南的\" class=\"headerlink\" title=\"最后，新浪是有 node 应用的部署指南的\"></a>最后，新浪是有 node 应用的部署指南的</h3><p>上边这些坑，整整折腾了我5个小时后，我才发现这个：</p>\n<p><a href=\"https://www.sinacloud.com/doc/sae/docker/nodejs-getting-started.html\" target=\"_blank\" rel=\"noopener\">新浪 node 应用部署指南</a></p>\n<p>不说了，都是泪。当然使用 Python、PHP 也可以查看对应的文档<br><a href=\"https://www.sinacloud.com/index/support.html\" target=\"_blank\" rel=\"noopener\">https://www.sinacloud.com/index/support.html</a></p>\n<h2 id=\"参考：\"><a href=\"#参考：\" class=\"headerlink\" title=\"参考：\"></a>参考：</h2><p><a href=\"http://www.jianshu.com/p/325288166a59\" target=\"_blank\" rel=\"noopener\">在新浪云上用php+mysql搭建简单后台系列</a></p>\n"},{"title":"Git常用命令清单","date":"2017-02-15T14:33:01.000Z","_content":"\n![目录](http://upload-images.jianshu.io/upload_images/332029-53b2e99ec9b33e76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n之前一直借助于 Source-tree 这种图形化 Git 工具，一次在帮同事解决 Git 分支合并问题时，用的同事电脑，没有 Source-tree ，感觉完全不会用了，什么命令也没记住。恶补一下命令，重新学一遍 Git 教程，发现好多常用的操作，用命令还是非常方便的。\n这里整理汇总下：\n\n## 一、Git alias\n\n在开始常用命令前，先推荐下使用 alias 定义 git 常用命令的别名，合理使用简写可以大幅提高效率。\n\n常用 git 命令，可以在 `~/.gitconfig` 文件中使用 alias 定义简写，以下是我个人常用 alias:\n\n```js\n[alias]\n    st = status -s\n    ci = commit\n    l  = log --oneline --decorate -12 --color\n    ll = log --oneline --decorate --color\n    lc = log --graph --color\n    co = checkout\n    br = branch\n    ba = branch -a\n    rb = rebase\n    dci = dcommit\n    lg = log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit\n```\n\n> 另，`~/.gitconfig` 文件中，可以查看当前 user 的 git 配置信息\n\n## 二、branch 分支操作\n\n### 查看分支信息\n\n```js\n\n# 列出所有本地分支\n// git br\n$ git branch\n\n# 列出所有本地分支和远程分支\n// git ba\n$ git branch -a\n```\n\n### 新建分支\n\n```js\n# 从当前分支新建一个分支。但依然停留在当前分支\n// git br [本地xxx]\n$ git branch [branch-name]\n// 常用于：对当前 分支做个备份\n\n# 从指定的远程分支，拉一个本地分支。并切换到该分支\n// 常用于： 从远端 develop 拉一个 本地 feature/xxx 分支\n$ git checkout -b newBrach origin/master\n\n# 新建一个分支，指向指定commit。但依然停留在当前分支\n$ git branch [branch] [commit]\n\n# 新建一个分支。并切换到该分支\n// git co -b [local or remote/branch-name]\n$ git checkout -b [branch-name]\n\n# 新建一个分支，指向某个tag\n$ git checkout -b [branch] [tag]\n```\n\n### 切换分支\n\n```js\n# 切换到指定分支，并更新工作区\n// git co [branch-name]\n$ git checkout [branch-name]\n\n# 切换到上一个分支\n$ git checkout -\n```\n\n### 删除分支\n\n```js\n# 删除本地分支\n// git br -d [branch-name]]\n$ git branch -d [branch-name]\n$ git branch -D //强制删除\n\n# 删除远程分支\n// git br -dr [remote/branch]\n// eg:  git br -dr origin/xxx_name\n$ git branch -dr [remote/branch]\n```\n\n### 合并分支\n\n```js\n# 合并指定分支到当前分支\n$ git merge [branch]\n\n# 选择一个commit，合并进当前分支\n$ git cherry-pick [commit]\n```\n\n\n## 三、tag 分支操作\n\n在 Git 中 tag 可以看做是指向某个 commit 的特殊分支\n\n### 列显已有 tag\n\n```js\n$ git tag\n```\n\n### 添加 tag\n\n```js\n$ git tag v1.4.0\n\n// 添加一个带 commit log 的 tag\n$ git tag -a v1.4 -m 'my version 1.4'\n\n// 为某个指定的 commit 打上 tag\n$ git tag -a v1.2 9fceb02\n\n// 查看 tag 信息\n$ git show v1.4\n```\n\n### 推送 tag\n\n```js\n// git push 不会将本地的 tag push 到 origin\n\n# push 指定 tag name\n$ git push origin v1.0\n# push 全部 tag\n$ git push origin --tags\n```\n\n### 删除 tag\n\n```js\n// 删除本地 tag\n$ git tag -d v0.9\n\n// 删除远端 tag\n$ git push origin :refs/tags/0.1.0\n## 明确的表示删除\n$ git push --delete origin v1.1\n```\n\n## 四、git pull\n\ngit pull命令的作用是，取回远程主机某个分支的更新，再与本地的指定分支合并。\n\n### Merge 型 的 pull\n\n> 如果本地分支，在 checkout 后，有 commit， git pull 就会增加一个 Merge log\n> 如果本地分支没有 新 commit，等于直接 fetch、pull\n\n![](http://upload-images.jianshu.io/upload_images/332029-6510e80758bdf307.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n```git\n\n// 将远端的 A 分支的代码，拉到本地 B 分支 (会产生一个 Merge log)\n$ git pull origin [remote_name]:[local_name]\n// 如果是往当前 本地分支 pull，则冒号后面的部分可以省略\n$ git pull origin [remote_name]\n\n\n// 实质上，这等同于先做git fetch，再做git merge。\n$ git fetch origin\n$ git merge origin/next\n\n# Git会自动在本地分支与远程分支之间，建立一种追踪关系（tracking）。 就是说，本地的master分支自动\"追踪\"origin/master分支。\n\n// 如果当前分支与远程分支存在追踪关系，git pull就可以省略远程分支名。\n$ git pull origin\n\n// 如果当前分支只有一个追踪分支，连远程主机名都可以省略。\n$ git pull\n// 上面命令表示，当前分支自动与唯一一个追踪分支进行合并\n\n```\n\n### rebase 型 pull\n\n```js\n\n// 如果合并需要采用rebase模式，可以使用--rebase选项。\n$ git pull --rebase <远程主机名> <远程分支名>:<本地分支名>\n// git pull --rebase origin [origin_name]:[local_name]\n\n// 如果是 rebase 到当前分支，可省略 ： 后\n$ git pull --rebase origin [origin_name]\n// 如果 rebase 的远端分支，是当前分支 track 的，[origin_name] 可省略\n$ git pull --rebase origin\n\n```\n\n\n## 五、Git push\n\n\n```js\n// 将当前 loca_name 分支 push 到远端，命名为 new_name\n$ git push <远程主机名> <本地分支名>:<远程分支名>\n// git push origin loca_name:new_name\n\n# 如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。\n# 如果当前分支只有一个追踪分支，那么主机名都可以省略。\n// 会将本地所有分支都 对应 push （慎用）\n$ git push\n\n// push 可以用来删除\n$ git push origin --delete master\n\n# 如果远程主机的版本比本地版本更新，推送时Git会报错，要求先在本地做git pull合并差异，然后再推送到远程主机。这时，如果你一定要推送，可以使用--force选项。\n$ git push --force origin\n\n# 最后，git push不会推送标签（tag），除非使用--tags选项。\n$ git push origin --tags\n\n```\n\n\n## 六、代码回滚\n\n### 快速合并缓存区到上一个 commit\n\n```js\n// 将 add 到缓存区的内容，和上一个 commit 一起， rebase 成了一个新的 commit\n$ git commit --amend\n\n// 便于将漏修改的，或是修改错误的内容，合并到上一个 commit 中。而不用提交两个 commit，然后 rebase 成一个\n// 注：如果修改过了， 只能 push -f 到远端\n```\n\n### checkout 到指定 commit\n\n这对于快速查看项目旧版本来说非常有用\n\n```js\n$ git checkout [commit id]\n\n// check 到往前指定此的 commit\n$ git checkout HEAD~2\n```\n\n### git Revert\n\nRevert撤销一个提交的同时会创建一个新的提交。\n\n```js\n# 新建一个commit，用来撤销指定commit\n# 后者的所有变化都将被前者抵消，并且应用到当前分支\n$ git revert [commit]\n```\n\n### git reset\n\n- 将已经加到缓存区的内容（仅打了本地 commit），移除到工作区\n\n```\n$ git reset HEAD\n\n$ git reset HEAD~2\n```\n\n- 从缓存区重置，不删除修改的地方\n\n```js\n// 将缓存区中的指定文件，移到工作区\n// 缓存区中的，指的是 add 后的\ngit reset <file>\n\n// 将缓存区中的全部文件，移到工作区\n$ git reset\n\n// 将本地 commit 历史中的 commit 移除到 工作区 （未 add 状态）\n$ git reset [commit_id]\n```\n\n### 删除式 reset\n\n```js\n// 缓存区和工作区的，都会被完全移除（删除）\n$ git reset --hard\n\n// 将本地 commit 历史中的直接删除\n$ git reset --hard <commit>\n\n# 重置当前HEAD为指定commit，但保持暂存区和工作区不变\n$ git reset --keep [commit]\n```\n\n参考：\n[常用 Git 命令清单 - 阮一峰](http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html)\n[Git远程操作详解 - 阮一峰](http://www.ruanyifeng.com/blog/2014/06/git_remote.html)\n[Git 配置别名 - 廖雪峰](http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001375234012342f90be1fc4d81446c967bbdc19e7c03d3000)\n[果壳中的 Git](https://github.com/geeeeeeeeek/git-recipes/wiki)\n\n特别推荐：\n[ jaywcjlove —— Git常用命令清单](https://github.com/jaywcjlove/handbook/blob/master/other/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B8%85%E5%8D%95.md)\n","source":"_posts/20170215-git-order-list.md","raw":"---\ntitle: Git常用命令清单\ndate: 2017-02-15 22:33:01\ntags: Git\ncategories: Tool\n---\n\n![目录](http://upload-images.jianshu.io/upload_images/332029-53b2e99ec9b33e76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n之前一直借助于 Source-tree 这种图形化 Git 工具，一次在帮同事解决 Git 分支合并问题时，用的同事电脑，没有 Source-tree ，感觉完全不会用了，什么命令也没记住。恶补一下命令，重新学一遍 Git 教程，发现好多常用的操作，用命令还是非常方便的。\n这里整理汇总下：\n\n## 一、Git alias\n\n在开始常用命令前，先推荐下使用 alias 定义 git 常用命令的别名，合理使用简写可以大幅提高效率。\n\n常用 git 命令，可以在 `~/.gitconfig` 文件中使用 alias 定义简写，以下是我个人常用 alias:\n\n```js\n[alias]\n    st = status -s\n    ci = commit\n    l  = log --oneline --decorate -12 --color\n    ll = log --oneline --decorate --color\n    lc = log --graph --color\n    co = checkout\n    br = branch\n    ba = branch -a\n    rb = rebase\n    dci = dcommit\n    lg = log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit\n```\n\n> 另，`~/.gitconfig` 文件中，可以查看当前 user 的 git 配置信息\n\n## 二、branch 分支操作\n\n### 查看分支信息\n\n```js\n\n# 列出所有本地分支\n// git br\n$ git branch\n\n# 列出所有本地分支和远程分支\n// git ba\n$ git branch -a\n```\n\n### 新建分支\n\n```js\n# 从当前分支新建一个分支。但依然停留在当前分支\n// git br [本地xxx]\n$ git branch [branch-name]\n// 常用于：对当前 分支做个备份\n\n# 从指定的远程分支，拉一个本地分支。并切换到该分支\n// 常用于： 从远端 develop 拉一个 本地 feature/xxx 分支\n$ git checkout -b newBrach origin/master\n\n# 新建一个分支，指向指定commit。但依然停留在当前分支\n$ git branch [branch] [commit]\n\n# 新建一个分支。并切换到该分支\n// git co -b [local or remote/branch-name]\n$ git checkout -b [branch-name]\n\n# 新建一个分支，指向某个tag\n$ git checkout -b [branch] [tag]\n```\n\n### 切换分支\n\n```js\n# 切换到指定分支，并更新工作区\n// git co [branch-name]\n$ git checkout [branch-name]\n\n# 切换到上一个分支\n$ git checkout -\n```\n\n### 删除分支\n\n```js\n# 删除本地分支\n// git br -d [branch-name]]\n$ git branch -d [branch-name]\n$ git branch -D //强制删除\n\n# 删除远程分支\n// git br -dr [remote/branch]\n// eg:  git br -dr origin/xxx_name\n$ git branch -dr [remote/branch]\n```\n\n### 合并分支\n\n```js\n# 合并指定分支到当前分支\n$ git merge [branch]\n\n# 选择一个commit，合并进当前分支\n$ git cherry-pick [commit]\n```\n\n\n## 三、tag 分支操作\n\n在 Git 中 tag 可以看做是指向某个 commit 的特殊分支\n\n### 列显已有 tag\n\n```js\n$ git tag\n```\n\n### 添加 tag\n\n```js\n$ git tag v1.4.0\n\n// 添加一个带 commit log 的 tag\n$ git tag -a v1.4 -m 'my version 1.4'\n\n// 为某个指定的 commit 打上 tag\n$ git tag -a v1.2 9fceb02\n\n// 查看 tag 信息\n$ git show v1.4\n```\n\n### 推送 tag\n\n```js\n// git push 不会将本地的 tag push 到 origin\n\n# push 指定 tag name\n$ git push origin v1.0\n# push 全部 tag\n$ git push origin --tags\n```\n\n### 删除 tag\n\n```js\n// 删除本地 tag\n$ git tag -d v0.9\n\n// 删除远端 tag\n$ git push origin :refs/tags/0.1.0\n## 明确的表示删除\n$ git push --delete origin v1.1\n```\n\n## 四、git pull\n\ngit pull命令的作用是，取回远程主机某个分支的更新，再与本地的指定分支合并。\n\n### Merge 型 的 pull\n\n> 如果本地分支，在 checkout 后，有 commit， git pull 就会增加一个 Merge log\n> 如果本地分支没有 新 commit，等于直接 fetch、pull\n\n![](http://upload-images.jianshu.io/upload_images/332029-6510e80758bdf307.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n```git\n\n// 将远端的 A 分支的代码，拉到本地 B 分支 (会产生一个 Merge log)\n$ git pull origin [remote_name]:[local_name]\n// 如果是往当前 本地分支 pull，则冒号后面的部分可以省略\n$ git pull origin [remote_name]\n\n\n// 实质上，这等同于先做git fetch，再做git merge。\n$ git fetch origin\n$ git merge origin/next\n\n# Git会自动在本地分支与远程分支之间，建立一种追踪关系（tracking）。 就是说，本地的master分支自动\"追踪\"origin/master分支。\n\n// 如果当前分支与远程分支存在追踪关系，git pull就可以省略远程分支名。\n$ git pull origin\n\n// 如果当前分支只有一个追踪分支，连远程主机名都可以省略。\n$ git pull\n// 上面命令表示，当前分支自动与唯一一个追踪分支进行合并\n\n```\n\n### rebase 型 pull\n\n```js\n\n// 如果合并需要采用rebase模式，可以使用--rebase选项。\n$ git pull --rebase <远程主机名> <远程分支名>:<本地分支名>\n// git pull --rebase origin [origin_name]:[local_name]\n\n// 如果是 rebase 到当前分支，可省略 ： 后\n$ git pull --rebase origin [origin_name]\n// 如果 rebase 的远端分支，是当前分支 track 的，[origin_name] 可省略\n$ git pull --rebase origin\n\n```\n\n\n## 五、Git push\n\n\n```js\n// 将当前 loca_name 分支 push 到远端，命名为 new_name\n$ git push <远程主机名> <本地分支名>:<远程分支名>\n// git push origin loca_name:new_name\n\n# 如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。\n# 如果当前分支只有一个追踪分支，那么主机名都可以省略。\n// 会将本地所有分支都 对应 push （慎用）\n$ git push\n\n// push 可以用来删除\n$ git push origin --delete master\n\n# 如果远程主机的版本比本地版本更新，推送时Git会报错，要求先在本地做git pull合并差异，然后再推送到远程主机。这时，如果你一定要推送，可以使用--force选项。\n$ git push --force origin\n\n# 最后，git push不会推送标签（tag），除非使用--tags选项。\n$ git push origin --tags\n\n```\n\n\n## 六、代码回滚\n\n### 快速合并缓存区到上一个 commit\n\n```js\n// 将 add 到缓存区的内容，和上一个 commit 一起， rebase 成了一个新的 commit\n$ git commit --amend\n\n// 便于将漏修改的，或是修改错误的内容，合并到上一个 commit 中。而不用提交两个 commit，然后 rebase 成一个\n// 注：如果修改过了， 只能 push -f 到远端\n```\n\n### checkout 到指定 commit\n\n这对于快速查看项目旧版本来说非常有用\n\n```js\n$ git checkout [commit id]\n\n// check 到往前指定此的 commit\n$ git checkout HEAD~2\n```\n\n### git Revert\n\nRevert撤销一个提交的同时会创建一个新的提交。\n\n```js\n# 新建一个commit，用来撤销指定commit\n# 后者的所有变化都将被前者抵消，并且应用到当前分支\n$ git revert [commit]\n```\n\n### git reset\n\n- 将已经加到缓存区的内容（仅打了本地 commit），移除到工作区\n\n```\n$ git reset HEAD\n\n$ git reset HEAD~2\n```\n\n- 从缓存区重置，不删除修改的地方\n\n```js\n// 将缓存区中的指定文件，移到工作区\n// 缓存区中的，指的是 add 后的\ngit reset <file>\n\n// 将缓存区中的全部文件，移到工作区\n$ git reset\n\n// 将本地 commit 历史中的 commit 移除到 工作区 （未 add 状态）\n$ git reset [commit_id]\n```\n\n### 删除式 reset\n\n```js\n// 缓存区和工作区的，都会被完全移除（删除）\n$ git reset --hard\n\n// 将本地 commit 历史中的直接删除\n$ git reset --hard <commit>\n\n# 重置当前HEAD为指定commit，但保持暂存区和工作区不变\n$ git reset --keep [commit]\n```\n\n参考：\n[常用 Git 命令清单 - 阮一峰](http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html)\n[Git远程操作详解 - 阮一峰](http://www.ruanyifeng.com/blog/2014/06/git_remote.html)\n[Git 配置别名 - 廖雪峰](http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001375234012342f90be1fc4d81446c967bbdc19e7c03d3000)\n[果壳中的 Git](https://github.com/geeeeeeeeek/git-recipes/wiki)\n\n特别推荐：\n[ jaywcjlove —— Git常用命令清单](https://github.com/jaywcjlove/handbook/blob/master/other/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B8%85%E5%8D%95.md)\n","slug":"20170215-git-order-list","published":1,"updated":"2019-04-18T11:06:48.750Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjumvmxad0015raxeabcn5f3n","content":"<p><img src=\"http://upload-images.jianshu.io/upload_images/332029-53b2e99ec9b33e76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"目录\"></p>\n<p>之前一直借助于 Source-tree 这种图形化 Git 工具，一次在帮同事解决 Git 分支合并问题时，用的同事电脑，没有 Source-tree ，感觉完全不会用了，什么命令也没记住。恶补一下命令，重新学一遍 Git 教程，发现好多常用的操作，用命令还是非常方便的。<br>这里整理汇总下：</p>\n<h2 id=\"一、Git-alias\"><a href=\"#一、Git-alias\" class=\"headerlink\" title=\"一、Git alias\"></a>一、Git alias</h2><p>在开始常用命令前，先推荐下使用 alias 定义 git 常用命令的别名，合理使用简写可以大幅提高效率。</p>\n<p>常用 git 命令，可以在 <code>~/.gitconfig</code> 文件中使用 alias 定义简写，以下是我个人常用 alias:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[alias]</span><br><span class=\"line\">    st = status -s</span><br><span class=\"line\">    ci = commit</span><br><span class=\"line\">    l  = log --oneline --decorate <span class=\"number\">-12</span> --color</span><br><span class=\"line\">    ll = log --oneline --decorate --color</span><br><span class=\"line\">    lc = log --graph --color</span><br><span class=\"line\">    co = checkout</span><br><span class=\"line\">    br = branch</span><br><span class=\"line\">    ba = branch -a</span><br><span class=\"line\">    rb = rebase</span><br><span class=\"line\">    dci = dcommit</span><br><span class=\"line\">    lg = log --color --graph --pretty=format:<span class=\"string\">'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset'</span> --abbrev-commit</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>另，<code>~/.gitconfig</code> 文件中，可以查看当前 user 的 git 配置信息</p>\n</blockquote>\n<h2 id=\"二、branch-分支操作\"><a href=\"#二、branch-分支操作\" class=\"headerlink\" title=\"二、branch 分支操作\"></a>二、branch 分支操作</h2><h3 id=\"查看分支信息\"><a href=\"#查看分支信息\" class=\"headerlink\" title=\"查看分支信息\"></a>查看分支信息</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"># 列出所有本地分支</span><br><span class=\"line\"><span class=\"comment\">// git br</span></span><br><span class=\"line\">$ git branch</span><br><span class=\"line\"></span><br><span class=\"line\"># 列出所有本地分支和远程分支</span><br><span class=\"line\"><span class=\"comment\">// git ba</span></span><br><span class=\"line\">$ git branch -a</span><br></pre></td></tr></table></figure>\n<h3 id=\"新建分支\"><a href=\"#新建分支\" class=\"headerlink\" title=\"新建分支\"></a>新建分支</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 从当前分支新建一个分支。但依然停留在当前分支</span><br><span class=\"line\"><span class=\"comment\">// git br [本地xxx]</span></span><br><span class=\"line\">$ git branch [branch-name]</span><br><span class=\"line\"><span class=\"comment\">// 常用于：对当前 分支做个备份</span></span><br><span class=\"line\"></span><br><span class=\"line\"># 从指定的远程分支，拉一个本地分支。并切换到该分支</span><br><span class=\"line\"><span class=\"comment\">// 常用于： 从远端 develop 拉一个 本地 feature/xxx 分支</span></span><br><span class=\"line\">$ git checkout -b newBrach origin/master</span><br><span class=\"line\"></span><br><span class=\"line\"># 新建一个分支，指向指定commit。但依然停留在当前分支</span><br><span class=\"line\">$ git branch [branch] [commit]</span><br><span class=\"line\"></span><br><span class=\"line\"># 新建一个分支。并切换到该分支</span><br><span class=\"line\"><span class=\"comment\">// git co -b [local or remote/branch-name]</span></span><br><span class=\"line\">$ git checkout -b [branch-name]</span><br><span class=\"line\"></span><br><span class=\"line\"># 新建一个分支，指向某个tag</span><br><span class=\"line\">$ git checkout -b [branch] [tag]</span><br></pre></td></tr></table></figure>\n<h3 id=\"切换分支\"><a href=\"#切换分支\" class=\"headerlink\" title=\"切换分支\"></a>切换分支</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 切换到指定分支，并更新工作区</span><br><span class=\"line\"><span class=\"comment\">// git co [branch-name]</span></span><br><span class=\"line\">$ git checkout [branch-name]</span><br><span class=\"line\"></span><br><span class=\"line\"># 切换到上一个分支</span><br><span class=\"line\">$ git checkout -</span><br></pre></td></tr></table></figure>\n<h3 id=\"删除分支\"><a href=\"#删除分支\" class=\"headerlink\" title=\"删除分支\"></a>删除分支</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 删除本地分支</span><br><span class=\"line\"><span class=\"comment\">// git br -d [branch-name]]</span></span><br><span class=\"line\">$ git branch -d [branch-name]</span><br><span class=\"line\">$ git branch -D <span class=\"comment\">//强制删除</span></span><br><span class=\"line\"></span><br><span class=\"line\"># 删除远程分支</span><br><span class=\"line\"><span class=\"comment\">// git br -dr [remote/branch]</span></span><br><span class=\"line\"><span class=\"comment\">// eg:  git br -dr origin/xxx_name</span></span><br><span class=\"line\">$ git branch -dr [remote/branch]</span><br></pre></td></tr></table></figure>\n<h3 id=\"合并分支\"><a href=\"#合并分支\" class=\"headerlink\" title=\"合并分支\"></a>合并分支</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 合并指定分支到当前分支</span><br><span class=\"line\">$ git merge [branch]</span><br><span class=\"line\"></span><br><span class=\"line\"># 选择一个commit，合并进当前分支</span><br><span class=\"line\">$ git cherry-pick [commit]</span><br></pre></td></tr></table></figure>\n<h2 id=\"三、tag-分支操作\"><a href=\"#三、tag-分支操作\" class=\"headerlink\" title=\"三、tag 分支操作\"></a>三、tag 分支操作</h2><p>在 Git 中 tag 可以看做是指向某个 commit 的特殊分支</p>\n<h3 id=\"列显已有-tag\"><a href=\"#列显已有-tag\" class=\"headerlink\" title=\"列显已有 tag\"></a>列显已有 tag</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git tag</span><br></pre></td></tr></table></figure>\n<h3 id=\"添加-tag\"><a href=\"#添加-tag\" class=\"headerlink\" title=\"添加 tag\"></a>添加 tag</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git tag v1<span class=\"number\">.4</span><span class=\"number\">.0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 添加一个带 commit log 的 tag</span></span><br><span class=\"line\">$ git tag -a v1<span class=\"number\">.4</span> -m <span class=\"string\">'my version 1.4'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 为某个指定的 commit 打上 tag</span></span><br><span class=\"line\">$ git tag -a v1<span class=\"number\">.2</span> <span class=\"number\">9</span>fceb02</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 查看 tag 信息</span></span><br><span class=\"line\">$ git show v1<span class=\"number\">.4</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"推送-tag\"><a href=\"#推送-tag\" class=\"headerlink\" title=\"推送 tag\"></a>推送 tag</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// git push 不会将本地的 tag push 到 origin</span></span><br><span class=\"line\"></span><br><span class=\"line\"># push 指定 tag name</span><br><span class=\"line\">$ git push origin v1<span class=\"number\">.0</span></span><br><span class=\"line\"># push 全部 tag</span><br><span class=\"line\">$ git push origin --tags</span><br></pre></td></tr></table></figure>\n<h3 id=\"删除-tag\"><a href=\"#删除-tag\" class=\"headerlink\" title=\"删除 tag\"></a>删除 tag</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 删除本地 tag</span></span><br><span class=\"line\">$ git tag -d v0<span class=\"number\">.9</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 删除远端 tag</span></span><br><span class=\"line\">$ git push origin :refs/tags/<span class=\"number\">0.1</span><span class=\"number\">.0</span></span><br><span class=\"line\">## 明确的表示删除</span><br><span class=\"line\">$ git push --<span class=\"keyword\">delete</span> origin v1<span class=\"number\">.1</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"四、git-pull\"><a href=\"#四、git-pull\" class=\"headerlink\" title=\"四、git pull\"></a>四、git pull</h2><p>git pull命令的作用是，取回远程主机某个分支的更新，再与本地的指定分支合并。</p>\n<h3 id=\"Merge-型-的-pull\"><a href=\"#Merge-型-的-pull\" class=\"headerlink\" title=\"Merge 型 的 pull\"></a>Merge 型 的 pull</h3><blockquote>\n<p>如果本地分支，在 checkout 后，有 commit， git pull 就会增加一个 Merge log<br>如果本地分支没有 新 commit，等于直接 fetch、pull</p>\n</blockquote>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/332029-6510e80758bdf307.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">// 将远端的 A 分支的代码，拉到本地 B 分支 (会产生一个 Merge log)</span><br><span class=\"line\">$ git pull origin [remote_name]:[local_name]</span><br><span class=\"line\">// 如果是往当前 本地分支 pull，则冒号后面的部分可以省略</span><br><span class=\"line\">$ git pull origin [remote_name]</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// 实质上，这等同于先做git fetch，再做git merge。</span><br><span class=\"line\">$ git fetch origin</span><br><span class=\"line\">$ git merge origin/next</span><br><span class=\"line\"></span><br><span class=\"line\"># Git会自动在本地分支与远程分支之间，建立一种追踪关系（tracking）。 就是说，本地的master分支自动&quot;追踪&quot;origin/master分支。</span><br><span class=\"line\"></span><br><span class=\"line\">// 如果当前分支与远程分支存在追踪关系，git pull就可以省略远程分支名。</span><br><span class=\"line\">$ git pull origin</span><br><span class=\"line\"></span><br><span class=\"line\">// 如果当前分支只有一个追踪分支，连远程主机名都可以省略。</span><br><span class=\"line\">$ git pull</span><br><span class=\"line\">// 上面命令表示，当前分支自动与唯一一个追踪分支进行合并</span><br></pre></td></tr></table></figure>\n<h3 id=\"rebase-型-pull\"><a href=\"#rebase-型-pull\" class=\"headerlink\" title=\"rebase 型 pull\"></a>rebase 型 pull</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 如果合并需要采用rebase模式，可以使用--rebase选项。</span></span><br><span class=\"line\">$ git pull --rebase &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br><span class=\"line\">// git pull --rebase origin [origin_name]:[local_name]</span><br><span class=\"line\"></span><br><span class=\"line\">// 如果是 rebase 到当前分支，可省略 ： 后</span><br><span class=\"line\">$ git pull --rebase origin [origin_name]</span><br><span class=\"line\">// 如果 rebase 的远端分支，是当前分支 track 的，[origin_name] 可省略</span><br><span class=\"line\">$ git pull --rebase origin</span><br></pre></td></tr></table></figure>\n<h2 id=\"五、Git-push\"><a href=\"#五、Git-push\" class=\"headerlink\" title=\"五、Git push\"></a>五、Git push</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 将当前 loca_name 分支 push 到远端，命名为 new_name</span></span><br><span class=\"line\">$ git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br><span class=\"line\">// git push origin loca_name:new_name</span><br><span class=\"line\"></span><br><span class=\"line\"># 如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。</span><br><span class=\"line\"># 如果当前分支只有一个追踪分支，那么主机名都可以省略。</span><br><span class=\"line\">// 会将本地所有分支都 对应 push （慎用）</span><br><span class=\"line\">$ git push</span><br><span class=\"line\"></span><br><span class=\"line\">// push 可以用来删除</span><br><span class=\"line\">$ git push origin --delete master</span><br><span class=\"line\"></span><br><span class=\"line\"># 如果远程主机的版本比本地版本更新，推送时Git会报错，要求先在本地做git pull合并差异，然后再推送到远程主机。这时，如果你一定要推送，可以使用--force选项。</span><br><span class=\"line\">$ git push --force origin</span><br><span class=\"line\"></span><br><span class=\"line\"># 最后，git push不会推送标签（tag），除非使用--tags选项。</span><br><span class=\"line\">$ git push origin --tags</span><br></pre></td></tr></table></figure>\n<h2 id=\"六、代码回滚\"><a href=\"#六、代码回滚\" class=\"headerlink\" title=\"六、代码回滚\"></a>六、代码回滚</h2><h3 id=\"快速合并缓存区到上一个-commit\"><a href=\"#快速合并缓存区到上一个-commit\" class=\"headerlink\" title=\"快速合并缓存区到上一个 commit\"></a>快速合并缓存区到上一个 commit</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 将 add 到缓存区的内容，和上一个 commit 一起， rebase 成了一个新的 commit</span></span><br><span class=\"line\">$ git commit --amend</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 便于将漏修改的，或是修改错误的内容，合并到上一个 commit 中。而不用提交两个 commit，然后 rebase 成一个</span></span><br><span class=\"line\"><span class=\"comment\">// 注：如果修改过了， 只能 push -f 到远端</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"checkout-到指定-commit\"><a href=\"#checkout-到指定-commit\" class=\"headerlink\" title=\"checkout 到指定 commit\"></a>checkout 到指定 commit</h3><p>这对于快速查看项目旧版本来说非常有用</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout [commit id]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// check 到往前指定此的 commit</span></span><br><span class=\"line\">$ git checkout HEAD~<span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"git-Revert\"><a href=\"#git-Revert\" class=\"headerlink\" title=\"git Revert\"></a>git Revert</h3><p>Revert撤销一个提交的同时会创建一个新的提交。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 新建一个commit，用来撤销指定commit</span><br><span class=\"line\"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span><br><span class=\"line\">$ git revert [commit]</span><br></pre></td></tr></table></figure>\n<h3 id=\"git-reset\"><a href=\"#git-reset\" class=\"headerlink\" title=\"git reset\"></a>git reset</h3><ul>\n<li>将已经加到缓存区的内容（仅打了本地 commit），移除到工作区</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git reset HEAD</span><br><span class=\"line\"></span><br><span class=\"line\">$ git reset HEAD~2</span><br></pre></td></tr></table></figure>\n<ul>\n<li>从缓存区重置，不删除修改的地方</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 将缓存区中的指定文件，移到工作区</span></span><br><span class=\"line\"><span class=\"comment\">// 缓存区中的，指的是 add 后的</span></span><br><span class=\"line\">git reset &lt;file&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将缓存区中的全部文件，移到工作区</span></span><br><span class=\"line\">$ git reset</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将本地 commit 历史中的 commit 移除到 工作区 （未 add 状态）</span></span><br><span class=\"line\">$ git reset [commit_id]</span><br></pre></td></tr></table></figure>\n<h3 id=\"删除式-reset\"><a href=\"#删除式-reset\" class=\"headerlink\" title=\"删除式 reset\"></a>删除式 reset</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 缓存区和工作区的，都会被完全移除（删除）</span></span><br><span class=\"line\">$ git reset --hard</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将本地 commit 历史中的直接删除</span></span><br><span class=\"line\">$ git reset --hard &lt;commit&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span><br><span class=\"line\">$ git reset --keep [commit]</span><br></pre></td></tr></table></figure>\n<p>参考：<br><a href=\"http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html\" target=\"_blank\" rel=\"noopener\">常用 Git 命令清单 - 阮一峰</a><br><a href=\"http://www.ruanyifeng.com/blog/2014/06/git_remote.html\" target=\"_blank\" rel=\"noopener\">Git远程操作详解 - 阮一峰</a><br><a href=\"http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001375234012342f90be1fc4d81446c967bbdc19e7c03d3000\" target=\"_blank\" rel=\"noopener\">Git 配置别名 - 廖雪峰</a><br><a href=\"https://github.com/geeeeeeeeek/git-recipes/wiki\" target=\"_blank\" rel=\"noopener\">果壳中的 Git</a></p>\n<p>特别推荐：<br><a href=\"https://github.com/jaywcjlove/handbook/blob/master/other/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B8%85%E5%8D%95.md\" target=\"_blank\" rel=\"noopener\"> jaywcjlove —— Git常用命令清单</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://upload-images.jianshu.io/upload_images/332029-53b2e99ec9b33e76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"目录\"></p>\n<p>之前一直借助于 Source-tree 这种图形化 Git 工具，一次在帮同事解决 Git 分支合并问题时，用的同事电脑，没有 Source-tree ，感觉完全不会用了，什么命令也没记住。恶补一下命令，重新学一遍 Git 教程，发现好多常用的操作，用命令还是非常方便的。<br>这里整理汇总下：</p>\n<h2 id=\"一、Git-alias\"><a href=\"#一、Git-alias\" class=\"headerlink\" title=\"一、Git alias\"></a>一、Git alias</h2><p>在开始常用命令前，先推荐下使用 alias 定义 git 常用命令的别名，合理使用简写可以大幅提高效率。</p>\n<p>常用 git 命令，可以在 <code>~/.gitconfig</code> 文件中使用 alias 定义简写，以下是我个人常用 alias:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[alias]</span><br><span class=\"line\">    st = status -s</span><br><span class=\"line\">    ci = commit</span><br><span class=\"line\">    l  = log --oneline --decorate <span class=\"number\">-12</span> --color</span><br><span class=\"line\">    ll = log --oneline --decorate --color</span><br><span class=\"line\">    lc = log --graph --color</span><br><span class=\"line\">    co = checkout</span><br><span class=\"line\">    br = branch</span><br><span class=\"line\">    ba = branch -a</span><br><span class=\"line\">    rb = rebase</span><br><span class=\"line\">    dci = dcommit</span><br><span class=\"line\">    lg = log --color --graph --pretty=format:<span class=\"string\">'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset'</span> --abbrev-commit</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>另，<code>~/.gitconfig</code> 文件中，可以查看当前 user 的 git 配置信息</p>\n</blockquote>\n<h2 id=\"二、branch-分支操作\"><a href=\"#二、branch-分支操作\" class=\"headerlink\" title=\"二、branch 分支操作\"></a>二、branch 分支操作</h2><h3 id=\"查看分支信息\"><a href=\"#查看分支信息\" class=\"headerlink\" title=\"查看分支信息\"></a>查看分支信息</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"># 列出所有本地分支</span><br><span class=\"line\"><span class=\"comment\">// git br</span></span><br><span class=\"line\">$ git branch</span><br><span class=\"line\"></span><br><span class=\"line\"># 列出所有本地分支和远程分支</span><br><span class=\"line\"><span class=\"comment\">// git ba</span></span><br><span class=\"line\">$ git branch -a</span><br></pre></td></tr></table></figure>\n<h3 id=\"新建分支\"><a href=\"#新建分支\" class=\"headerlink\" title=\"新建分支\"></a>新建分支</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 从当前分支新建一个分支。但依然停留在当前分支</span><br><span class=\"line\"><span class=\"comment\">// git br [本地xxx]</span></span><br><span class=\"line\">$ git branch [branch-name]</span><br><span class=\"line\"><span class=\"comment\">// 常用于：对当前 分支做个备份</span></span><br><span class=\"line\"></span><br><span class=\"line\"># 从指定的远程分支，拉一个本地分支。并切换到该分支</span><br><span class=\"line\"><span class=\"comment\">// 常用于： 从远端 develop 拉一个 本地 feature/xxx 分支</span></span><br><span class=\"line\">$ git checkout -b newBrach origin/master</span><br><span class=\"line\"></span><br><span class=\"line\"># 新建一个分支，指向指定commit。但依然停留在当前分支</span><br><span class=\"line\">$ git branch [branch] [commit]</span><br><span class=\"line\"></span><br><span class=\"line\"># 新建一个分支。并切换到该分支</span><br><span class=\"line\"><span class=\"comment\">// git co -b [local or remote/branch-name]</span></span><br><span class=\"line\">$ git checkout -b [branch-name]</span><br><span class=\"line\"></span><br><span class=\"line\"># 新建一个分支，指向某个tag</span><br><span class=\"line\">$ git checkout -b [branch] [tag]</span><br></pre></td></tr></table></figure>\n<h3 id=\"切换分支\"><a href=\"#切换分支\" class=\"headerlink\" title=\"切换分支\"></a>切换分支</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 切换到指定分支，并更新工作区</span><br><span class=\"line\"><span class=\"comment\">// git co [branch-name]</span></span><br><span class=\"line\">$ git checkout [branch-name]</span><br><span class=\"line\"></span><br><span class=\"line\"># 切换到上一个分支</span><br><span class=\"line\">$ git checkout -</span><br></pre></td></tr></table></figure>\n<h3 id=\"删除分支\"><a href=\"#删除分支\" class=\"headerlink\" title=\"删除分支\"></a>删除分支</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 删除本地分支</span><br><span class=\"line\"><span class=\"comment\">// git br -d [branch-name]]</span></span><br><span class=\"line\">$ git branch -d [branch-name]</span><br><span class=\"line\">$ git branch -D <span class=\"comment\">//强制删除</span></span><br><span class=\"line\"></span><br><span class=\"line\"># 删除远程分支</span><br><span class=\"line\"><span class=\"comment\">// git br -dr [remote/branch]</span></span><br><span class=\"line\"><span class=\"comment\">// eg:  git br -dr origin/xxx_name</span></span><br><span class=\"line\">$ git branch -dr [remote/branch]</span><br></pre></td></tr></table></figure>\n<h3 id=\"合并分支\"><a href=\"#合并分支\" class=\"headerlink\" title=\"合并分支\"></a>合并分支</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 合并指定分支到当前分支</span><br><span class=\"line\">$ git merge [branch]</span><br><span class=\"line\"></span><br><span class=\"line\"># 选择一个commit，合并进当前分支</span><br><span class=\"line\">$ git cherry-pick [commit]</span><br></pre></td></tr></table></figure>\n<h2 id=\"三、tag-分支操作\"><a href=\"#三、tag-分支操作\" class=\"headerlink\" title=\"三、tag 分支操作\"></a>三、tag 分支操作</h2><p>在 Git 中 tag 可以看做是指向某个 commit 的特殊分支</p>\n<h3 id=\"列显已有-tag\"><a href=\"#列显已有-tag\" class=\"headerlink\" title=\"列显已有 tag\"></a>列显已有 tag</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git tag</span><br></pre></td></tr></table></figure>\n<h3 id=\"添加-tag\"><a href=\"#添加-tag\" class=\"headerlink\" title=\"添加 tag\"></a>添加 tag</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git tag v1<span class=\"number\">.4</span><span class=\"number\">.0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 添加一个带 commit log 的 tag</span></span><br><span class=\"line\">$ git tag -a v1<span class=\"number\">.4</span> -m <span class=\"string\">'my version 1.4'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 为某个指定的 commit 打上 tag</span></span><br><span class=\"line\">$ git tag -a v1<span class=\"number\">.2</span> <span class=\"number\">9</span>fceb02</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 查看 tag 信息</span></span><br><span class=\"line\">$ git show v1<span class=\"number\">.4</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"推送-tag\"><a href=\"#推送-tag\" class=\"headerlink\" title=\"推送 tag\"></a>推送 tag</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// git push 不会将本地的 tag push 到 origin</span></span><br><span class=\"line\"></span><br><span class=\"line\"># push 指定 tag name</span><br><span class=\"line\">$ git push origin v1<span class=\"number\">.0</span></span><br><span class=\"line\"># push 全部 tag</span><br><span class=\"line\">$ git push origin --tags</span><br></pre></td></tr></table></figure>\n<h3 id=\"删除-tag\"><a href=\"#删除-tag\" class=\"headerlink\" title=\"删除 tag\"></a>删除 tag</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 删除本地 tag</span></span><br><span class=\"line\">$ git tag -d v0<span class=\"number\">.9</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 删除远端 tag</span></span><br><span class=\"line\">$ git push origin :refs/tags/<span class=\"number\">0.1</span><span class=\"number\">.0</span></span><br><span class=\"line\">## 明确的表示删除</span><br><span class=\"line\">$ git push --<span class=\"keyword\">delete</span> origin v1<span class=\"number\">.1</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"四、git-pull\"><a href=\"#四、git-pull\" class=\"headerlink\" title=\"四、git pull\"></a>四、git pull</h2><p>git pull命令的作用是，取回远程主机某个分支的更新，再与本地的指定分支合并。</p>\n<h3 id=\"Merge-型-的-pull\"><a href=\"#Merge-型-的-pull\" class=\"headerlink\" title=\"Merge 型 的 pull\"></a>Merge 型 的 pull</h3><blockquote>\n<p>如果本地分支，在 checkout 后，有 commit， git pull 就会增加一个 Merge log<br>如果本地分支没有 新 commit，等于直接 fetch、pull</p>\n</blockquote>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/332029-6510e80758bdf307.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">// 将远端的 A 分支的代码，拉到本地 B 分支 (会产生一个 Merge log)</span><br><span class=\"line\">$ git pull origin [remote_name]:[local_name]</span><br><span class=\"line\">// 如果是往当前 本地分支 pull，则冒号后面的部分可以省略</span><br><span class=\"line\">$ git pull origin [remote_name]</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// 实质上，这等同于先做git fetch，再做git merge。</span><br><span class=\"line\">$ git fetch origin</span><br><span class=\"line\">$ git merge origin/next</span><br><span class=\"line\"></span><br><span class=\"line\"># Git会自动在本地分支与远程分支之间，建立一种追踪关系（tracking）。 就是说，本地的master分支自动&quot;追踪&quot;origin/master分支。</span><br><span class=\"line\"></span><br><span class=\"line\">// 如果当前分支与远程分支存在追踪关系，git pull就可以省略远程分支名。</span><br><span class=\"line\">$ git pull origin</span><br><span class=\"line\"></span><br><span class=\"line\">// 如果当前分支只有一个追踪分支，连远程主机名都可以省略。</span><br><span class=\"line\">$ git pull</span><br><span class=\"line\">// 上面命令表示，当前分支自动与唯一一个追踪分支进行合并</span><br></pre></td></tr></table></figure>\n<h3 id=\"rebase-型-pull\"><a href=\"#rebase-型-pull\" class=\"headerlink\" title=\"rebase 型 pull\"></a>rebase 型 pull</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 如果合并需要采用rebase模式，可以使用--rebase选项。</span></span><br><span class=\"line\">$ git pull --rebase &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br><span class=\"line\">// git pull --rebase origin [origin_name]:[local_name]</span><br><span class=\"line\"></span><br><span class=\"line\">// 如果是 rebase 到当前分支，可省略 ： 后</span><br><span class=\"line\">$ git pull --rebase origin [origin_name]</span><br><span class=\"line\">// 如果 rebase 的远端分支，是当前分支 track 的，[origin_name] 可省略</span><br><span class=\"line\">$ git pull --rebase origin</span><br></pre></td></tr></table></figure>\n<h2 id=\"五、Git-push\"><a href=\"#五、Git-push\" class=\"headerlink\" title=\"五、Git push\"></a>五、Git push</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 将当前 loca_name 分支 push 到远端，命名为 new_name</span></span><br><span class=\"line\">$ git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br><span class=\"line\">// git push origin loca_name:new_name</span><br><span class=\"line\"></span><br><span class=\"line\"># 如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。</span><br><span class=\"line\"># 如果当前分支只有一个追踪分支，那么主机名都可以省略。</span><br><span class=\"line\">// 会将本地所有分支都 对应 push （慎用）</span><br><span class=\"line\">$ git push</span><br><span class=\"line\"></span><br><span class=\"line\">// push 可以用来删除</span><br><span class=\"line\">$ git push origin --delete master</span><br><span class=\"line\"></span><br><span class=\"line\"># 如果远程主机的版本比本地版本更新，推送时Git会报错，要求先在本地做git pull合并差异，然后再推送到远程主机。这时，如果你一定要推送，可以使用--force选项。</span><br><span class=\"line\">$ git push --force origin</span><br><span class=\"line\"></span><br><span class=\"line\"># 最后，git push不会推送标签（tag），除非使用--tags选项。</span><br><span class=\"line\">$ git push origin --tags</span><br></pre></td></tr></table></figure>\n<h2 id=\"六、代码回滚\"><a href=\"#六、代码回滚\" class=\"headerlink\" title=\"六、代码回滚\"></a>六、代码回滚</h2><h3 id=\"快速合并缓存区到上一个-commit\"><a href=\"#快速合并缓存区到上一个-commit\" class=\"headerlink\" title=\"快速合并缓存区到上一个 commit\"></a>快速合并缓存区到上一个 commit</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 将 add 到缓存区的内容，和上一个 commit 一起， rebase 成了一个新的 commit</span></span><br><span class=\"line\">$ git commit --amend</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 便于将漏修改的，或是修改错误的内容，合并到上一个 commit 中。而不用提交两个 commit，然后 rebase 成一个</span></span><br><span class=\"line\"><span class=\"comment\">// 注：如果修改过了， 只能 push -f 到远端</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"checkout-到指定-commit\"><a href=\"#checkout-到指定-commit\" class=\"headerlink\" title=\"checkout 到指定 commit\"></a>checkout 到指定 commit</h3><p>这对于快速查看项目旧版本来说非常有用</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout [commit id]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// check 到往前指定此的 commit</span></span><br><span class=\"line\">$ git checkout HEAD~<span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"git-Revert\"><a href=\"#git-Revert\" class=\"headerlink\" title=\"git Revert\"></a>git Revert</h3><p>Revert撤销一个提交的同时会创建一个新的提交。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 新建一个commit，用来撤销指定commit</span><br><span class=\"line\"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span><br><span class=\"line\">$ git revert [commit]</span><br></pre></td></tr></table></figure>\n<h3 id=\"git-reset\"><a href=\"#git-reset\" class=\"headerlink\" title=\"git reset\"></a>git reset</h3><ul>\n<li>将已经加到缓存区的内容（仅打了本地 commit），移除到工作区</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git reset HEAD</span><br><span class=\"line\"></span><br><span class=\"line\">$ git reset HEAD~2</span><br></pre></td></tr></table></figure>\n<ul>\n<li>从缓存区重置，不删除修改的地方</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 将缓存区中的指定文件，移到工作区</span></span><br><span class=\"line\"><span class=\"comment\">// 缓存区中的，指的是 add 后的</span></span><br><span class=\"line\">git reset &lt;file&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将缓存区中的全部文件，移到工作区</span></span><br><span class=\"line\">$ git reset</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将本地 commit 历史中的 commit 移除到 工作区 （未 add 状态）</span></span><br><span class=\"line\">$ git reset [commit_id]</span><br></pre></td></tr></table></figure>\n<h3 id=\"删除式-reset\"><a href=\"#删除式-reset\" class=\"headerlink\" title=\"删除式 reset\"></a>删除式 reset</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 缓存区和工作区的，都会被完全移除（删除）</span></span><br><span class=\"line\">$ git reset --hard</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将本地 commit 历史中的直接删除</span></span><br><span class=\"line\">$ git reset --hard &lt;commit&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span><br><span class=\"line\">$ git reset --keep [commit]</span><br></pre></td></tr></table></figure>\n<p>参考：<br><a href=\"http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html\" target=\"_blank\" rel=\"noopener\">常用 Git 命令清单 - 阮一峰</a><br><a href=\"http://www.ruanyifeng.com/blog/2014/06/git_remote.html\" target=\"_blank\" rel=\"noopener\">Git远程操作详解 - 阮一峰</a><br><a href=\"http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001375234012342f90be1fc4d81446c967bbdc19e7c03d3000\" target=\"_blank\" rel=\"noopener\">Git 配置别名 - 廖雪峰</a><br><a href=\"https://github.com/geeeeeeeeek/git-recipes/wiki\" target=\"_blank\" rel=\"noopener\">果壳中的 Git</a></p>\n<p>特别推荐：<br><a href=\"https://github.com/jaywcjlove/handbook/blob/master/other/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B8%85%E5%8D%95.md\" target=\"_blank\" rel=\"noopener\"> jaywcjlove —— Git常用命令清单</a></p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cjumvmx9c0000raxezm38r3fq","category_id":"cjumvmx9l0004raxerk26ova5","_id":"cjumvmx9v000fraxe1ke61bay"},{"post_id":"cjumvmx9i0002raxe45yc8cg3","category_id":"cjumvmx9l0004raxerk26ova5","_id":"cjumvmx9w000iraxewosoz0ve"},{"post_id":"cjumvmx9n0006raxe2mb93ezo","category_id":"cjumvmx9v000eraxewyudm331","_id":"cjumvmx9x000nraxesqugtnaj"},{"post_id":"cjumvmx9o0007raxegfoijiz0","category_id":"cjumvmx9v000eraxewyudm331","_id":"cjumvmx9y000praxenw81an73"},{"post_id":"cjumvmx9q0008raxef9fnimws","category_id":"cjumvmx9x000mraxeqp4hw1g1","_id":"cjumvmxa0000rraxezx9qv3xk"},{"post_id":"cjumvmx9u000draxe8mvgloel","category_id":"cjumvmx9y000qraxe76fv3hya","_id":"cjumvmxa0000sraxeyog0uef7"},{"post_id":"cjumvmxa5000traxesay80r6w","category_id":"cjumvmx9x000mraxeqp4hw1g1","_id":"cjumvmxac0010raxehvhmcojc"},{"post_id":"cjumvmxa8000vraxewx2ovgmg","category_id":"cjumvmx9x000mraxeqp4hw1g1","_id":"cjumvmxad0013raxeg32ws510"},{"post_id":"cjumvmxaa000xraxe2u546xf7","category_id":"cjumvmx9x000mraxeqp4hw1g1","_id":"cjumvmxae0016raxev2lf6qzl"},{"post_id":"cjumvmxad0015raxeabcn5f3n","category_id":"cjumvmx9v000eraxewyudm331","_id":"cjumvmxaf001araxej0nzsij4"},{"post_id":"cjumvmxac0012raxeuys0n56i","category_id":"cjumvmxae0017raxe0nfhz110","_id":"cjumvmxag001craxetkr9cc15"}],"PostTag":[{"post_id":"cjumvmx9c0000raxezm38r3fq","tag_id":"cjumvmx9m0005raxe8bgxnac2","_id":"cjumvmx9s000braxe3l74yyw2"},{"post_id":"cjumvmx9i0002raxe45yc8cg3","tag_id":"cjumvmx9m0005raxe8bgxnac2","_id":"cjumvmx9w000hraxefys1z80d"},{"post_id":"cjumvmx9q0008raxef9fnimws","tag_id":"cjumvmx9v000graxeerwbiuir","_id":"cjumvmx9x000lraxehzjv03xp"},{"post_id":"cjumvmx9u000draxe8mvgloel","tag_id":"cjumvmx9x000kraxemb941mxb","_id":"cjumvmx9y000oraxeamali50t"},{"post_id":"cjumvmxa5000traxesay80r6w","tag_id":"cjumvmx9v000graxeerwbiuir","_id":"cjumvmxaa000wraxeh71y6qjw"},{"post_id":"cjumvmxa8000vraxewx2ovgmg","tag_id":"cjumvmx9v000graxeerwbiuir","_id":"cjumvmxab000yraxetnh5iqde"},{"post_id":"cjumvmxaa000xraxe2u546xf7","tag_id":"cjumvmx9v000graxeerwbiuir","_id":"cjumvmxac0011raxefm1t9bmq"},{"post_id":"cjumvmxab000zraxeqn4gl83z","tag_id":"cjumvmxad0014raxepck7lqb7","_id":"cjumvmxaf0019raxejte80myh"},{"post_id":"cjumvmxac0012raxeuys0n56i","tag_id":"cjumvmxaf0018raxefaf07h2l","_id":"cjumvmxag001draxenleb62gp"},{"post_id":"cjumvmxad0015raxeabcn5f3n","tag_id":"cjumvmxaf001braxel0mz60m1","_id":"cjumvmxag001eraxe4lbmqkow"}],"Tag":[{"name":"CALayer","_id":"cjumvmx9m0005raxe8bgxnac2"},{"name":"CocoaPods","_id":"cjumvmx9v000graxeerwbiuir"},{"name":"spider","_id":"cjumvmx9x000kraxemb941mxb"},{"name":"runtime swizzling","_id":"cjumvmxad0014raxepck7lqb7"},{"name":"node.js","_id":"cjumvmxaf0018raxefaf07h2l"},{"name":"Git","_id":"cjumvmxaf001braxel0mz60m1"}]}}